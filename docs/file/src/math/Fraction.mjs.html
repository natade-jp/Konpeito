<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/math/Fraction.mjs | konpeito</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="The collection of javascirpt library such as numerical calculation."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="konpeito"><meta property="twitter:description" content="The collection of javascirpt library such as numerical calculation."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/natade-jp/konpeito.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/konpeito.mjs~konpeito.html">konpeito</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math">math</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/BigDecimal.mjs~BigDecimal.html">BigDecimal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/BigInteger.mjs~BigInteger.html">BigInteger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/Complex.mjs~Complex.html">Complex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/Fraction.mjs~Fraction.html">Fraction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/Matrix.mjs~Matrix.html">Matrix</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-BigDecimalDivideType">BigDecimalDivideType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-MatrixSettings">MatrixSettings</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-context">math/context</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/context/MathContext.mjs~MathContext.html">MathContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/context/RoundingMode.mjs~RoundingMode.html">RoundingMode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/context/RoundingMode.mjs~RoundingModeEntity.html">RoundingModeEntity</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-tools">math/tools</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/LinearAlgebra.mjs~LinearAlgebra.html">LinearAlgebra</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/Random.mjs~Random.html">Random</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/Signal.mjs~Signal.html">Signal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/Statistics.mjs~Statistics.html">Statistics</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SignalSettings">SignalSettings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StatisticsSettings">StatisticsSettings</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/math/Fraction.mjs</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&#xFEFF;/**
 * The script is part of konpeito.
 * 
 * AUTHOR:
 *  natade (http://twitter.com/natadea)
 * 
 * LICENSE:
 *  The MIT license https://opensource.org/licenses/MIT
 */
// @ts-check

// @ts-ignore
import BigInteger from &quot;./BigInteger.mjs&quot;;

// @ts-ignore
import BigDecimal from &quot;./BigDecimal.mjs&quot;;

// @ts-ignore
import MathContext from &quot;./context/MathContext.mjs&quot;;

/**
 * Collection of functions used in Fraction.
 * @ignore
 */
class FractionTool {

	/**
	 * Create data for Fraction from strings.
	 * @param ntext {string}
	 * @return {Fraction}
	 */
	static to_fraction_data_from_number_string(ntext) {
		let scale = 0;
		let buff;
		let is_negate = false;
		// &#x6B63;&#x898F;&#x5316;
		let text = ntext.replace(/\s/g, &quot;&quot;).toLowerCase();
		// +-&#x306E;&#x7B26;&#x53F7;&#x304C;&#x3042;&#x308B;&#x304B;
		const number_text = [];
		buff = text.match(/^[+-]+/);
		if(buff !== null) {
			buff = buff[0];
			text = text.substr(buff.length);
			if(buff.indexOf(&quot;-&quot;) !== -1) {
				is_negate = true;
				number_text.push(&quot;-&quot;);
			}
		}
		// &#x6574;&#x6570;&#x90E8;&#x304C;&#x3042;&#x308B;&#x304B;
		buff = text.match(/^[0-9]+/);
		if(buff !== null) {
			buff = buff[0];
			text = text.substr(buff.length);
			number_text.push(buff);
		}
		// &#x6D6E;&#x52D5;&#x5C0F;&#x6570;&#x70B9;&#x306E;&#x8A08;&#x7B97;&#x304C;&#x306A;&#x3044;&#x5834;&#x5408;&#x306F;&#x3053;&#x3053;&#x3067;&#x5B8C;&#x4E86;
		if(text.length === 0) {
			return new Fraction([new BigInteger([number_text.join(&quot;&quot;), 10]), BigInteger.ONE]);
		}
		// &#x5DE1;&#x56DE;&#x5C0F;&#x6570;&#x70B9;&#x6307;&#x5B9A;&#x304C;&#x3042;&#x308B;&#x304B;
		let cyclic_decimal = null;
		if(/[()&apos;&quot;[\]]/.test(text)) {
			const match_data = text.match(/([^.]*)\.(\d*)[([&apos;&quot;](\d+)[)\]&apos;&quot;](.*)/);
			if(match_data === null) {
				throw &quot;Fraction Unsupported argument &quot; + text;
			}
			// &#x5DE1;&#x56DE;&#x5C11;&#x6570;&#x306E;&#x5834;&#x6240;
			const cyclic_decimal_scale = match_data[2].length;
			const cyclic_decimal_text = match_data[3];
			// &#x5DE1;&#x56DE;&#x5C11;&#x6570;&#x4EE5;&#x5916;&#x3092;&#x62BD;&#x51FA;
			if(cyclic_decimal_scale === 0) {
				text = match_data[1] + match_data[4];
			}
			else {
				text = match_data[1] + &quot;.&quot; + match_data[2] + match_data[4];
			}

			const numerator = new BigInteger([cyclic_decimal_text, 10]);
			const denominator_string = [];
			for(let i = 0; i &lt; cyclic_decimal_text.length; i++) {
				denominator_string.push(&quot;9&quot;);
			}
			const denominator = new BigInteger([denominator_string.join(&quot;&quot;), 10]);
			cyclic_decimal = new Fraction([numerator, denominator]);
			cyclic_decimal = cyclic_decimal.scaleByPowerOfTen(-cyclic_decimal_scale);
		}
		// &#x5C0F;&#x6570;&#x90E8;&#x304C;&#x3042;&#x308B;&#x304B;
		buff = text.match(/^\.[0-9]+/);
		if(buff !== null) {
			buff = buff[0];
			text = text.substr(buff.length);
			buff = buff.substr(1);
			scale = scale + buff.length;
			number_text.push(buff);
		}
		// &#x6307;&#x6570;&#x8868;&#x8A18;&#x304C;&#x3042;&#x308B;&#x304B;
		buff = text.match(/^e[+-]?[0-9]+/);
		if(buff !== null) {
			buff = buff[0].substr(1);
			scale = scale - parseInt(buff, 10);
		}

		let f = null;
		{
			let numerator = null;
			let denominator = null;
			// &#x51FA;&#x529B;&#x7528;&#x306E;&#x6587;&#x5B57;&#x3092;&#x4F5C;&#x6210;
			if(scale === 0) {
				numerator = new BigInteger([number_text.join(&quot;&quot;), 10]);
				denominator = BigInteger.ONE;
			}
			if(scale &lt; 0) {
				for(let i = 0; i &lt; -scale; i++) {
					number_text.push(&quot;0&quot;);
				}
				numerator = new BigInteger([number_text.join(&quot;&quot;), 10]);
				denominator = BigInteger.ONE;
			}
			else if(scale &gt; 0) {
				numerator = new BigInteger([number_text.join(&quot;&quot;), 10]);
				const denominator_string = [&quot;1&quot;];
				for(let i = 0; i &lt; scale; i++) {
					denominator_string.push(&quot;0&quot;);
				}
				denominator = new BigInteger([denominator_string.join(&quot;&quot;), 10]);
			}
			f = new Fraction([numerator, denominator]);
		}
		if(cyclic_decimal) {
			if(!is_negate) {
				f = f.add(cyclic_decimal);
			}
			else {
				f = f.sub(cyclic_decimal);
			}
		}
		return f;
	}

	/**
	 * Create data for Fraction from fractional string.
	 * @param ntext {string}
	 * @return {Fraction}
	 */
	static to_fraction_data_from_fraction_string(ntext) {
		if(ntext.indexOf(&quot;/&quot;) === -1) {
			return FractionTool.to_fraction_data_from_number_string(ntext);
		}
		else {
			const fraction_value = ntext.split(&quot;/&quot;);
			const numerator_value = FractionTool.to_fraction_data_from_number_string(fraction_value[0]);
			const denominator_value = FractionTool.to_fraction_data_from_number_string(fraction_value[1]);
			return numerator_value.div(denominator_value);
		}
	}

	/**
	 * Create data for Fraction from number.
	 * @param value {number}
	 * @return {Fraction}
	 */
	static to_fraction_data_from_number(value) {
		let numerator = null;
		let denominator = null;
		// &#x6574;&#x6570;
		if(value === Math.floor(value)) {
			numerator = new BigInteger(value);
			denominator = BigInteger.ONE;
		}
		// &#x6D6E;&#x52D5;&#x5C0F;&#x6570;
		else {
			let scale = Math.trunc(Math.log(Math.abs(value)) / Math.log(10));
			let x = value / Math.pow(10, scale);
			// &#x30B9;&#x30B1;&#x30FC;&#x30EB;&#x3092;&#x9006;&#x306B;&#x3059;&#x308B;
			scale = - scale;
			for(let i = 0; i &lt; 14; i++) {
				x = x * 10;
				scale = scale + 1;
				if(Math.abs(x - Math.round(x)) &lt;= Number.EPSILON) {
					break;
				}
			}
			// &#x6700;&#x3082;&#x4E0B;&#x306E;&#x6841;&#x306F;&#x56DB;&#x6368;&#x4E94;&#x5165;&#x3059;&#x308B;
			x = Math.round(x * 1e14) / 1e14;
			if(scale &lt;= 0) {
				numerator = new BigInteger(value);
				denominator = BigInteger.ONE;
			}
			else {
				numerator = new BigInteger(x);
				const denominator_string = [&quot;1&quot;];
				for(let i = 0; i &lt; scale; i++) {
					denominator_string.push(&quot;0&quot;);
				}
				denominator = new BigInteger([denominator_string.join(&quot;&quot;), 10]);
			}
		}
		return new Fraction([numerator, denominator]);
	}

	/**
	 * Normalization.
	 * - Reduce fraction using gcd.
	 * - Add the sign to the numerator.
	 * - If the number is zero, the denominator is one.
	 * @param value {Fraction}
	 */
	static normalization(value) {
		if(value.denominator.equals(BigInteger.ONE)) {
			return;
		}
		if(value.denominator.equals(BigInteger.MINUS_ONE)) {
			value.numerator = value.numerator.negate();
			value.denominator = BigInteger.ONE;
			return;
		}
		if(value.numerator.equals(BigInteger.ZERO)) {
			value.denominator = BigInteger.ONE;
			return;
		}
		const gcd = value.numerator.gcd(value.denominator);
		let numerator = value.numerator.div(gcd);
		let denominator = value.denominator.div(gcd);
		if(denominator.sign() &lt; 0) {
			numerator = numerator.negate();
			denominator = denominator.negate();
		}
		value.numerator = numerator;
		value.denominator = denominator;
	}

}

/**
 * Fraction class (immutable).
 */
export default class Fraction {

	/**
	 * Create an fraction.
	 * 
	 * Initialization can be performed as follows.
	 * - 10, &quot;10&quot;, &quot;10/1&quot;, &quot;10.0/1.0&quot;, [&quot;10&quot;, &quot;1&quot;], [10, 1]
	 * - 0.01, &quot;0.01&quot;, &quot;0.1e-1&quot;, &quot;1/100&quot;, [1, 100], [2, 200], [&quot;2&quot;, &quot;200&quot;]
	 * - &quot;1/3&quot;, &quot;0.[3]&quot;, &quot;0.(3)&quot;, &quot;0.&apos;3&apos;&quot;, &quot;0.&quot;3&quot;&quot;, [1, 3], [2, 6]
	 * - &quot;3.555(123)&quot; = 3.555123123123..., &quot;147982 / 41625&quot;
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} [number] - Fraction data. See how to use the function.
	 */
	constructor(number) {
		
		// &#x5206;&#x5B50;
		/**
		 * @type {BigInteger}
		 */
		this.numerator = null;

		// &#x5206;&#x6BCD;
		/**
		 * @type {BigInteger}
		 */
		this.denominator = null;

		if(arguments.length === 0) {
			this.numerator = BigInteger.ZERO;
			this.denominator = BigInteger.ONE;
		}
		else if(arguments.length === 1) {
			let is_normalization = false;
			if(typeof number === &quot;number&quot;) {
				const x = FractionTool.to_fraction_data_from_number(number);
				this.numerator = x.numerator;
				this.denominator = x.denominator;
			}
			else if(typeof number === &quot;string&quot;) {
				const x = FractionTool.to_fraction_data_from_fraction_string(number);
				this.numerator = x.numerator;
				this.denominator = x.denominator;
			}
			else if(number instanceof BigInteger) {
				this.numerator = number;
				this.denominator = BigInteger.ONE;
			}
			else if(number instanceof Fraction) {
				this.numerator = number.numerator;
				this.denominator = number.denominator;
			}
			else if((number instanceof Array) &amp;&amp; (number.length === 2)) {
				this.numerator = (number[0] instanceof BigInteger) ? number[0] : new BigInteger(number[0]);
				this.denominator = (number[1] instanceof BigInteger) ? number[1] : new BigInteger(number[1]);
				is_normalization = true;
			}
			else if((number instanceof Object) &amp;&amp; number.numerator &amp;&amp; number.denominator) {
				this.numerator = (number.numerator instanceof BigInteger) ? number.numerator : new BigInteger(number.numerator);
				this.denominator = (number.denominator instanceof BigInteger) ? number.denominator : new BigInteger(number.denominator);
				is_normalization = true;
			}
			else if(number instanceof BigDecimal) {
				const value = new Fraction(number.unscaledValue());
				const x = value.scaleByPowerOfTen(-number.scale());
				this.numerator = x.numerator;
				this.denominator = x.denominator;
			}
			else if((number instanceof Object) &amp;&amp; (number.doubleValue)) {
				const x = FractionTool.to_fraction_data_from_number(number.doubleValue);
				this.numerator = x.numerator;
				this.denominator = x.denominator;
			}
			else if(number instanceof Object) {
				const x1 = FractionTool.to_fraction_data_from_fraction_string(number.toString());
				this.numerator = x1.numerator;
				this.denominator = x1.denominator;
			}
			else {
				throw &quot;Fraction Unsupported argument &quot; + number;
			}
			if(is_normalization) {
				FractionTool.normalization(this);
			}
		}
		else {
			throw &quot;Fraction Unsupported argument &quot; + number;
		}
	}

	/**
	 * Create an entity object of this class.
	 * @returns {Fraction}
	 */
	static create(number) {
		if(number instanceof Fraction) {
			return number;
		}
		else {
			return new Fraction(number);
		}
	}

	/**
	 * Convert number to Fraction type.
	 * @returns {Fraction}
	 */
	static valueOf(number) {
		return Fraction.create(number);
	}

	/**
	 * Convert to Fraction.
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} number 
	 * @returns {Fraction}
	 * @private
	 */
	static _toFraction(number) {
		if(number instanceof Fraction) {
			return number;
		}
		else {
			return new Fraction(number);
		}
	}

	/**
	 * Convert to real number.
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} number 
	 * @returns {number}
	 * @private
	 */
	static _toFloat(number) {
		if(typeof number === &quot;number&quot;) {
			return number;
		}
		else if(number instanceof Fraction) {
			return number.doubleValue;
		}
		else {
			return (new Fraction(number)).doubleValue;
		}
	}

	/**
	 * Convert to integer.
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} number 
	 * @returns {number}
	 * @private
	 */
	static _toInteger(number) {
		if(typeof number === &quot;number&quot;) {
			return Math.trunc(number);
		}
		else if(number instanceof Fraction) {
			return number.intValue;
		}
		else {
			return (new Fraction(number)).intValue;
		}
	}

	/**
	 * Deep copy.
	 * @returns {Fraction} 
	 */
	clone() {
		return new Fraction(this);
	}

	/**
	 * Absolute value.
	 * @returns {Fraction} abs(A)
	 */
	abs() {
		if(this.sign() &gt;= 0) {
			return this;
		}
		return this.negate();
	}

	/**
	 * this * -1
	 * @returns {Fraction} -A
	 */
	negate() {
		return new Fraction([this.numerator.negate(), this.denominator]);
	}

	/**
	 * The positive or negative sign of this number.
	 * - +1 if positive, -1 if negative, 0 if 0.
	 * @returns {number}
	 */
	sign() {
		return this.numerator.sign();
	}
	
	/**
	 * Convert to string.
	 * @returns {string} 
	 */
	toString() {
		return this.numerator.toString() + &quot; / &quot; + this.denominator.toString();
	}

	// ----------------------
	// &#x56DB;&#x5247;&#x6F14;&#x7B97;
	// ----------------------
	
	/**
	 * Add.
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} num
	 * @return {Fraction}
	 */
	add(num) {
		const x = this;
		const y = Fraction._toFraction(num);
		let f;
		if(x.isInteger() &amp;&amp; y.isInteger()) {
			f = new Fraction([ x.numerator.add(y.numerator), BigInteger.ONE]);
		}
		else {
			f = new Fraction([
				x.numerator.mul(y.denominator).add(y.numerator.mul(x.denominator)),
				x.denominator.mul(y.denominator)
			]);
		}
		return f;
	}

	/**
	 * Subtract.
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} num
	 * @return {Fraction}
	 */
	sub(num) {
		const x = this;
		const y = Fraction._toFraction(num);
		let f;
		if(x.isInteger() &amp;&amp; y.isInteger()) {
			f = new Fraction([ x.numerator.sub(y.numerator), BigInteger.ONE]);
		}
		else {
			f = new Fraction([
				x.numerator.mul(y.denominator).sub(y.numerator.mul(x.denominator)),
				x.denominator.mul(y.denominator)
			]);
		}
		return f;
	}

	/**
	 * Multiply.
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} num
	 * @return {Fraction}
	 */
	mul(num) {
		const x = this;
		const y = Fraction._toFraction(num);
		let f;
		if(x.isInteger() &amp;&amp; y.isInteger()) {
			f = new Fraction([ x.numerator.mul(y.numerator), BigInteger.ONE]);
		}
		else {
			f = new Fraction([ x.numerator.mul(y.numerator), x.denominator.mul(y.denominator) ]);
		}
		return f;
	}

	/**
	 * Divide.
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} num
	 * @return {Fraction}
	 */
	div(num) {
		const x = this;
		const y = Fraction._toFraction(num);
		let f;
		if(x.isInteger() &amp;&amp; y.isInteger()) {
			f = new Fraction([ x.numerator, y.numerator]);
		}
		else {
			f = new Fraction([ x.numerator.mul(y.denominator), y.numerator.mul(x.denominator)]);
		}
		return f;
	}

	/**
	 * Inverse number of this value.
	 * @return {Fraction}
	 */
	inv() {
		return new Fraction([ this.denominator, this.numerator]);
	}

	/**
	 * Modulo, positive remainder of division.
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} num
	 * @return {Fraction}
	 */
	mod(num) {
		const x = this;
		const y = Fraction._toFraction(num);
		// x - y * floor(x/y)
		return x.sub(y.mul(x.div(y).floor()));
	}

	/**
	 * Power function.
	 * - Supports only integers.
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} num
	 * @returns {Fraction} pow(A, B)
	 */
	pow(num) {
		const x = this;
		const y = Fraction._toInteger(num);
		const numerator = x.numerator.pow(y);
		const denominator = x.denominator.pow(y);
		return new Fraction([ numerator, denominator ]);
	}

	// ----------------------
	// &#x305D;&#x306E;&#x4ED6;&#x306E;&#x6F14;&#x7B97;
	// ----------------------
	
	/**
	 * Factorial function, x!.
	 * - Supports only integers.
	 * @returns {Fraction} n!
	 */
	factorial() {
		return new Fraction([this.toBigInteger().factorial(), Fraction.ONE]);
	}

	/**
	 * Multiply a multiple of ten.
	 * - Supports only integers.
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} n
	 * @returns {Fraction}
	 */
	scaleByPowerOfTen(n) {
		const scale = Fraction._toInteger(n);
		if(scale === 0) {
			return this;
		}
		let f;
		if(scale &gt; 0) {
			f = new Fraction([ this.numerator.scaleByPowerOfTen(scale), this.denominator]);
		}
		else if(scale &lt; 0) {
			f = new Fraction([ this.numerator, this.denominator.scaleByPowerOfTen(-scale)]);
		}
		return f;
	}

	// ----------------------
	// &#x4ED6;&#x306E;&#x578B;&#x306B;&#x5909;&#x63DB;&#x7528;
	// ----------------------
	
	/**
	 * integer value.
	 * @returns {number}
	 */
	get intValue() {
		if(this.isInteger()) {
			return Math.trunc(this.numerator.doubleValue);
		}
		return Math.trunc(this.doubleValue);
	}

	/**
	 * floating point.
	 * @returns {number}
	 */
	get doubleValue() {
		if(this.isInteger()) {
			return this.numerator.doubleValue;
		}
		const x = new BigDecimal([this.numerator, MathContext.UNLIMITED]);
		const y = new BigDecimal([this.denominator, MathContext.UNLIMITED]);
		return x.div(y, {context : MathContext.DECIMAL64}).doubleValue;
	}

	/**
	 * return BigInteger.
	 * @returns {BigInteger}
	 */
	toBigInteger() {
		return new BigInteger(this.fix().numerator);
	}
	
	/**
	 * return BigDecimal.
	 * @param {MathContext} [mc] - MathContext setting after calculation. 
	 * @returns {BigDecimal}
	 */
	toBigDecimal(mc) {
		if(this.isInteger()) {
			return new BigDecimal(this.numerator);
		}
		const x = new BigDecimal([this.numerator, MathContext.UNLIMITED]);
		const y = new BigDecimal([this.denominator, MathContext.UNLIMITED]);
		if(mc) {
			return x.div(y, {context: mc});
		}
		else {
			return x.div(y, {context: BigDecimal.getDefaultContext()});
		}
	}

	// ----------------------
	// &#x6BD4;&#x8F03;
	// ----------------------
	
	/**
	 * Equals.
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} num
	 * @returns {boolean} A === B
	 */
	equals(num) {
		const x = this;
		const y = Fraction._toFraction(num);
		return x.numerator.equals(y.numerator) &amp;&amp; x.denominator.equals(y.denominator);
	}

	/**
	 * Compare values.
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} num
	 * @returns {number} A &gt; B ? 1 : (A === B ? 0 : -1)
	 */
	compareTo(num) {
		return this.sub(num).sign();
	}

	/**
	 * Maximum number.
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} number
	 * @returns {Fraction} max([A, B])
	 */
	max(number) {
		const val = Fraction._toFraction(number);
		if(this.compareTo(val) &gt;= 0) {
			return this;
		}
		else {
			return val;
		}
	}

	/**
	 * Minimum number.
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} number
	 * @returns {Fraction} min([A, B])
	 */
	min(number) {
		const val = Fraction._toFraction(number);
		if(this.compareTo(val) &gt;= 0) {
			return val;
		}
		else {
			return this;
		}
	}

	/**
	 * Clip number within range.
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} min 
	 * @param {Fraction|BigInteger|BigDecimal|number|string|Array&lt;Object&gt;|{numerator:Object,denominator:Object}|Object} max
	 * @returns {Fraction} min(max(x, min), max)
	 */
	clip(min, max) {
		const min_ = Fraction._toFraction(min);
		const max_ = Fraction._toFraction(max);
		const arg_check = min_.compareTo(max_);
		if(arg_check === 1) {
			throw &quot;clip(min, max) error. (min &gt; max)-&gt;(&quot; + min_ + &quot; &gt; &quot; + max_ + &quot;)&quot;;
		}
		else if(arg_check === 0) {
			return min_;
		}
		if(this.compareTo(max_) === 1) {
			return max_;
		}
		else if(this.compareTo(min_) === -1) {
			return min_;
		}
		return this;
	}

	// ----------------------
	// &#x4E38;&#x3081;
	// ----------------------
	
	/**
	 * Floor.
	 * @returns {Fraction} floor(A)
	 */
	floor() {
		if(this.isInteger()) {
			return this;
		}
		const x = this.fix();
		if(this.sign() &gt; 0) {
			return x;
		}
		else {
			return new Fraction([x.numerator.sub(BigInteger.ONE), Fraction.ONE]);
		}
	}

	/**
	 * Ceil.
	 * @returns {Fraction} ceil(A)
	 */
	ceil() {
		if(this.isInteger()) {
			return this;
		}
		const x = this.fix();
		if(this.sign() &gt; 0) {
			return new Fraction([x.numerator.add(BigInteger.ONE), Fraction.ONE]);
		}
		else {
			return x;
		}
	}
	
	/**
	 * Rounding to the nearest integer.
	 * @returns {Fraction} round(A)
	 */
	round() {
		if(this.isInteger()) {
			return this;
		}
		const x = this.floor();
		const fract = this.sub(x);
		if(fract.compareTo(Fraction.HALF) &gt;= 0) {
			return new Fraction([x.numerator.add(BigInteger.ONE), Fraction.ONE]);
		}
		else {
			return x;
		}
	}

	/**
	 * To integer rounded down to the nearest.
	 * @returns {Fraction} fix(A), trunc(A)
	 */
	fix() {
		if(this.isInteger()) {
			return this;
		}
		return new Fraction([this.numerator.div(this.denominator), Fraction.ONE]);
	}

	/**
	 * Fraction.
	 * @returns {Fraction} fract(A)
	 */
	fract() {
		if(this.isInteger()) {
			return Fraction.ZERO;
		}
		return this.sub(this.floor());
	}

	// ----------------------
	// &#x30C6;&#x30B9;&#x30C8;&#x7CFB;
	// ----------------------
	
	/**
	 * Return true if the value is integer.
	 * @return {boolean}
	 */
	isInteger() {
		return this.denominator.equals(BigInteger.ONE);
	}

	/**
	 * this === 0
	 * @return {boolean} A === 0
	 */
	isZero() {
		return this.numerator.equals(BigInteger.ZERO) &amp;&amp; this.denominator.equals(BigInteger.ONE);
	}

	/**
	 * this === 1
	 * @return {boolean} A === 1
	 */
	isOne() {
		return this.numerator.equals(BigInteger.ONE) &amp;&amp; this.denominator.equals(BigInteger.ONE);
	}

	/**
	 * this &gt; 0
	 * @returns {boolean}
	 */
	isPositive() {
		return this.numerator.isPositive();
	}

	/**
	 * this &lt; 0
	 * @returns {boolean}
	 */
	isNegative() {
		return this.numerator.isNegative();
	}

	/**
	 * this &gt;= 0
	 * @returns {boolean}
	 */
	isNotNegative() {
		return this.numerator.isNotNegative();
	}

	// ----------------------
	// &#x5B9A;&#x6570;
	// ----------------------
	
	/**
	 * -1
	 * @returns {Fraction} -1
	 */
	static get MINUS_ONE() {
		return DEFINE.MINUS_ONE;
	}

	/**
	 * 0
	 * @returns {Fraction} 0
	 */
	static get ZERO() {
		return DEFINE.ZERO;
	}

	/**
	 * 0.5
	 * @returns {Fraction} 0.5
	 */
	static get HALF() {
		return DEFINE.HALF;
	}
	
	/**
	 * 1
	 * @returns {Fraction} 1
	 */
	static get ONE() {
		return DEFINE.ONE;
	}
	
	/**
	 * 2
	 * @returns {Fraction} 2
	 */
	static get TWO() {
		return DEFINE.TWO;
	}
	
	/**
	 * 10
	 * @returns {Fraction} 10
	 */
	static get TEN() {
		return DEFINE.TEN;
	}

}

/**
 * Collection of constant values used in the class.
 * @ignore
 */
const DEFINE = {

	/**
	 * -1
	 */
	MINUS_ONE : new Fraction([BigInteger.MINUS_ONE, BigInteger.ONE]),

	/**
	 * 0
	 */
	ZERO : new Fraction([BigInteger.ZERO, BigInteger.ONE]),
	
	/**
	 * 1
	 */
	ONE : new Fraction([BigInteger.ONE, BigInteger.ONE]),

	/**
	 * 0.5
	 */
	HALF : new Fraction([BigInteger.ONE, BigInteger.TWO]),

	/**
	 * 2
	 */
	TWO : new Fraction([BigInteger.TWO, BigInteger.ONE]),

	/**
	 * 10
	 */
	TEN : new Fraction([BigInteger.TEN, BigInteger.ONE])

};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
