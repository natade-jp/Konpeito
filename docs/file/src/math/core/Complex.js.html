<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/math/Complex.js | konpeito</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="The collection of javascirpt library such as numerical calculation."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="konpeito"><meta property="twitter:description" content="The collection of javascirpt library such as numerical calculation."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/natade-jp/konpeito.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/konpeito.js~konpeito.html">konpeito</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math">math</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/BigDecimal.js~BigDecimal.html">BigDecimal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/BigInteger.js~BigInteger.html">BigInteger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/Complex.js~Complex.html">Complex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/Fraction.js~Fraction.html">Fraction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/Matrix.js~Matrix.html">Matrix</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KBigDecimalDivideType">KBigDecimalDivideType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KBigDecimalInputData">KBigDecimalInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KBigDecimalLocalInputData">KBigDecimalLocalInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KBigDecimalScaleData">KBigDecimalScaleData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KBigIntegerInputData">KBigIntegerInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KComplexInputData">KComplexInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KFractionInputData">KFractionInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMatrixInputData">KMatrixInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMatrixSettings">KMatrixSettings</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-context">math/context</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/context/MathContext.js~MathContext.html">MathContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/context/RoundingMode.js~RoundingMode.html">RoundingMode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/context/RoundingMode.js~RoundingModeEntity.html">RoundingModeEntity</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-tools">math/tools</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/LinearAlgebra.js~LinearAlgebra.html">LinearAlgebra</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/Probability.js~Probability.html">Probability</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/Random.js~Random.html">Random</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/Signal.js~Signal.html">Signal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/Statistics.js~Statistics.html">Statistics</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KRandomSettings">KRandomSettings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KSignalSettings">KSignalSettings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KStatisticsSettings">KStatisticsSettings</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/math/Complex.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&#xFEFF;/**
 * The script is part of konpeito.
 * 
 * AUTHOR:
 *  natade (http://twitter.com/natadea)
 * 
 * LICENSE:
 *  The MIT license https://opensource.org/licenses/MIT
 */

import Random from &quot;./tools/Random.js&quot;;
import Matrix from &quot;./Matrix.js&quot;;

/**
 * Complex type argument.
 * - Complex
 * - number
 * - string
 * - Array&lt;number&gt;
 * - {_re:number,_im:number}
 * - {doubleValue:number}
 * - {toString:function}
 * @typedef {Complex|number|string|Array&lt;number&gt;|{_re:number,_im:number}|{doubleValue:number}|{toString:function}} KComplexInputData
 */

/**
 * Random number generation class used within Complex.
 * @type {Random}
 * @ignore
 */
const random_class = new Random();

/**
 * Collection of functions used in Complex.
 * @ignore
 */
class ComplexTool {

	/**
	 * Create data for complex numbers from strings.
	 * @param {string} text - Target strings.
	 * @returns {{real : number, imag : number}}
	 */
	static ToComplexFromString(text) {
		let str = text.replace(/\s/g, &quot;&quot;).toLowerCase();
		str = str.replace(/infinity|inf/g, &quot;1e100000&quot;);
		// &#x8907;&#x7D20;&#x6570;&#x306E;&#x5BA3;&#x8A00;&#x304C;&#x306A;&#x3044;&#x5834;&#x5408;
		if(!(/[ij]/.test(str))) {
			return {
				real : parseFloat(str),
				imag : 0.0
			};
		}
		// &#x3053;&#x306E;&#x6642;&#x70B9;&#x3067;&#x8907;&#x7D20;&#x6570;&#x3067;&#x3042;&#x308B;&#x3002;
		// &#x4EE5;&#x4E0B;&#x771F;&#x9762;&#x76EE;&#x306B;&#x8ABF;&#x67FB;
		let re = 0;
		let im = 0;
		let buff;
		// &#x6700;&#x5F8C;&#x304C;$&#x306A;&#x3089;&#x53F3;&#x5074;&#x304C;&#x5B9F;&#x6570;&#x3001;&#x6700;&#x5F8C;&#x304C;[+-]&#x306A;&#x3089;&#x5DE6;&#x5074;&#x304C;&#x5B9F;&#x6570;
		buff = str.match(/[+-]?(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan))($|[+-])/);
		if(buff) {
			re = parseFloat(buff[0]);
		}
		// &#x8907;&#x7D20;&#x6570;&#x306F;&#x6570;&#x5024;&#x304C;&#x7701;&#x7565;&#x3055;&#x308C;&#x308B;&#x5834;&#x5408;&#x304C;&#x3042;&#x308B;
		buff = str.match(/[+-]?(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan))?[ij]/);
		if(buff) {
			buff = buff[0].substring(0, buff[0].length - 1);
			// i, +i, -j &#x306E;&#x3088;&#x3046;&#x306B;&#x5B9F;&#x6570;&#x90E8;&#x304C;&#x306A;&#x304F;&#x3001;&#x6570;&#x5024;&#x3082;&#x306A;&#x3044;&#x5834;&#x5408;
			if((/^[-+]$/.test(buff)) || buff.length === 0) {
				im = buff === &quot;-&quot; ? -1 : 1;
			}
			else {
				im = parseFloat(buff);
			}
		}
		return {
			real : re,
			imag : im
		};
	}

}

/**
 * Complex number class. (immutable)
 */
export default class Complex {

	/**
	 * Create a complex number.
	 * 
	 * Initialization can be performed as follows.
	 * - 1200, &quot;1200&quot;, &quot;12e2&quot;, &quot;1.2e3&quot;
	 * - &quot;3 + 4i&quot;, &quot;4j + 3&quot;, [3, 4].
	 * @param {KComplexInputData} number - Complex number. See how to use the function.
	 */
	constructor(number) {
		// &#x884C;&#x5217;&#x3067;&#x4F7F;&#x3046;&#x305F;&#x3081;&#x30A4;&#x30DF;&#x30E5;&#x30FC;&#x30BF;&#x30D6;&#x30EB;&#x306F;&#x5FC5;&#x305A;&#x5B88;&#x308B;&#x3053;&#x3068;&#x3002;
		if(arguments.length === 1) {
			const obj = number;
			if(obj instanceof Complex) {
				
				/**
				 * The real part of this Comlex.
				 * @private
				 * @type {number}
				 */
				this._re = obj._re;
				
				/**
				 * The imaginary part of this Comlex.
				 * @private
				 * @type {number}
				 */
				this._im = obj._im;
			}
			else if(typeof obj === &quot;number&quot;) {
				this._re = obj;
				this._im = 0.0;
			}
			else if(typeof obj === &quot;string&quot;) {
				const x = ComplexTool.ToComplexFromString(obj);
				this._re = x.real;
				this._im = x.imag;
			}
			else if(obj instanceof Array) {
				if(obj.length === 2) {
					this._re = obj[0];
					this._im = obj[1];
				}
				else {
					throw &quot;Complex Unsupported argument &quot; + arguments;
				}
			}
			else if(&quot;doubleValue&quot; in obj) {
				this._re = obj.doubleValue;
				this._im = 0.0;
			}
			else if((&quot;_re&quot; in obj) &amp;&amp; (&quot;_im&quot; in obj)) {
				this._re = obj._re;
				this._im = obj._im;
			}
			else if(obj instanceof Object) {
				const x = ComplexTool.ToComplexFromString(obj.toString());
				this._re = x.real;
				this._im = x.imag;
			}
			else {
				throw &quot;Complex Unsupported argument &quot; + arguments;
			}
		}
		else {
			throw &quot;Complex Many arguments : &quot; + arguments.length;
		}
	}

	/**
	 * Create an entity object of this class.
	 * @param {KComplexInputData} number
	 * @returns {Complex}
	 */
	static create(number) {
		if(number instanceof Complex) {
			return number;
		}
		else {
			return new Complex(number);
		}
	}
	
	/**
	 * Convert number to Complex type.
	 * @param {KComplexInputData} number
	 * @returns {Complex}
	 */
	static valueOf(number) {
		return Complex.create(number);
	}
	
	/**
	 * Convert to Complex.
	 * If type conversion is unnecessary, return the value as it is.
	 * @param {KComplexInputData} number 
	 * @returns {Complex}
	 * @private
	 */
	static _toComplex(number) {
		if(number instanceof Complex) {
			return number;
		}
		else if(number instanceof Matrix) {
			return Matrix._toComplex(number);
		}
		else {
			return new Complex(number);
		}
	}

	/**
	 * Convert to real number.
	 * @param {KComplexInputData} number 
	 * @returns {number}
	 * @private
	 */
	static _toDouble(number) {
		if(typeof number === &quot;number&quot;) {
			return number;
		}
		const complex_number = Complex._toComplex(number);
		if(complex_number.isReal()) {
			return complex_number.real;
		}
		else {
			throw &quot;not support complex numbers.[&quot; + number + &quot;]&quot;;
		}
	}

	/**
	 * Convert to integer.
	 * @param {KComplexInputData} number 
	 * @returns {number}
	 * @private
	 */
	static _toInteger(number) {
		return Math.trunc(Complex._toDouble(number));
	}

	/**
	 * integer value.
	 * @returns {number}
	 */
	get intValue() {
		return Math.trunc(this.real);
	}

	/**
	 * floating point.
	 * @returns {number}
	 */
	get doubleValue() {
		return this.real;
	}

	/**
	 * Deep copy.
	 * @returns {Complex} 
	 */
	clone() {
		return this;
	}

	/**
	 * Convert to string.
	 * @returns {string} 
	 */
	toString() {
		/**
		 * @type {function(number): string }
		 */
		const formatG = function(x) {
			let numstr = x.toPrecision(6);
			if(numstr.indexOf(&quot;.&quot;) !== -1) {
				numstr = numstr.replace(/\.?0+$/, &quot;&quot;);  // 1.00 , 1.10
				numstr = numstr.replace(/\.?0+e/, &quot;e&quot;); // 1.0e , 1.10e
			}
			else if(/inf/i.test(numstr)) {
				if(x === Number.POSITIVE_INFINITY) {
					return &quot;Inf&quot;;
				}
				else {
					return &quot;-Inf&quot;;
				}
			}
			else if(/nan/i.test(numstr)) {
				return &quot;NaN&quot;;
			}
			return numstr;
		};
		if(!this.isReal()) {
			if(this._re === 0) {
				return formatG(this._im) + &quot;i&quot;;
			}
			else if((this._im &gt;= 0) || (Number.isNaN(this._im))) {
				return formatG(this._re) + &quot; + &quot; + formatG(this._im) + &quot;i&quot;;
			}
			else {
				return formatG(this._re) + &quot; - &quot; + formatG(-this._im) + &quot;i&quot;;
			}
		}
		else {
			return formatG(this._re);
		}
	}
	
	/**
	 * Create random values with uniform random numbers.
	 * @returns {Complex}
	 */
	static rand() {
		return new Complex(random_class.nextDouble());
	}

	/**
	 * Create random values with normal distribution.
	 * @returns {Complex}
	 */
	static randn() {
		return new Complex(random_class.nextGaussian());
	}

	/**
	 * The real part of this Comlex.
	 * @returns {number} real(A)
	 */
	get real() {
		return this._re;
	}
	
	/**
	 * The imaginary part of this Comlex.
	 * @returns {number} imag(A)
	 */
	get imag() {
		return this._im;
	}

	/**
	 * norm.
	 * @returns {number} |A|
	 */
	get norm() {
		if(this._im === 0) {
			return Math.abs(this._re);
		}
		else if(this._re === 0) {
			return Math.abs(this._im);
		}
		else {
			return Math.sqrt(this._re * this._re + this._im * this._im);
		}
	}

	/**
	 * The argument of this complex number.
	 * @returns {number} arg(A)
	 */
	get arg() {
		if(this._im === 0) {
			return this._re &gt;= 0 ? 0 : Math.PI;
		}
		else if(this._re === 0) {
			return Math.PI * (this._im &gt;= 0.0 ? 0.5 : -0.5);
		}
		else {
			return Math.atan2(this._im, this._re);
		}
	}

	/**
	 * Return number of decimal places for real and imaginary parts.
	 * - Used to make a string.
	 * @returns {number} Number of decimal places.
	 */
	getDecimalPosition() {
		/**
		 * @type {function(number): number }
		 */
		const getDecimal = function(x) {
			if(!Number.isFinite(x)) {
				return 0;
			}
			let a = x;
			let point = 0;
			for(let i = 0; i &lt; 20; i++) {
				if(Math.abs(a - Math.round(a)) &lt;= Number.EPSILON) {
					break;
				}
				a *= 10;
				point++;
			}
			return point;
		};
		return Math.max( getDecimal(this.real), getDecimal(this.imag) );
	}

	/**
	 * The positive or negative sign of this number.
	 * - +1 if positive, -1 if negative, 0 if 0.
	 * @returns {Complex} 
	 */
	sign() {
		if(this._im === 0) {
			if(this._re === 0) {
				return new Complex(0);
			}
			else {
				return new Complex(this._re &gt; 0 ? 1 : -1);
			}
		}
		return this.div(this.norm);
	}
	
	// ----------------------
	// &#x56DB;&#x5247;&#x6F14;&#x7B97;
	// ----------------------
	
	/**
	 * Add.
	 * @param {KComplexInputData} number 
	 * @returns {Complex} A + B
	 */
	add(number) {
		const x = new Complex(number);
		x._re = this._re + x._re;
		x._im = this._im + x._im;
		return x;
	}

	/**
	 * Subtract.
	 * @param {KComplexInputData} number
	 * @returns {Complex} A - B
	 */
	sub(number) {
		const x = new Complex(number);
		x._re = this._re - x._re;
		x._im = this._im - x._im;
		return x;
	}

	/**
	 * Multiply.
	 * @param {KComplexInputData} number
	 * @returns {Complex} A * B
	 */
	mul(number) {
		const x = new Complex(number);
		if((this._im === 0) &amp;&amp; (x._im === 0)) {
			x._re = this._re * x._re;
			return x;
		}
		else if((this._re === 0) &amp;&amp; (x._re === 0)) {
			x._re = - this._im * x._im;
			x._im = 0;
			return x;
		}
		else {
			const re = this._re * x._re - this._im * x._im;
			const im = this._im * x._re + this._re * x._im;
			x._re = re;
			x._im = im;
			return x;
		}
	}
	
	/**
	 * Inner product/Dot product.
	 * @param {KComplexInputData} number
	 * @returns {Complex} A * conj(B)
	 */
	dot(number) {
		const x = new Complex(number);
		if((this._im === 0) &amp;&amp; (x._im === 0)) {
			x._re = this._re * x._re;
			return x;
		}
		else if((this._re === 0) &amp;&amp; (x._re === 0)) {
			x._re = this._im * x._im;
			x._im = 0;
			return x;
		}
		else {
			const re = this._re * x._re + this._im * x._im;
			const im = - this._im * x._re + this._re * x._im;
			x._re = re;
			x._im = im;
			return x;
		}
	}
	
	/**
	 * Divide.
	 * @param {KComplexInputData} number
	 * @returns {Complex} A / B
	 */
	div(number) {
		const x = new Complex(number);
		if((this._im === 0) &amp;&amp; (x._im === 0)) {
			x._re = this._re / x._re;
			return x;
		}
		else if((this._re === 0) &amp;&amp; (x._re === 0)) {
			x._re = this._im / x._im;
			x._im = 0;
			return x;
		}
		else {
			const re = this._re * x._re + this._im * x._im;
			const im = this._im * x._re - this._re * x._im;
			const denominator = 1.0 / (x._re * x._re + x._im * x._im);
			x._re = re * denominator;
			x._im = im * denominator;
			return x;
		}
	}

	/**
	 * Modulo, positive remainder of division.
	 * @param {KComplexInputData} number - Divided value (real number only).
	 * @returns {Complex} A mod B
	 */
	mod(number) {
		const x = new Complex(number);
		if((this._im !== 0) || (x._im !== 0)) {
			throw &quot;calculation method is undefined.&quot;;
		}
		let _re = this._re - x._re * (0 | (this._re / x._re));
		if(_re &lt; 0) {
			_re += x._re;
		}
		x._re = _re;
		return x;
	}

	/**
	 * Inverse number of this value.
	 * @returns {Complex} 1 / A
	 */
	inv() {
		if(this._im === 0) {
			return new Complex(1.0 / this._re);
		}
		else if(this._re === 0) {
			return new Complex([0, - 1.0 / this._im]);
		}
		return Complex.ONE.div(this);
	}

	// ----------------------
	// &#x6BD4;&#x8F03;
	// ----------------------
	
	/**
	 * Equals.
	 * @param {KComplexInputData} number
	 * @param {KComplexInputData} [tolerance=Number.EPSILON] - Calculation tolerance of calculation.
	 * @returns {boolean} A === B
	 */
	equals(number, tolerance) {
		const x = Complex._toComplex(number);
		const tolerance_ = tolerance ? Complex._toDouble(tolerance) : Number.EPSILON;
		// &#x7121;&#x9650;&#x5927;&#x3001;&#x975E;&#x6570;&#x306E;&#x5024;&#x3082;&#x542B;&#x3081;&#x3066;&#x4E00;&#x5EA6;&#x78BA;&#x8A8D;
		if((this._re === x._re) &amp;&amp; (this._im === x._im)) {
			return true;
		}
		// &#x8AA4;&#x5DEE;&#x3092;&#x542B;&#x3093;&#x3060;&#x5024;&#x306E;&#x6BD4;&#x8F03;
		return (Math.abs(this._re - x._re) &lt;  tolerance_) &amp;&amp; (Math.abs(this._im - x._im) &lt; tolerance_);
	}

	/**
	 * Compare values.
	 * @param {KComplexInputData} number
	 * @param {KComplexInputData} [tolerance=Number.EPSILON] - Calculation tolerance of calculation.
	 * @returns {number} A &gt; B ? 1 : (A === B ? 0 : -1)
	 */
	compareTo(number, tolerance) {
		const x1 = this;
		const x2 = Complex._toComplex(number);
		const tolerance_ = tolerance ? Complex._toDouble(tolerance) : Number.EPSILON;
		const a = x1.real + x1.imag;
		const b = x2.real + x2.imag;
		if((Math.abs(a - b) &lt;= tolerance_)) {
			return 0;
		}
		return a &gt; b ? 1 : -1;
	}
	
	/**
	 * Maximum number.
	 * @param {KComplexInputData} number
	 * @returns {Complex} max([A, B])
	 */
	max(number) {
		const x = Complex._toComplex(number);
		if(this.compareTo(x) &gt;= 0) {
			return this;
		}
		else {
			return x;
		}
	}

	/**
	 * Minimum number.
	 * @param {KComplexInputData} number
	 * @returns {Complex} min([A, B])
	 */
	min(number) {
		const x = Complex._toComplex(number);
		if(this.compareTo(x) &lt;= 0) {
			return this;
		}
		else {
			return x;
		}
	}

	/**
	 * Clip number within range.
	 * @param {KComplexInputData} min 
	 * @param {KComplexInputData} max
	 * @returns {Complex} min(max(x, min), max)
	 */
	clip(min, max) {
		const min_ = Complex._toComplex(min);
		const max_ = Complex._toComplex(max);
		const arg_check = min_.compareTo(max_);
		if(arg_check === 1) {
			throw &quot;clip(min, max) error. (min &gt; max)-&gt;(&quot; + min_ + &quot; &gt; &quot; + max_ + &quot;)&quot;;
		}
		else if(arg_check === 0) {
			return min_;
		}
		if(this.compareTo(max_) === 1) {
			return max_;
		}
		else if(this.compareTo(min_) === -1) {
			return min_;
		}
		return this;
	}

	// ----------------------
	// &#x30C6;&#x30B9;&#x30C8;&#x7CFB;
	// ----------------------
	
	/**
	 * Return true if the value is integer.
	 * @param {KComplexInputData} [tolerance=Number.EPSILON] - Calculation tolerance of calculation.
	 * @returns {boolean}
	 */
	isInteger(tolerance) {
		const tolerance_ = tolerance ? Complex._toDouble(tolerance) : Number.EPSILON;
		return this.isReal() &amp;&amp; (Math.abs(this._re - Math.trunc(this._re)) &lt; tolerance_);
	}

	/**
	 * Returns true if the vallue is complex integer (including normal integer).
	 * @param {KComplexInputData} [tolerance=Number.EPSILON] - Calculation tolerance of calculation.
	 * @returns {boolean} real(A) === integer &amp;&amp; imag(A) === integer
	 */
	isComplexInteger(tolerance) {
		const tolerance_ = tolerance ? Complex._toDouble(tolerance) : Number.EPSILON;
		// &#x8907;&#x7D20;&#x6574;&#x6570;
		return (Math.abs(this._re - Math.trunc(this._re)) &lt; tolerance_) &amp;&amp;
				(Math.abs(this._im - Math.trunc(this._im)) &lt; tolerance_);
	}

	/**
	 * this === 0
	 * @param {KComplexInputData} [tolerance=Number.EPSILON] - Calculation tolerance of calculation.
	 * @returns {boolean} A === 0
	 */
	isZero(tolerance) {
		const tolerance_ = tolerance ? Complex._toDouble(tolerance) : Number.EPSILON;
		return (Math.abs(this._re) &lt; tolerance_) &amp;&amp; (Math.abs(this._im) &lt; tolerance_);
	}

	/**
	 * this === 1
	 * @param {KComplexInputData} [tolerance=Number.EPSILON] - Calculation tolerance of calculation.
	 * @returns {boolean} A === 1
	 */
	isOne(tolerance) {
		const tolerance_ = tolerance ? Complex._toDouble(tolerance) : Number.EPSILON;
		return (Math.abs(this._re - 1.0) &lt; tolerance_) &amp;&amp; (Math.abs(this._im) &lt; tolerance_);
	}

	/**
	 * Returns true if the vallue is complex number (imaginary part is not 0).
	 * @param {KComplexInputData} [tolerance=Number.EPSILON] - Calculation tolerance of calculation.
	 * @returns {boolean} imag(A) !== 0
	 */
	isComplex(tolerance) {
		const tolerance_ = tolerance ? Complex._toDouble(tolerance) : Number.EPSILON;
		return (Math.abs(this._im) &gt;= tolerance_);
	}
	
	/**
	 * Return true if the value is real number.
	 * @param {KComplexInputData} [tolerance=Number.EPSILON] - Calculation tolerance of calculation.
	 * @returns {boolean} imag(A) === 0
	 */
	isReal(tolerance) {
		const tolerance_ = tolerance ? Complex._toDouble(tolerance) : Number.EPSILON;
		return (Math.abs(this._im) &lt; tolerance_);
	}

	/**
	 * this === NaN
	 * @returns {boolean} isNaN(A)
	 */
	isNaN() {
		return isNaN(this._re) || isNaN(this._im);
	}

	/**
	 * Return true if this real part of the complex positive.
	 * @returns {boolean} real(x) &gt; 0
	 */
	isPositive() {
		// Number.EPSILON&#x306F;&#x4F7F;&#x7528;&#x3057;&#x306A;&#x3044;&#x3002;&#x3069;&#x3061;&#x3089;&#x306B;&#x3076;&#x308C;&#x308B;&#x304B;&#x4E0D;&#x660E;&#x306A;&#x70B9;&#x53CA;&#x3073;
		// &#x308F;&#x305A;&#x304B;&#x306A;&#x8CA0;&#x306E;&#x6570;&#x3060;&#x3063;&#x305F;&#x5834;&#x5408;&#x306B;&#x3001;sqrt&#x3067;&#x30A8;&#x30E9;&#x30FC;&#x304C;&#x767A;&#x751F;&#x3059;&#x308B;&#x305F;&#x3081;
		return 0.0 &lt; this._re;
	}

	/**
	 * real(this) &lt; 0
	 * @returns {boolean} real(x) &lt; 0
	 */
	isNegative() {
		return 0.0 &gt; this._re;
	}

	/**
	 * real(this) &gt;= 0
	 * @returns {boolean} real(x) &gt;= 0
	 */
	isNotNegative() {
		return 0.0 &lt;= this._re;
	}

	/**
	 * this === Infinity
	 * @returns {boolean} isInfinite(A)
	 */
	isInfinite() {
		return	(this._re === Number.POSITIVE_INFINITY) ||
				(this._im === Number.POSITIVE_INFINITY) ||
				(this._re === Number.NEGATIVE_INFINITY) ||
				(this._im === Number.NEGATIVE_INFINITY);
	}
	
	/**
	 * Return true if the value is finite number.
	 * @returns {boolean} !isNaN(A) &amp;&amp; !isInfinite(A)
	 */
	isFinite() {
		return !this.isNaN() &amp;&amp; !this.isInfinite();
	}

	// ----------------------
	// &#x8907;&#x7D20;&#x6570;
	// ----------------------
	
	/**
	 * Absolute value.
	 * @returns {Complex} abs(A)
	 */
	abs() {
		return new Complex(this.norm);
	}

	/**
	 * Complex conjugate.
	 * @returns {Complex} real(A) - imag(A)j
	 */
	conj() {
		if(this._im === 0) {
			return this;
		}
		// &#x5171;&#x5F79;&#x8907;&#x7D20;&#x6570;
		return new Complex([this._re, -this._im]);
	}

	/**
	 * this * -1
	 * @returns {Complex} -A
	 */
	negate() {
		return new Complex([-this._re, -this._im]);
	}

	// ----------------------
	// &#x6307;&#x6570;
	// ----------------------
	
	/**
	 * Power function.
	 * @param {KComplexInputData} number
	 * @returns {Complex} pow(A, B)
	 */
	pow(number) {
		const A = this;
		const B = new Complex(number);
		// -2 ^ 0.5 ... &#x8907;&#x7D20;&#x6570;
		// -2 ^ 1   ... &#x5B9F;&#x6570;
		//  2 ^ 0.5 ... &#x5B9F;&#x6570;
		if(B.isReal()) {
			if(A.isReal() &amp;&amp; (A.isNotNegative() || B.isInteger())) {
				B._re = Math.pow(A._re, B._re);
				return B;
			}
			else {
				const r = Math.pow(A.norm, B._re);
				const s = A.arg * B._re;
				B._re = r * Math.cos(s);
				B._im = r * Math.sin(s);
				return B;
			}
		}
		else {
			return B.mul(A.log()).exp();
		}
	}

	/**
	 * Square.
	 * @returns {Complex} pow(A, 2)
	 */
	square() {
		if(this._im === 0.0) {
			return new Complex(this._re * this._re);
		}
		return this.mul(this);
	}

	/**
	 * Square root.
	 * @returns {Complex} sqrt(A)
	 */
	sqrt() {
		if(this.isReal()) {
			if(this.isNotNegative()) {
				return new Complex(Math.sqrt(this._re));
			}
			else {
				return new Complex([0, Math.sqrt(-this._re)]);
			}
		}
		const r = Math.sqrt(this.norm);
		const s = this.arg * 0.5;
		return new Complex([r * Math.cos(s), r * Math.sin(s)]);
	}

	/**
	 * Reciprocal square root.
	 * @returns {Complex} rsqrt(A)
	 */
	rsqrt() {
		if(this.isReal()) {
			if(this.isNotNegative()) {
				return new Complex(1.0 / Math.sqrt(this._re));
			}
			else {
				return new Complex([0, - 1.0 / Math.sqrt(-this._re)]);
			}
		}
		return this.sqrt().inv();
	}

	/**
	 * Logarithmic function.
	 * @returns {Complex} log(A)
	 */
	log() {
		if(this.isReal() &amp;&amp; this.isNotNegative()) {
			return new Complex(Math.log(this._re));
		}
		// &#x8CA0;&#x306E;&#x5024;&#x304C;&#x5165;&#x3063;&#x3066;&#x3044;&#x308B;&#x304B;&#x3001;&#x3082;&#x3068;&#x3082;&#x3068;&#x8907;&#x7D20;&#x6570;&#x304C;&#x5165;&#x3063;&#x3066;&#x3044;&#x308B;&#x5834;&#x5408;&#x306F;&#x3001;&#x8907;&#x7D20;&#x5BFE;&#x6570;&#x95A2;&#x6570;
		return new Complex([Math.log(this.norm), this.arg]);
	}

	/**
	 * Exponential function.
	 * @returns {Complex} exp(A)
	 */
	exp() {
		if(this.isReal()) {
			return new Complex(Math.exp(this._re));
		}
		// &#x8907;&#x7D20;&#x6307;&#x6570;&#x95A2;&#x6570;
		const r = Math.exp(this._re);
		return new Complex([r * Math.cos(this._im), r * Math.sin(this._im)]);
	}

	// ----------------------
	// &#x4E09;&#x89D2;&#x95A2;&#x6570;
	// ----------------------
	
	/**
	 * Sine function.
	 * @returns {Complex} sin(A)
	 */
	sin() {
		if(this.isReal()) {
			return new Complex(Math.sin(this._re));
		}
		// &#x30AA;&#x30A4;&#x30E9;&#x30FC;&#x306E;&#x516C;&#x5F0F;&#x3088;&#x308A;
		// sin x = (e^ix - e^-ex) / 2i
		const a = this.mul(Complex.I).exp();
		const b = this.mul(Complex.I.negate()).exp();
		return a.sub(b).div([0, 2]);
	}

	/**
	 * Cosine function.
	 * @returns {Complex} cos(A)
	 */
	cos() {
		if(this.isReal()) {
			return new Complex(Math.cos(this._re));
		}
		// &#x30AA;&#x30A4;&#x30E9;&#x30FC;&#x306E;&#x516C;&#x5F0F;&#x3088;&#x308A;
		// cos x = (e^ix + e^-ex) / 2
		const a = this.mul(Complex.I).exp();
		const b = this.mul(Complex.I.negate()).exp();
		return a.add(b).div(2);
	}

	/**
	 * Tangent function.
	 * @returns {Complex} tan(A)
	 */
	tan() {
		if(this.isReal()) {
			return new Complex(Math.tan(this._re));
		}
		// &#x4E09;&#x89D2;&#x95A2;&#x6570;&#x306E;&#x76F8;&#x4E92;&#x95A2;&#x4FC2; tan x = sin x / cos x
		return this.sin().div(this.cos());
	}

	/**
	 * Atan (arc tangent) function.
	 * - Return the values of [-PI/2, PI/2].
	 * @returns {Complex} atan(A)
	 */
	atan() {
		if(this.isReal()) {
			return new Complex(Math.atan(this._re));
		}
		// &#x9006;&#x6B63;&#x63A5; tan-1 x = i/2 log( i+x / i-x )
		return Complex.I.div(Complex.TWO).mul(Complex.I.add(this).div(Complex.I.sub(this)).log());
	}

	/**
	 * Atan (arc tangent) function.
	 * Return the values of [-PI, PI] .
	 * Supports only real numbers.
	 * @param {KComplexInputData} [number] - X
	 * @returns {Complex} atan2(Y, X)
	 */
	atan2(number) {
		if(arguments.length === 0) {
			return new Complex(this.arg);
		}
		// y.atan2(x) &#x3068;&#x3059;&#x308B;&#x3002;
		const y = this;
		const x = Complex._toComplex(number);
		if(y.isReal() &amp;&amp; x.isReal()) {
			return new Complex(Math.atan2(y._re, x._re));
		}
		// &#x8907;&#x7D20;&#x6570;&#x306E;atan2&#x306F;&#x672A;&#x5B9A;&#x7FA9;&#x3067;&#x3042;&#x308B;&#xFF08;&#x5B9F;&#x88C5;&#x4E0D;&#x53EF;&#x80FD;&#xFF09;
		throw &quot;calculation method is undefined.&quot;;
	}
	
	// ----------------------
	// &#x4FE1;&#x53F7;&#x51E6;&#x7406;&#x7CFB;
	// ----------------------
	
	/**
	 * Normalized sinc function.
	 * @returns {Complex} sinc(A)
	 */
	sinc() {
		if(this.isReal()) {
			if(this._re === 0) {
				return(Complex.ONE);
			}
			const x = Math.PI * this._re;
			return new Complex(Math.sin(x) / x);
		}
		const x = this.mul(Complex.PI);
		return new Complex( x.sin().div(x) );
	}

	// ----------------------
	// &#x4E38;&#x3081;
	// ----------------------
	
	/**
	 * Floor.
	 * @returns {Complex} floor(A)
	 */
	floor() {
		return new Complex([Math.floor(this._re), Math.floor(this._im)]);
	}

	/**
	 * Ceil.
	 * @returns {Complex} ceil(A)
	 */
	ceil() {
		return new Complex([Math.ceil(this._re), Math.ceil(this._im)]);
	}
	
	/**
	 * Rounding to the nearest integer.
	 * @returns {Complex} round(A)
	 */
	round() {
		return new Complex([Math.round(this._re), Math.round(this._im)]);
	}

	/**
	 * To integer rounded down to the nearest.
	 * @returns {Complex} fix(A), trunc(A)
	 */
	fix() {
		return new Complex([Math.trunc(this._re), Math.trunc(this._im)]);
	}

	/**
	 * Fraction.
	 * @returns {Complex} fract(A)
	 */
	fract() {
		return new Complex([this._re - Math.floor(this._re), this._im - Math.floor(this._im)]);
	}

	// ----------------------
	// &#x5B9A;&#x6570;
	// ----------------------
	
	/**
	 * 1
	 * @returns {Complex} 1
	 */
	static get ONE() {
		return DEFINE.ONE;
	}
	
	/**
	 * 2
	 * @returns {Complex} 2
	 */
	static get TWO() {
		return DEFINE.TWO;
	}
	
	/**
	 * 10
	 * @returns {Complex} 10
	 */
	static get TEN() {
		return DEFINE.TEN;
	}
	
	/**
	 * 0
	 * @returns {Complex} 0
	 */
	static get ZERO() {
		return DEFINE.ZERO;
	}

	/**
	 * -1
	 * @returns {Complex} -1
	 */
	static get MINUS_ONE() {
		return DEFINE.MINUS_ONE;
	}

	/**
	 * i, j
	 * @returns {Complex} i
	 */
	static get I() {
		return DEFINE.I;
	}

	/**
	 * PI.
	 * @returns {Complex} 3.14...
	 */
	static get PI() {
		return DEFINE.PI;
	}

	/**
	 * 0.25 * PI.
	 * @returns {Complex} 0.78...
	 */
	static get QUARTER_PI() {
		return DEFINE.QUARTER_PI;
	}

	/**
	 * 0.5 * PI.
	 * @returns {Complex} 1.57...
	 */
	static get HALF_PI() {
		return DEFINE.HALF_PI;
	}

	/**
	 * 2 * PI.
	 * @returns {Complex} 6.28...
	 */
	static get TWO_PI() {
		return DEFINE.TWO_PI;
	}

	/**
	 * E, Napier&apos;s constant.
	 * @returns {Complex} 2.71...
	 */
	static get E() {
		return DEFINE.E;
	}

	/**
	 * log_e(2)
	 * @returns {Complex} ln(2)
	 */
	static get LN2() {
		return DEFINE.LN2;
	}

	/**
	 * log_e(10)
	 * @returns {Complex} ln(10)
	 */
	static get LN10() {
		return DEFINE.LN10;
	}

	/**
	 * log_2(e)
	 * @returns {Complex} log_2(e)
	 */
	static get LOG2E() {
		return DEFINE.LOG2E;
	}
	
	/**
	 * log_10(e)
	 * @returns {Complex} log_10(e)
	 */
	static get LOG10E() {
		return DEFINE.LOG10E;
	}
	
	/**
	 * sqrt(2)
	 * @returns {Complex} sqrt(2)
	 */
	static get SQRT2() {
		return DEFINE.SQRT2;
	}
	
	/**
	 * sqrt(0.5)
	 * @returns {Complex} sqrt(0.5)
	 */
	static get SQRT1_2() {
		return DEFINE.SQRT1_2;
	}
	
	/**
	 * 0.5
	 * @returns {Complex} 0.5
	 */
	static get HALF() {
		return DEFINE.HALF;
	}

	/**
	 * Positive infinity.
	 * @returns {Complex} Infinity
	 */
	static get POSITIVE_INFINITY() {
		return DEFINE.POSITIVE_INFINITY;
	}
	
	/**
	 * Negative Infinity.
	 * @returns {Complex} -Infinity
	 */
	static get NEGATIVE_INFINITY() {
		return DEFINE.NEGATIVE_INFINITY;
	}

	/**
	 * Not a Number.
	 * @returns {Complex} NaN
	 */
	static get NaN() {
		return DEFINE.NaN;
	}

}

/**
 * Collection of constant values used in the class.
 * @ignore
 */
const DEFINE = {

	/**
	 * 0
	 */
	ZERO : new Complex(0),

	/**
	 * 1
	 */
	ONE : new Complex(1),

	/**
	 * 2
	 */
	TWO : new Complex(2),

	/**
	 * 10
	 */
	TEN : new Complex(10),

	/**
	 * -1
	 */
	MINUS_ONE : new Complex(-1),

	/**
	 * i, j
	 */
	I : new Complex([0, 1]),

	/**
	 * PI.
	 */
	PI : new Complex(Math.PI),

	/**
	 * 0.25 * PI.
	 */
	QUARTER_PI : new Complex(0.25 * Math.PI),

	/**
	 * 0.5 * PI.
	 */
	HALF_PI : new Complex(0.5 * Math.PI),

	/**
	 * 2 * PI.
	 */
	TWO_PI : new Complex(2.0 * Math.PI),

	/**
	 * E, Napier&apos;s constant.
	 */
	E : new Complex(Math.E),

	/**
	 * log_e(2)
	 */
	LN2 : new Complex(Math.LN2),

	/**
	 * log_e(10)
	 */
	LN10 : new Complex(Math.LN10),

	/**
	 * log_2(e)
	 */
	LOG2E : new Complex(Math.LOG2E),

	/**
	 * log_10(e)
	 */
	LOG10E : new Complex(Math.LOG10E),

	/**
	 * sqrt(2)
	 */
	SQRT2 : new Complex(Math.SQRT2),

	/**
	 * sqrt(0.5)
	 */
	SQRT1_2 : new Complex(Math.SQRT1_2),

	/**
	 * 0.5
	 */
	HALF : new Complex(0.5),

	/**
	 * Positive infinity.
	 */
	POSITIVE_INFINITY : new Complex(Number.POSITIVE_INFINITY),

	/**
	 * Negative Infinity.
	 */
	NEGATIVE_INFINITY : new Complex(Number.NEGATIVE_INFINITY),

	/**
	 * Not a Number.
	 */
	NaN : new Complex(Number.NaN)
};

</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
