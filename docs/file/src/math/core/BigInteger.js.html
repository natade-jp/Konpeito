<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/math/core/BigInteger.js | konpeito</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="The collection of javascirpt library such as numerical calculation."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="konpeito"><meta property="twitter:description" content="The collection of javascirpt library such as numerical calculation."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/natade-jp/konpeito.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/konpeito.js~konpeito.html">konpeito</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-core">math/core</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/BigDecimal.js~BigDecimal.html">BigDecimal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/BigInteger.js~BigInteger.html">BigInteger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/Complex.js~Complex.html">Complex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/Fraction.js~Fraction.html">Fraction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/Matrix.js~Matrix.html">Matrix</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KBigDecimalDivideType">KBigDecimalDivideType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KBigDecimalInputData">KBigDecimalInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KBigDecimalLocalInputData">KBigDecimalLocalInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KBigDecimalScaleData">KBigDecimalScaleData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KBigIntegerInputData">KBigIntegerInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KComplexInputData">KComplexInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KFractionInputData">KFractionInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMatrixInputData">KMatrixInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMatrixSettings">KMatrixSettings</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-core-base">math/core/base</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/base/KonpeitoFloat.js~KonpeitoFloat.html">KonpeitoFloat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/base/KonpeitoInteger.js~KonpeitoInteger.html">KonpeitoInteger</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-core-context">math/core/context</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/context/MathContext.js~MathContext.html">MathContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/context/RoundingMode.js~RoundingMode.html">RoundingMode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/context/RoundingMode.js~RoundingModeEntity.html">RoundingModeEntity</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-core-tools">math/core/tools</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/LinearAlgebra.js~LinearAlgebra.html">LinearAlgebra</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/Probability.js~Probability.html">Probability</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/Random.js~Random.html">Random</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/Signal.js~Signal.html">Signal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/Statistics.js~Statistics.html">Statistics</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KRandomSettings">KRandomSettings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KSignalSettings">KSignalSettings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KStatisticsSettings">KStatisticsSettings</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-tools">math/tools</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/DataAnalysis.js~DataAnalysis.html">DataAnalysis</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-tools-dataanalysis">math/tools/DataAnalysis</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/DataAnalysis/MultipleRegressionAnalysis.js~MultipleRegressionAnalysis.html">MultipleRegressionAnalysis</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisAnova">KMultipleRegressionAnalysisAnova</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisOutput">KMultipleRegressionAnalysisOutput</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisPartialRegression">KMultipleRegressionAnalysisPartialRegression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisPartialRegressionData">KMultipleRegressionAnalysisPartialRegressionData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisSettings">KMultipleRegressionAnalysisSettings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisVectorState">KMultipleRegressionAnalysisVectorState</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/math/core/BigInteger.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&#xFEFF;/**
 * The script is part of konpeito.
 * 
 * AUTHOR:
 *  natade (http://twitter.com/natadea)
 * 
 * LICENSE:
 *  The MIT license https://opensource.org/licenses/MIT
 */

import Polyfill from &quot;../tools/Polyfill.js&quot;;
import Random from &quot;./tools/Random.js&quot;;
import Fraction from &quot;./Fraction.js&quot;;
import BigDecimal from &quot;./BigDecimal.js&quot;;
import Complex from &quot;./Complex.js&quot;;
import Matrix from &quot;./Matrix.js&quot;;
import MathContext from &quot;./context/MathContext.js&quot;;
import KonpeitoInteger from &quot;./base/KonpeitoInteger.js&quot;;

/**
 * BigInteger type argument.
 * - BigInteger
 * - number
 * - string
 * - Array&lt;string|number&gt;
 * - {toBigInteger:function}
 * - {intValue:number}
 * - {toString:function}
 * 
 * Initialization can be performed as follows.
 * - 1200, &quot;1200&quot;, &quot;12e2&quot;, &quot;1.2e3&quot;, [&quot;1200&quot;, 10]
 * - &quot;0xff&quot;, [&quot;ff&quot;, 16]
 * - &quot;0o01234567&quot;, [&quot;01234567&quot;, 8]
 * - &quot;0b0110101&quot;, [&quot;0110101&quot;, 2]
 * @typedef {BigInteger|number|boolean|string|Array&lt;string|number&gt;|{toBigInteger:function}|{intValue:number}|{toString:function}} KBigIntegerInputData
 */

/**
 * Random number class to be used when the random number class is not set.
 * @type {Random}
 * @ignore
 */
let DEFAULT_RANDOM = new Random();

/**
 * Collection of functions used in BigInteger.
 * @ignore
 */
class BigIntegerTool {

	/**
	 * Return a hex array from a string containing numbers.
	 * @param {string} text - String containing a number (remove the negative sign).
	 * @param {number} radix - Base number.
	 * @returns {Array&lt;number&gt;} Hex array.
	 */
	static toHexadecimalArrayFromPlainString(text, radix) {
		// &#x4E0B;&#x306E;&#x5909;&#x63DB;&#x3092;&#x3059;&#x308B;&#x3053;&#x3068;&#x3067;&#x3001;2&#x9032;&#x6570;&#x3067;&#x306E;&#x5909;&#x63DB;&#x6642;&#x306B;&#x5185;&#x90E8;&#x306E;for&#x306E;&#x7E70;&#x308A;&#x8FD4;&#x3059;&#x56DE;&#x6570;&#x304C;&#x6E1B;&#x308B;
		// v0.03 &#x51FA;&#x6765;&#x308B;&#x9650;&#x308A;&#x307E;&#x3068;&#x3081;&#x3066;n&#x9032;&#x6570;&#x5909;&#x63DB;&#x3059;&#x308B;
		const max_num = 0x3FFFFFFF;
		const keta = Math.floor( Math.log(max_num) / Math.log(radix) );

		/**
		 * @type {Array&lt;number&gt;}
		 */
		let x = [];
		
		/**
		 * @type {Array&lt;number&gt;}
		 */
		const y = [];
		const len = Math.ceil(text.length / keta);
		let offset = text.length;
		for(let i = 0; i &lt; len; i++ ) {
			offset -= keta;
			if(offset &gt;= 0) {
				x[i] = parseInt(text.substring(offset, offset + keta), radix);
			}
			else {
				x[i] = parseInt(text.substring(0, offset + keta), radix);
			}
		}
		const calcradix = Math.round(Math.pow(radix, keta));
		// v0.03&#x3053;&#x3053;&#x307E;&#x3067;
		// 2&#x3067;&#x5272;&#x3063;&#x3066;&#x3044;&#x304F;&#x30A2;&#x30EB;&#x30B4;&#x30EA;&#x30BA;&#x30E0;&#x3067;2&#x9032;&#x6570;&#x306B;&#x5909;&#x63DB;&#x3059;&#x308B;
		while(x.length !==  0) {
			// 2&#x3067;&#x5272;&#x3063;&#x3066;&#x3044;&#x304F;
			// &#x96A3;&#x306E;&#x6841;&#x3067;&#x305F;carry&#x306F;radix&#x9032;&#x6570;&#x3092;&#x304B;&#x3051;&#x3066;&#x6841;&#x4E0A;&#x3052;&#x3057;&#x3066;&#x308B;
			let carry = 0;
			for(let i = x.length - 1; i &gt;= 0; i--) {
				const a = x[i] + carry * calcradix;
				x[i]  = a &gt;&gt;&gt; 1;
				carry = a &amp; 1;
			}
			// 1&#x4F59;&#x308B;&#x304B;&#x3069;&#x3046;&#x304B;&#x3092;&#x30C6;&#x30B9;&#x30C8;&#x3059;&#x308B;
			y[y.length] = carry;
			// x&#x304C;0&#x306B;&#x306A;&#x3063;&#x3066;&#x3044;&#x308B;&#x90E8;&#x5206;&#x306F;&#x524A;&#x9664;&#x3057;&#x3066;&#x3044;&#x304F;
			if(x[x.length - 1] === 0) {
				x.pop();
			}
		}
		// &#x30E1;&#x30E2;&#x30EA;&#x7BC0;&#x7D04;&#x306E;&#x305F;&#x3081;1&#x3064;&#x306E;&#x5909;&#x6570;&#xFF08;16&#x30D3;&#x30C3;&#x30C8;&#xFF09;&#x306B;&#x53CE;&#x3081;&#x308B;&#x3060;&#x3051;&#x53CE;&#x3081;&#x3066;&#x3044;&#x304F;
		x = [];
		for(let i = 0; i &lt; y.length; i++) {
			x[i &gt;&gt;&gt; 4] |= y[i] &lt;&lt; (i &amp; 0xF);
		}
		return x;
	}

	/**
	 * Remove exponent notation in strings representing unsigned numbers.
	 * @param {string} ntext 
	 * @returns {string}
	 */
	static toPlainStringFromString(ntext) {
		let scale = 0;
		let buff;
		// &#x6B63;&#x898F;&#x5316;
		let text = ntext.replace(/\s/g, &quot;&quot;).toLowerCase();

		/**
		 * @type {Array&lt;string&gt;}
		 */
		const number_text = [];
		// &#x6574;&#x6570;&#x90E8;&#x3092;&#x62BD;&#x51FA;
		buff = text.match(/^[0-9]+/);
		if(buff !== null) {
			buff = buff[0];
			text = text.substr(buff.length);
			number_text.push(buff);
		}
		// &#x5C0F;&#x6570;&#x90E8;&#x304C;&#x3042;&#x308B;&#x304B;
		buff = text.match(/^\.[0-9]+/);
		if(buff !== null) {
			buff = buff[0];
			text = text.substr(buff.length);
			buff = buff.substr(1);
			scale = scale + buff.length;
			number_text.push(buff);
		}
		// &#x6307;&#x6570;&#x8868;&#x8A18;&#x304C;&#x3042;&#x308B;&#x304B;
		buff = text.match(/^e[+-]?[0-9]+/);
		if(buff !== null) {
			buff = buff[0].substr(1);
			scale -= parseInt(buff, 10);
		}
		// &#x51FA;&#x529B;&#x7528;&#x306E;&#x6587;&#x5B57;&#x3092;&#x4F5C;&#x6210;
		let output_string;
		if(scale === 0) {
			output_string = number_text.join(&quot;&quot;);
		}
		if(scale &lt; 0) {
			for(let i = 0; i &lt; -scale; i++) {
				number_text.push(&quot;0&quot;);
			}
			output_string = number_text.join(&quot;&quot;);
		}
		else if(scale &gt; 0) {
			output_string = number_text.join(&quot;&quot;);
			output_string = output_string.substring(0, output_string.length - scale);
			output_string = output_string.length !== 0 ? output_string : &quot;0&quot;;
		}
		return output_string;
	}

	/**
	 * Return a hexadecimal array from the number.
	 * @param {number} num - Target number.
	 * @returns {{element : Array&lt;number&gt;, state : number}} Data for BigInteger.
	 */
	static toBigIntegerFromNumber(num) {
		if(!isFinite(num)) {
			if(num === Number.POSITIVE_INFINITY) {
				return {
					state : BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY,
					element : []
				};
			}
			if(num === Number.NEGATIVE_INFINITY) {
				return {
					state : BIGINTEGER_NUMBER_STATE.NEGATIVE_INFINITY,
					element : []
				};
			}
			else {
				return {
					state : BIGINTEGER_NUMBER_STATE.NOT_A_NUMBER,
					element : []
				};
			}
		}
		let x;
		let state;
		if((num | 0) === 0) {
			state = BIGINTEGER_NUMBER_STATE.ZERO;
			x = 0;
		}
		else if(num &gt; 0) {
			state = BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER;
			x = num;
		}
		else {
			state = BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER;
			x = -num;
		}
		if(x &gt; 0xFFFFFFFF) {
			return {
				element : BigIntegerTool.toHexadecimalArrayFromPlainString(BigIntegerTool.toPlainStringFromString(x.toFixed()), 10),
				state : state
			};
		}
		/**
		 * @type {Array&lt;number&gt;}
		 */
		const y = [];
		while(x !==  0) {
			y[y.length] = x &amp; 1;
			x &gt;&gt;&gt;= 1;
		}
		/**
		 * @type {Array&lt;number&gt;}
		 */
		const z = [];
		for(let i = 0; i &lt; y.length; i++) {
			z[i &gt;&gt;&gt; 4] |= y[i] &lt;&lt; (i &amp; 0xF);
		}
		
		return {
			element : z,
			state : state
		};
	}

	/**
	 * Return string of number from a hexadecimal array.
	 * @param {Array&lt;number&gt;} binary - Hex array.
	 * @param {number} radix - Base number.
	 * @returns {Array&lt;number&gt;} Numeric array for each digit in the specified base number.
	 */
	static toPlainStringFromHexadecimalArray(binary, radix) {

		/**
		 * @param {Array&lt;number&gt;} x1 
		 * @param {Array&lt;number&gt;} x2 
		 * @param {Array&lt;number&gt;} y 
		 */
		const add = function(x1, x2, y) {
			const size = x1.length;
			let carry = 0;
			for(let i = 0; i &lt; size; i++) {
				y[i] = x1[i] + ((x2.length &gt;= (i + 1)) ? x2[i] : 0) + carry;
				if(y[i] &gt;= radix) {
					carry = 1;
					y[i] -= radix;
				}
				else {
					carry = 0;
				}
			}
			if(carry === 1) {
				y[size] = 1;
			}
		};
		const y = [0];
		const t = [1];
		for(let i = 0;i &lt; binary.length;i++) {
			for(let j = 0; j &lt; 16; j++) {
				if((binary[i] &gt;&gt;&gt; j) &amp; 1) {
					add(t, y, y);
				}
				add(t, t, t);
			}
		}
		return y;
	}

	/**
	 * @param {number[]} element
	 * @returns {boolean}
	 * @ignore
	 */
	static isZeroElement(element) {
		if(element.length === 0) {
			return true;
		}
		if((element.length === 1 &amp;&amp; element[0] === 0)) {
			return true;
		}
		return false;
	}

	/**
	 * Return data to represent multi-precision numbers from strings.
	 * @param {string} text - String containing a number.
	 * @param {number} [radix=10] - Base number.
	 * @returns {{element : Array&lt;number&gt;, state : number}} Data for BigInteger.
	 */
	static toBigIntegerFromString(text, radix) {
		let x = text.replace(/\s/g, &quot;&quot;).toLowerCase();
		// &#x7279;&#x6B8A;&#x306A;&#x72B6;&#x614B;
		{
			if(/nan/.test(text)) {
				return {
					state : BIGINTEGER_NUMBER_STATE.NOT_A_NUMBER,
					element : []
				};
			}
			else if(/inf/.test(text)) {
				if(!/-/.test(text)) {
					return {
						state : BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY,
						element : []
					};
				}
				else {
					return {
						state : BIGINTEGER_NUMBER_STATE.NEGATIVE_INFINITY,
						element : []
					};
				}
			}
		}
		const sign_text = x.match(/^[-+]+/);

		/**
		 * @type {Array&lt;number&gt;}
		 */
		let element     = [];
		let state       = BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER;

		if(sign_text !== null) {
			const hit_text = sign_text[0];
			x = x.substring(hit_text.length, x.length);
			if(hit_text.indexOf(&quot;-&quot;) !== -1) {
				state = BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER;
			}
		}

		if(radix) {
			element = BigIntegerTool.toHexadecimalArrayFromPlainString(x, radix);
		}
		else if(/^0x/.test(x)) {
			element = BigIntegerTool.toHexadecimalArrayFromPlainString(x.substring(2, x.length), 16);
		}
		else if(/^0b/.test(x)) {
			element = BigIntegerTool.toHexadecimalArrayFromPlainString(x.substring(2, x.length), 2);
		}
		else if(/^0o/.test(x)) {
			element = BigIntegerTool.toHexadecimalArrayFromPlainString(x.substring(2, x.length), 8);
		}
		else {
			x = BigIntegerTool.toPlainStringFromString(x);
			element = BigIntegerTool.toHexadecimalArrayFromPlainString(x, 10);
		}
		// &quot;0&quot;&#x306E;&#x5834;&#x5408;&#x304C;&#x3042;&#x308B;&#x70BA;
		if(BigIntegerTool.isZeroElement(element)) {
			element = [];
			state = BIGINTEGER_NUMBER_STATE.ZERO;
		}

		return {
			element : element,
			state : state
		};
	}
}

/**
 * Numeric state.
 * @type {{ZERO:number, POSITIVE_NUMBER:number, NEGATIVE_NUMBER:number, NOT_A_NUMBER:number, POSITIVE_INFINITY:number, NEGATIVE_INFINITY:number}}
 * @ignore
 */
const BIGINTEGER_NUMBER_STATE = {
	ZERO : 0,
	POSITIVE_NUMBER : 1,
	NEGATIVE_NUMBER : 2,
	NOT_A_NUMBER : 3,
	POSITIVE_INFINITY : 4,
	NEGATIVE_INFINITY : 5
};

// &#x5185;&#x90E8;&#x3067;&#x306F;1&#x5909;&#x6570;&#x5185;&#x306E;&#x4E2D;&#x306E;16&#x30D3;&#x30C3;&#x30C8;&#x3054;&#x3068;&#x306B;&#x7BA1;&#x7406;
// 2&#x5909;&#x6570;&#x3067;16&#x30D3;&#x30C3;&#x30C8;*16&#x30D3;&#x30C3;&#x30C8;&#x3067;32&#x30D3;&#x30C3;&#x30C8;&#x3092;&#x8868;&#x3059;
// this.element	...	16&#x30D3;&#x30C3;&#x30C8;&#x3054;&#x3068;&#x306B;&#x7BA1;&#x7406;
//
// &#x672C;&#x30AF;&#x30E9;&#x30B9;&#x306F;&#x30A4;&#x30DF;&#x30E5;&#x30FC;&#x30BF;&#x30D6;&#x30EB;&#x3067;&#x3059;&#x3002;
// &#x5185;&#x90E8;&#x306E;&#x300C;_&#x300D;&#x304B;&#x3089;&#x59CB;&#x307E;&#x308B;&#x30E1;&#x30BD;&#x30C3;&#x30C9;&#x306F;&#x5185;&#x90E8;&#x8A08;&#x7B97;&#x7528;&#x3067;&#x975E;&#x516C;&#x958B;&#x3067;&#x3059;&#x3002;&#x307E;&#x305F;&#x30DF;&#x30E5;&#x30FC;&#x30BF;&#x30D6;&#x30EB;&#x3067;&#x3059;&#x3002;

/**
 * Arbitrary-precision integer class (immutable).
 */
export default class BigInteger extends KonpeitoInteger {

	/**
	 * Create an arbitrary-precision integer.
	 * 
	 * Initialization can be performed as follows.
	 * - 1200, &quot;1200&quot;, &quot;12e2&quot;, &quot;1.2e3&quot;, [&quot;1200&quot;, 10]
	 * - &quot;0xff&quot;, [&quot;ff&quot;, 16]
	 * - &quot;0o01234567&quot;, [&quot;01234567&quot;, 8]
	 * - &quot;0b0110101&quot;, [&quot;0110101&quot;, 2]
	 * @param {KBigIntegerInputData} [number] - Numeric data. See how to use the function.
	 */
	constructor(number) {
		super();
		
		/**
		 * Numeric state.
		 * @private
		 * @type {number}
		 */
		this.state = BIGINTEGER_NUMBER_STATE.ZERO;

		if(arguments.length === 0) {

			/**
			 * An integer consisting of 16 bits per element of the array.
			 * @private
			 * @type {Array&lt;number&gt;}
			 */
			this.element     = [];

		}
		else if(arguments.length === 1) {
			if(number instanceof BigInteger) {
				this.element = number.element.slice(0);
				this.state = number.state;
			}
			else if(typeof number === &quot;number&quot;) {
				const x = BigIntegerTool.toBigIntegerFromNumber(number);
				this.element = x.element;
				this.state = x.state;
			}
			else if(typeof number === &quot;string&quot;) {
				const x = BigIntegerTool.toBigIntegerFromString(number);
				this.element = x.element;
				this.state = x.state;
			}
			else if(number instanceof Array) {
				if((number.length === 2) &amp;&amp; (typeof number[0] === &quot;string&quot; &amp;&amp; (typeof number[1] === &quot;number&quot;))) {
					const x = BigIntegerTool.toBigIntegerFromString(number[0], number[1]);
					this.element = x.element;
					this.state = x.state;
				}
				else {
					throw &quot;BigInteger Unsupported argument &quot; + arguments;
				}
			}
			else if(typeof number === &quot;object&quot;) {
				if(&quot;toBigInteger&quot; in number) {
					const x = number.toBigInteger();
					this.element = x.element;
					this.state = x.state;
				}
				else if(&quot;intValue&quot; in number) {
					const x = BigIntegerTool.toBigIntegerFromNumber(number.intValue);
					this.element = x.element;
					this.state = x.state;
				}
				else {
					const x = BigIntegerTool.toBigIntegerFromString(number.toString());
					this.element = x.element;
					this.state = x.state;
				}
			}
			else if(typeof number === &quot;boolean&quot;) {
				const x = BigIntegerTool.toBigIntegerFromNumber(number ? 1 : 0);
				this.element = x.element;
				this.state = x.state;
			}
			else {
				throw &quot;BigInteger Unsupported argument &quot; + number;
			}
		}
		else {
			throw &quot;BigInteger Unsupported argument &quot; + number;
		}
	}

	/**
	 * Create an entity object of this class.
	 * @param {KBigIntegerInputData} number 
	 * @returns {BigInteger}
	 */
	static create(number) {
		if(number instanceof BigInteger) {
			return number;
		}
		else {
			return new BigInteger(number);
		}
	}

	/**
	 * Create an arbitrary-precision integer.
	 * - Does not support strings using exponential notation.
	 * - If you want to initialize with the specified base number, please set up with an array [&quot;ff&quot;, 16].
	 * @param {KBigIntegerInputData} number 
	 * @returns {BigInteger}
	 */
	static valueOf(number) {
		return BigInteger.create(number);
	}

	/**
	 * Convert to BigInteger.
	 * If type conversion is unnecessary, return the value as it is.
	 * @param {KBigIntegerInputData} number 
	 * @returns {BigInteger}
	 * @private
	 */
	static _toBigInteger(number) {
		if(number instanceof BigInteger) {
			return number;
		}
		else {
			return new BigInteger(number);
		}
	}

	/**
	 * Convert to real number.
	 * @param {KBigIntegerInputData} number 
	 * @returns {number}
	 * @private
	 */
	static _toFloat(number) {
		if(typeof number === &quot;number&quot;) {
			return number;
		}
		else if(number instanceof BigInteger) {
			return number.doubleValue;
		}
		else {
			return (new BigInteger(number)).doubleValue;
		}
	}

	/**
	 * Convert to integer.
	 * @param {KBigIntegerInputData} number 
	 * @returns {number}
	 * @private
	 */
	static _toInteger(number) {
		if(typeof number === &quot;number&quot;) {
			return Math.trunc(number);
		}
		else if(number instanceof BigInteger) {
			return number.intValue;
		}
		else {
			return (new BigInteger(number)).intValue;
		}
	}

	/**
	 * Random number of specified bit length.
	 * @param {KBigIntegerInputData} bitsize - Bit length.
	 * @param {Random} [random] - Class for creating random numbers.
	 * @returns {BigInteger}
	 */
	static createRandomBigInteger(bitsize, random) {
		const rand = (random !== undefined &amp;&amp; random instanceof Random) ? random : DEFAULT_RANDOM;
		const x = new BigInteger();
		const bits = BigInteger._toInteger(bitsize);
		const size = ((bits - 1) &gt;&gt; 4) + 1;
		if(bits === 0) {
			return BigInteger.ZERO;
		}
		let r;
		for(let i = 0, j = 0; i &lt; size; i++) {
			if(j === 0) {
				r = rand.nextInt(); // 32&#x30D3;&#x30C3;&#x30C8;&#x305A;&#x3064;&#x4F5C;&#x6210;&#x3059;&#x308B;
				x.element[i] = r &amp; 0xFFFF;
				j = 1;
			}
			else {
				x.element[i] = (r &gt;&gt;&gt; 16) &amp; 0xFFFF;
				j = 0;
			}
		}
		// 1&#xFF5E;15&#x30D3;&#x30C3;&#x30C8;&#x4F59;&#x308B;&#x5834;&#x5408;&#x306F;&#x3001;16&#x30D3;&#x30C3;&#x30C8;&#x305A;&#x3064;&#x4F5C;&#x6210;&#x3057;&#x3066;&#x3044;&#x308B;&#x306E;&#x3067;&#x524A;&#x308B;
		if((bits % 16) !== 0) {
			x.element[x.element.length - 1] &amp;= (1 &lt;&lt; (bits % 16)) - 1;
		}
		// &#x6700;&#x5F8C;&#x306E;&#x30D3;&#x30C3;&#x30C8;&#x306B; 0 &#x3092;&#x305F;&#x304F;&#x3055;&#x3093;&#x4F5C;&#x6210;&#x3057;&#x3066;&#x3044;&#x308B;&#x3068;&#x3001;
		// 0&#x306E;&#x307F;&#x306E;&#x30C7;&#x30FC;&#x30BF;&#x306B;&#x306A;&#x308B;&#x53EF;&#x80FD;&#x6027;&#x304C;&#x3042;&#x308B;&#x305F;&#x3081;&#x30E1;&#x30E2;&#x30EA;&#x3092;&#x4FEE;&#x6B63;
		x.state = BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER;
		x._memory_reduction();
		return x;
	}

	/**
	 * Convert to string.
	 * @param {KBigIntegerInputData} [radix=10] - Base number.
	 * @returns {string}
	 */
	toString(radix) {
		if(!this.isFinite()) {
			return this.isNaN() ? &quot;NaN&quot; : (this.isPositiveInfinity() ? &quot;Infinity&quot; : &quot;-Infinity&quot;);
		}
		const radix_ = radix ? BigInteger._toInteger(radix) : 10;

		// int&#x578B;&#x3067;&#x6271;&#x3048;&#x308B;&#x6570;&#x5024;&#x3067; toString &#x304C;&#x53EF;&#x80FD;&#x306A;&#x306E;&#x3067;&#x3001;
		// &#x305B;&#x3063;&#x304B;&#x304F;&#x3060;&#x304B;&#x3089;&#x3088;&#x308A;&#x5927;&#x304D;&#x306A;&#x9032;&#x6570;&#x3067;&#x8A08;&#x7B97;&#x3057;&#x3066;&#x3044;&#x3051;&#x3070;&#x3001;&#x3042;&#x3068;&#x3067;toString&#x3059;&#x308B;&#x56DE;&#x6570;&#x304C;&#x6E1B;&#x308B;&#x30C6;&#x30AF;&#x30CB;&#x30C3;&#x30AF;
		// 2&#x9032;&#x6570;&#x3067;&#x3042;&#x308C;&#x3070;&#x3001;2^n&#x4E57;&#x3067;&#x8A08;&#x7B97;&#x3057;&#x3066;&#x3082;&#x554F;&#x984C;&#x304C;&#x306A;&#x3044; 4&#x9032;&#x6570;&#x3084;8&#x9032;&#x6570;&#x3067;&#x8A08;&#x7B97;&#x3057;&#x3066;&#x3001;2&#x9032;&#x6570;&#x306B;&#x623B;&#x305B;&#x3070;&#x5DE1;&#x56DE;&#x5C11;&#x6570;&#x306A;&#x3057;
		// v0.03 &#x51FA;&#x6765;&#x308B;&#x9650;&#x308A;&#x307E;&#x3068;&#x3081;&#x3066;n&#x9032;&#x6570;&#x5909;&#x63DB;&#x3059;&#x308B;
		const max_num = 0x3FFFFFFF;
		//                        max_num &gt; radix^x
		// floor(log max_num / log radix) = x
		const keta = Math.floor( Math.log(max_num) / Math.log(radix_) );
		const calcradix = Math.round(Math.pow(radix_, keta));
		// zeros = &quot;00000000....&quot;
		const zeros_array = [];
		for(let i = 0; i &lt; keta; i++) {
			zeros_array[i] = &quot;0&quot;;
		}
		const zeros_string = zeros_array.join(&quot;&quot;);
		// v0.03&#x3053;&#x3053;&#x307E;&#x3067;
		const x = BigIntegerTool.toPlainStringFromHexadecimalArray(this.element, calcradix);
		const y = [];
		let z = &quot;&quot;;
		if(this.sign() &lt; 0) {
			y[y.length] = &quot;-&quot;;
		}
		for(let i = x.length - 1; i &gt;= 0; i--) {
			z = x[i].toString(radix_);
			if(i &lt; (x.length - 1)) {
				y[y.length] = zeros_string.substring(0, keta - z.length);
			}
			y[y.length] = z;
		}
		return y.join(&quot;&quot;);
	}

	/**
	 * Deep copy.
	 * @returns {BigInteger}
	 */
	clone() {
		return new BigInteger(this);
	}

	/**
	 * Create a numerical value for addition. If negative, two&apos;s complement.
	 * @param {number} [bit_length] - Bit length. If not set, it will be calculated automatically.
	 * @returns {BigInteger}
	 * @private
	 */
	getTwosComplement(bit_length) {
		const y = this.clone();
		if(!this.isFinite()) {
			return y;
		}
		if(y.isNotNegative()) {
			return y;
		}
		else {
			// &#x6B63;&#x306B;&#x3059;&#x308B;
			y.state = BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER;
			// &#x30D3;&#x30C3;&#x30C8;&#x306E;&#x6570;&#x304C;&#x5B58;&#x5728;&#x3057;&#x306A;&#x3044;&#x5834;&#x5408;&#x306F;&#x6570;&#x3048;&#x308B;
			const len = (bit_length !== undefined) ? bit_length : y.bitLength();
			const e = y.element;
			// &#x30D3;&#x30C3;&#x30C8;&#x53CD;&#x8EE2;&#x5F8C;
			for(let i = 0; i &lt; e.length; i++) {
				e[i] ^= 0xFFFF;
			}
			// 1&#xFF5E;15&#x30D3;&#x30C3;&#x30C8;&#x4F59;&#x308B;&#x5834;&#x5408;&#x306F;&#x3001;16&#x30D3;&#x30C3;&#x30C8;&#x305A;&#x3064;&#x4F5C;&#x6210;&#x3057;&#x3066;&#x3044;&#x308B;&#x306E;&#x3067;&#x524A;&#x308B;
			// n&#x30D3;&#x30C3;&#x30C8;&#x306E;&#x30DE;&#x30B9;&#x30AF;&#xFF08;&#x306A;&#x304A;&#x8CA0;&#x306E;&#x5024;&#x3092;&#x8868;&#x3059;&#x6700;&#x4E0A;&#x4F4D;&#x30D3;&#x30C3;&#x30C8;&#x306F;&#x524A;&#x9664;&#x3059;&#x308B;&#xFF09;
			if((len % 16) !== 0) {
				e[e.length - 1] &amp;= (1 &lt;&lt; (len % 16)) - 1;
			}
			// 1&#x3092;&#x52A0;&#x7B97;
			y._add(new BigInteger(1));
			return y;
		}
	}

	/**
	 * Expand memory to specified bit length. (mutable)
	 * @param {number} bit_length - Bit length.
	 * @private
	 */
	_memory_allocation(bit_length) {
		if(!this.isFinite()) {
			return;
		}
		const n = BigInteger._toInteger(bit_length);
		const elementsize = this.element.length &lt;&lt; 4;
		if(elementsize &lt; n) {
			const addsize = (((n - elementsize - 1) &amp; 0xFFFFFFF0) &gt;&gt;&gt; 4) + 1;
			for(let i = 0;i &lt; addsize;i++) {
				this.element[this.element.length] = 0;
			}
		}
	}

	/**
	 * Normalization of the internal data. (mutable)
	 * @private
	 */
	_memory_reduction() {
		if(!this.isFinite()) {
			return;
		}
		for(let i = this.element.length - 1;i &gt;= 0;i--) {
			if(this.element[i] !==  0) {
				// &#x6700;&#x7D42;&#x884C;&#x4EE5;&#x5916;&#x3067;&#x898B;&#x3064;&#x304B;&#x3063;&#x305F;&#x3089;&#x3001;&#x4E0A;&#x306E;&#x9818;&#x57DF;&#x3092;&#x524A;&#x9664;&#x3059;&#x308B;
				if(i &lt; this.element.length - 1) {
					this.element.splice(i + 1, this.element.length - i - 1);
				}
				return;
			}
		}
		// &#x5168;&#x3066;0&#x3060;&#x3063;&#x305F;&#x5834;&#x5408;
		this.state = BIGINTEGER_NUMBER_STATE.ZERO;
		this.element = [];
	}

	/**
	 * Absolute value. (mutable)
	 * @returns {BigInteger} A = abs(A)
	 * @private
	 */
	_abs() {
		// -1 -&gt; 1, 0 -&gt; 0, 1 -&gt; 1
		if(this.state === BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER) {
			this.state = BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER;
		}
		else if(this.state === BIGINTEGER_NUMBER_STATE.NEGATIVE_INFINITY) {
			this.state = BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY;
		}
		return this;
	}

	/**
	 * Absolute value.
	 * @returns {BigInteger} abs(A)
	 */
	abs() {
		return this.clone()._abs();
	}

	/**
	 * this *= -1
	 * @returns {BigInteger} A = -A
	 * @private
	 */
	_negate() {
		if(this.state === BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER) {
			this.state = BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER;
		}
		else if(this.state === BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER) {
			this.state = BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER;
		}
		else if(this.state === BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY) {
			this.state = BIGINTEGER_NUMBER_STATE.NEGATIVE_INFINITY;
		}
		else if(this.state === BIGINTEGER_NUMBER_STATE.NEGATIVE_INFINITY) {
			this.state = BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY;
		}
		return this;
	}

	/**
	 * this * -1
	 * @returns {BigInteger} -A
	 */
	negate() {
		return this.clone()._negate();
	}

	/**
	 * The positive or negative sign of this number.
	 * - +1 if positive, -1 if negative, 0 if 0.
	 * @returns {number}
	 */
	sign() {
		if(this.isNaN()) {
			return NaN;
		}
		else if(this.isZero()) {
			return 0;
		}
		else if(this.isPositive()) {
			return 1;
		}
		else {
			return -1;
		}
	}

	// ----------------------
	// &#x56DB;&#x5247;&#x6F14;&#x7B97;
	// ----------------------
	
	/**
	 * Add. (mutable)
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} A += B
	 * @private
	 */
	_add(number) {
		const val = BigInteger._toBigInteger(number);
		const o1 = this;
		const o2 = val;
		if(!o1.isFinite() || !o2.isFinite()) {
			let ret;
			if(o1.isNaN() || o2.isNaN() || (o1.isInfinite() &amp;&amp; o2.isInfinite() &amp;&amp; !o1.equalsState(o2))) {
				ret = BigInteger.NaN.clone();
			}
			else if(o1.isPositiveInfinity() || o2.isPositiveInfinity()) {
				ret = BigInteger.POSITIVE_INFINITY.clone();
			}
			else {
				ret = BigInteger.NEGATIVE_INFINITY.clone();
			}
			this.element = ret.element;
			this.state = ret.state;
			return this;
		}
		let x1 = o1.element;
		let x2 = o2.element;
		if(o1.sign() === o2.sign()) {
			//&#x8DB3;&#x3057;&#x7B97;
			this._memory_allocation(x2.length &lt;&lt; 4);
			let carry = 0;
			for(let i = 0; i &lt; x1.length; i++) {
				x1[i] += ((x2.length &gt;= (i + 1)) ? x2[i] : 0) + carry;
				if(x1[i] &gt; 0xFFFF) {
					carry = 1;
					x1[i] &amp;= 0xFFFF;
				}
				else {
					carry = 0;
				}
			}
			if(carry !== 0) {
				x1[x1.length] = carry;
			}
		}
		else {
			// &#x5F15;&#x304D;&#x7B97;
			const compare = o1.compareToAbs(o2);
			if(compare === 0) {
				this.element = [];
				this.state = BIGINTEGER_NUMBER_STATE.ZERO;
				return this;
			}
			else if(compare === -1) {
				this.state = o2.state;
				const swap = x1;
				x1 = x2.slice(0);
				x2 = swap;
			}
			let carry = 0;
			for(let i = 0; i &lt; x1.length; i++) {
				x1[i] -= ((x2.length &gt;= (i + 1)) ? x2[i] : 0) + carry;
				if(x1[i] &lt; 0) {
					x1[i] += 0x10000;
					carry  = 1;
				}
				else {
					carry  = 0;
				}
			}
			this.element = x1;
			this._memory_reduction();
		}
		return this;
	}

	/**
	 * Add.
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} A + B
	 */
	add(number) {
		return this.clone()._add(number);
	}

	/**
	 * Subtract. (mutable)
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} A -= B
	 * @private
	 */
	_sub(number) {
		// &#x4E00;&#x6642;&#x7684;&#x306B;&#x8A18;&#x9332;&#x3057;&#x3066;&#x304A;&#x3044;&#x3066;&#x5F15;&#x6570;&#x306E;&#x60C5;&#x5831;&#x306F;&#x66F8;&#x304D;&#x63DB;&#x3048;&#x306A;&#x3044;&#x3088;&#x3046;&#x306B;&#x3059;&#x308B;
		const val = BigInteger._toBigInteger(number);
		const state = val.state;
		const out  = this._add(val._negate());
		val.state = state;
		return out;
	}

	/**
	 * Subtract.
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} A - B
	 */
	sub(number) {
		return this.clone()._sub(number);
	}

	/**
	 * Multiply. (mutable)
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} A *= B
	 * @private
	 */
	_mul(number) {
		const x = this.mul(number);
		this.element = x.element;
		this.state   = x.state;
		return this;
	}

	/**
	 * Multiply.
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} A * B
	 */
	mul(number) {
		const val = BigInteger._toBigInteger(number);
		const o1 = this;
		const o2 = val;
		if(!o1.isFinite() || !o2.isFinite()) {
			if(o1.isNaN() || o2.isNaN() || (o1.isZero() || o2.isZero())) {
				return BigInteger.NaN.clone();
			}
			else if(o1.sign() * o2.sign() &gt; 0) {
				return BigInteger.POSITIVE_INFINITY.clone();
			}
			else {
				return BigInteger.NEGATIVE_INFINITY.clone();
			}
		}
		const x1 = o1.element;
		const x2 = o2.element;
		const out  = new BigInteger();
		const buff = new BigInteger();
		const y  = out.element;
		for(let i = 0; i &lt; x1.length; i++) {
			buff.element = [];
			// x3 = x1[i] * x2
			const x3 = buff.element;
			let carry = 0;
			for(let j = 0; j &lt; x2.length; j++) {
				x3[j] = x1[i] * x2[j] + carry;
				if(x3[j] &gt; 0xFFFF) {
					carry = x3[j] &gt;&gt;&gt; 16;
					x3[j] &amp;= 0xFFFF;
				}
				else {
					carry = 0;
				}
			}
			if(carry !== 0) {
				x3[x3.length] = carry;
			}
			// x3 = x3 &lt;&lt; (i * 16)
			//buff._shift(i &lt;&lt; 4);
			for(let j = x3.length - 1; j &gt;= 0; j--) {
				x3[j + i] = x3[j];
			}
			for(let j = i - 1; j &gt;= 0; j--) {
				x3[j] = 0;
			}
			// y = y + x3 (out._add(buff))
			//out._add(buff);
			carry = 0;
			out._memory_allocation(x3.length &lt;&lt; 4);
			for(let j = i; j &lt; y.length; j++) {
				y[j] += ((x3.length &gt;= (j + 1)) ? x3[j] : 0) + carry;
				if(y[j] &gt; 0xFFFF) {
					carry = 1;
					y[j] &amp;= 0xFFFF;
				}
				else {
					carry = 0;
				}
			}
			if(carry !== 0) {
				y[y.length] = carry;
			}
		}
		const sign = this.sign() * val.sign();
		out.state = sign === 0 ? BIGINTEGER_NUMBER_STATE.ZERO :	(sign === 1 ? BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER : BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER);
		return out;
	}

	/**
	 * Divide and rem. (mutable)
	 * @param {KBigIntegerInputData} number
	 * @returns {Array&lt;BigInteger&gt;} [C = fix(A / B), A - C * B]
	 * @private
	 */
	_divideAndRemainder(number) {
		const o1 = this;
		const o2 = BigInteger._toBigInteger(number);
		if(!o1.isFinite() || !o2.isFinite()) {
			if(o1.isNaN() || o2.isNaN() || (o1.isInfinite() &amp;&amp; o2.isInfinite())) {
				return [BigInteger.NaN, BigInteger.NaN];
			}
			else if(o1.isInfinite()) {
				if(o1.sign() * o2.sign() &gt;= 0) {
					return [BigInteger.POSITIVE_INFINITY, BigInteger.NaN];
				}
				else {
					return [BigInteger.NEGATIVE_INFINITY, BigInteger.NaN];
				}
			}
			else {
				return [BigInteger.ZERO, BigInteger.NaN];
			}
		}
		else if(o2.isZero()) {
			if(o1.isZero()) {
				return [BigInteger.NaN, BigInteger.NaN];
			}
			else {
				return [o1.sign() &gt;= 0 ? BigInteger.POSITIVE_INFINITY : BigInteger.NEGATIVE_INFINITY, BigInteger.NaN];
			}
		}
		const out = [];
		const compare = o1.compareToAbs(o2);
		const sign = o1.sign() * o2.sign();
		if(compare &lt; 0) {
			out[0] = new BigInteger(0);
			out[1] = o1.clone();
			return out;
		}
		else if(compare === 0) {
			out[0] = new BigInteger(1);
			out[0].state = sign === 1 ? BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER : BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER;
			out[1] = new BigInteger(0);
			return out;
		}
		const ONE = new BigInteger(1);
		const size = o1.bitLength() - o2.bitLength();
		const x1 = o1.clone()._abs();
		const x2 = o2.shift(size)._abs();
		const y  = new BigInteger();
		for(let i = 0; i &lt;= size; i++) {
			if(x1.compareToAbs(x2) &gt;= 0) {
				x1._sub(x2);
				y._add(ONE);
			}
			if(i === size) {
				break;
			}
			x2._shift(-1);
			y._shift(1);
		}
		out[0] = y;
		out[0].state = sign === 1 ? BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER : BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER;
		out[1] = x1;
		out[1].state = x1.state !== BIGINTEGER_NUMBER_STATE.ZERO ? o1.state : x1.state;
		return out;
	}

	/**
	 * Divide and rem.
	 * @param {KBigIntegerInputData} number
	 * @returns {Array&lt;BigInteger&gt;} [C = fix(A / B), A - C * B]
	 */
	divideAndRemainder(number) {
		return this.clone()._divideAndRemainder(number);
	}

	/**
	 * Divide. (mutable)
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} fix(A / B)
	 * @private
	 */
	_div(number) {
		return this._divideAndRemainder(number)[0];
	}

	/**
	 * Divide.
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} fix(A / B)
	 */
	div(number) {
		return this.clone()._div(number);
	}

	/**
	 * Inverse number of this value.
	 * @returns {BigInteger} 1 / A
	 */
	inv() {
		{
			if(!this.isFinite()) {
				return this.isNaN() ? BigInteger.NaN : BigInteger.ZERO;
			}
			if(this.isZero()) {
				return BigInteger.NaN;
			}
		}
		return BigInteger.ZERO;
	}

	/**
	 * Remainder of division. (mutable)
	 * - Result has same sign as the Dividend.
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} A %= B
	 * @private
	 */
	_rem(number) {
		const y = this._divideAndRemainder(number)[1];
		this.element = y.element;
		this.state = y.state;
		return this;
	}

	/**
	 * Remainder of division.
	 * - Result has same sign as the Dividend.
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} A % B
	 */
	rem(number) {
		return this.clone()._rem(number);
	}

	/**
	 * Modulo, positive rem of division. (mutable)
	 * - Result has same sign as the Divisor.
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} A = A mod B
	 * @private
	 */
	_mod(number) {
		const o1 = this;
		const o2 = BigInteger._toBigInteger(number);
		if(o2.isZero()) {
			return o1;
		}
		const y = o1._divideAndRemainder(o2)[1];
		if(o1.state !== o2.state) {
			y._add(o2);
		}
		this.element = y.element;
		this.state = y.state;
		return this;
	}

	/**
	 * Modulo, positive rem of division.
	 * - Result has same sign as the Divisor.
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} A mod B
	 */
	mod(number) {
		return this.clone()._mod(number);
	}

	/**
	 * Modular exponentiation.
	 * @param {KBigIntegerInputData} exponent
	 * @param {KBigIntegerInputData} m 
	 * @returns {BigInteger} A^B mod m
	 */
	modPow(exponent, m) {
		const m_ = BigInteger._toBigInteger(m);
		let x = new BigInteger(this);
		let y = new BigInteger(1);
		const e = new BigInteger(exponent);
		if(!x.isFinite() || !e.isFinite()) {
			return BigInteger.NaN;
		}
		while(e.element.length !== 0) {
			if((e.element[0] &amp; 1) !== 0) {
				y = y.multiply(x).mod(m_);
			}
			x = x.multiply(x).mod(m_);
			e._shift(-1);
		}
		return y;
	}

	/**
	 * Modular multiplicative inverse.
	 * @param {KBigIntegerInputData} m
	 * @returns {BigInteger} A^(-1) mod m
	 */
	modInverse(m) {
		const m_ = BigInteger._toBigInteger(m);
		if(!this.isFinite() || !m_.isFinite()) {
			return BigInteger.NaN;
		}
		const y = this.extgcd(m);
		const ONE  = new BigInteger(1);
		if(y[2].compareTo(ONE) !== 0) {
			return BigInteger.NaN;
		}
		// &#x6B63;&#x306B;&#x3059;&#x308B;&#x305F;&#x3081; rem &#x3067;&#x306F;&#x306A;&#x304F; mod &#x3092;&#x4F7F;&#x7528;&#x3059;&#x308B;
		return y[0]._add(m_).rem(m_);
	}

	// ----------------------
	// &#x305D;&#x306E;&#x4ED6;&#x306E;&#x6F14;&#x7B97;
	// ----------------------
	
	/**
	 * Factorial function, x!.
	 * @returns {BigInteger} n!
	 */
	factorial() {
		{
			if(!this.isFinite()) {
				return this;
			}
			else if(this.isNegative()) {
				return BigInteger.NaN;
			}
		}
		const loop_max = BigInteger._toInteger(this);
		let x = BigInteger.ONE;
		for(let i = 2; i &lt;= loop_max; i++) {
			x = x.multiply(i);
		}
		return x;
	}

	/**
	 * Multiply a multiple of ten.
	 * @param {KBigIntegerInputData} n
	 * @returns {BigInteger} x * 10^n
	 */
	scaleByPowerOfTen(n) {
		const x = BigInteger._toInteger(n);
		if(x === 0) {
			return this;
		}
		if(x &gt; 0) {
			return this.mul(BigInteger.TEN.pow(x));
		}
		else {
			return this.div(BigInteger.TEN.pow(x));
		}
	}

	// ----------------------
	// &#x6307;&#x6570;
	// ----------------------
	
	/**
	 * Power function.
	 * @param {KBigIntegerInputData} exponent
	 * @returns {BigInteger} pow(A, B)
	 */
	pow(exponent) {
		const e = new BigInteger(exponent);
		{
			if(this.isNaN() || e.isNaN()) {
				return BigInteger.NaN;
			}
			if(e.isZero()) {
				return BigInteger.ONE;
			}
			else if(this.isZero()) {
				if(e.isNegativeInfinity()) {
					return BigInteger.POSITIVE_INFINITY;
				}
				else {
					return BigInteger.ZERO;
				}
			}
			else if(this.isOne()) {
				return this;
			}
			else if(this.isInfinite()) {
				if(this.isPositiveInfinity()) {
					return BigInteger.POSITIVE_INFINITY;
				}
				else {
					if(e.isPositiveInfinity()) {
						return BigInteger.NaN;
					}
					else {
						return BigInteger.create(Infinity * Math.pow(-1, Math.round(e.doubleValue)));
					}
				}
			}
			else if(e.isInfinite()) {
				if(this.isNegative()) {
					// &#x8907;&#x7D20;&#x6570;
					return BigInteger.NaN;
				}
				if(this.compareTo(BigInteger.ONE) &lt; 0) {
					if(e.isPositiveInfinity()) {
						return BigInteger.ZERO;
					}
					else if(e.isNegativeInfinity()) {
						return BigInteger.POSITIVE_INFINITY;
					}
				}
				else {
					if(e.isPositiveInfinity()) {
						return BigInteger.POSITIVE_INFINITY;
					}
					else if(e.isNegativeInfinity()) {
						return BigInteger.ZERO;
					}
				}
			}
		}
		let x = BigInteger._toBigInteger(this);
		let y = BigInteger._toBigInteger(1);
		while(e.element.length !== 0) {
			if((e.element[0] &amp; 1) !== 0) {
				y = y.multiply(x);
			}
			x = x.multiply(x);
			e._shift(-1);
		}
		return y;
	}

	/**
	 * Square.
	 * @returns {BigInteger} A^2
	 */
	square() {
		return this.mul(this);
	}

	/**
	 * Square root.
	 * @returns {BigInteger} floor(sqrt(A))
	 */
	sqrt() {
		{
			if(this.isZero()) {
				return BigInteger.ZERO;
			}
			else if(this.isNaN()) {
				return BigInteger.NaN;
			}
			else if(this.isNegative()) {
				return BigInteger.NaN; // &#x8907;&#x7D20;&#x6570;
			}
			else if(this.isInfinite()) {
				return BigInteger.POSITIVE_INFINITY;
			}
		}
		// &#x30CB;&#x30E5;&#x30FC;&#x30C8;&#x30F3;&#x6CD5;&#x306B;&#x3088;&#x3063;&#x3066;&#x6C42;&#x3081;&#x308B;
		// &#x53C2;&#x8003;&#xFF1A;&#x5965;&#x6751;&#x6674;&#x5F66; (1991). C&#x8A00;&#x8A9E;&#x306B;&#x3088;&#x308B;&#x6700;&#x65B0;&#x30A2;&#x30EB;&#x30B4;&#x30EA;&#x30BA;&#x30E0;&#x4E8B;&#x5178;.
		// A^0.5  = x
		//     A  = x^2
		//     0  = x^2 - A
		//   f(x) = x^2 - A
		//   f&apos;(x) = 2x
		// x_(n+1) = x_n - f(x_n)/f&apos;(x_n)
		//         = x_n - (x_n^2 - A)/2x_n
		//         = (2*x_n^2 - x_n^2 + A)/2x_n
		//         = (x_n^2 + A)/2x_n
		//         = (x_n + (A/x_n)) / 2
		let s = BigInteger.ONE;
		/**
		 * @type {BigInteger}
		 */
		let t = this;
		while(s.compareToAbs(t) === -1) {
			s = s.shiftLeft(1);
			t = t.shiftRight(1);
		}
		const x0 = t;
		let xn = x0;
		for(let i = 0; i &lt; 300; i++) {
			const xn1 = xn.add(this.div(xn)).shiftRight(1);
			const delta = xn1.sub(xn);
			if(delta.isZero()) {
				break;
			}
			xn = xn1;
		}
		return xn;
	}
	
	/**
	 * Cube root.
	 * @returns {BigInteger} floor(cbrt(A))
	 */
	cbrt() {
		{
			if(this.isZero()) {
				return BigInteger.ZERO;
			}
			else if(this.isNaN()) {
				return BigInteger.NaN;
			}
			else if(this.isInfinite()) {
				return this;
			}
		}
		// &#x30CB;&#x30E5;&#x30FC;&#x30C8;&#x30F3;&#x6CD5;&#x306B;&#x3088;&#x3063;&#x3066;&#x6C42;&#x3081;&#x308B;
		// &#x53C2;&#x8003;&#xFF1A;&#x5965;&#x6751;&#x6674;&#x5F66; (1991). C&#x8A00;&#x8A9E;&#x306B;&#x3088;&#x308B;&#x6700;&#x65B0;&#x30A2;&#x30EB;&#x30B4;&#x30EA;&#x30BA;&#x30E0;&#x4E8B;&#x5178;.
		let s = BigInteger.ONE;
		/**
		 * @type {BigInteger}
		 */
		let t = this;
		while(s.compareToAbs(t) === -1) {
			s = s.shiftLeft(1);
			t = t.shiftRight(2);
		}
		const x0 = t;
		let xn = x0;
		for(let i = 0; i &lt; 300; i++) {
			const xn_2 = xn.mul(xn);
			const xn1 = xn.shiftLeft(1).add(this.div(xn_2)).div(3);
			const delta = xn1.sub(xn);
			if(delta.isZero()) {
				break;
			}
			xn = xn1;
		}
		return xn;
	}

	/**
	 * log_2(x)
	 * @returns {BigInteger} log2(A)
	 */
	log2() {
		{
			if(this.isZero()) {
				return BigInteger.ZERO;
			}
			else if(this.isNaN()) {
				return BigInteger.NaN;
			}
			else if(this.isNegative()) {
				return BigInteger.NaN;
			}
			else if(this.isInfinite()) {
				return BigInteger.POSITIVE_INFINITY;
			}
		}
		return BigInteger.create(this.bitLength() - 1);
	}

	/**
	 * log_10(x)
	 * @returns {BigInteger} log10(A)
	 */
	log10() {
		{
			if(this.isZero()) {
				return BigInteger.ZERO;
			}
			else if(this.isNaN()) {
				return BigInteger.NaN;
			}
			else if(this.isNegative()) {
				return BigInteger.NaN;
			}
			else if(this.isInfinite()) {
				return BigInteger.POSITIVE_INFINITY;
			}
		}
		return BigInteger.create(this.toString(10).length - 1);
	}

	// ----------------------
	// &#x74B0;&#x5883;&#x8A2D;&#x5B9A;&#x7528;
	// ----------------------
	
	/**
	 * Set default class of random.
	 * This is used if you do not specify a random number.
	 * @param {Random} random
	 */
	static setDefaultRandom(random) {
		DEFAULT_RANDOM = random;
	}

	/**
	 * Return default Random class.
	 * Used when Random not specified explicitly.
	 * @returns {Random}
	 */
	static getDefaultRandom() {
		return DEFAULT_RANDOM;
	}

	// ----------------------
	// &#x4ED6;&#x306E;&#x578B;&#x306B;&#x5909;&#x63DB;&#x7528;
	// ----------------------
	
	/**
	 * Value at the specified position of the internally used array that composed of hexadecimal numbers.
	 * @param {KBigIntegerInputData} point - Array address.
	 * @returns {number}
	 */
	getShort(point) {
		if(this.isZero()) {
			return 0;
		}
		const n = BigInteger._toInteger(point);
		return ((0 &lt;= n) &amp;&amp; (n &lt;= this.element.length)) ? this.element[n] : NaN;
	}

	/**
	 * boolean value.
	 * @returns {boolean}
	 */
	get booleanValue() {
		return !this.isZero() &amp;&amp; !this.isNaN();
	}

	/**
	 * 32-bit integer value.
	 * - If it is outside the range of JavaScript Number, it will not be an accurate number.
	 * @returns {number}
	 */
	get intValue() {
		if(!this.isFinite()) {
			return this.isNaN() ? NaN : (this.isPositiveInfinity() ? Infinity : -Infinity);
		}
		let x = this.getShort(0) + (this.getShort(1) &lt;&lt; 16);
		x &amp;= 0xFFFFFFFF;
		if((x &gt; 0) &amp;&amp; this.isNegative()) {
			x = -x;
		}
		return x;
	}

	/**
	 * 64-bit integer value.
	 * - If it is outside the range of JavaScript Number, it will not be an accurate number.
	 * @returns {number}
	 * @deprecated
	 */
	get longValue() {
		if(!this.isFinite()) {
			return this.isNaN() ? NaN : (this.isPositiveInfinity() ? Infinity : -Infinity);
		}
		let x = 0;
		for(let i = Math.min(3, this.element.length - 1); i &gt;= 0; i--) {
			x *= 65536;
			x += this.getShort(i);
		}
		if(this.isNegative()) {
			x = -x;
		}
		return x;
	}

	/**
	 * 64-bit floating point.
	 * - If it is outside the range of JavaScript Number, it will not be an accurate number.
	 * @returns {number}
	 */
	get doubleValue() {
		if(!this.isFinite()) {
			return this.isNaN() ? NaN : (this.isPositiveInfinity() ? Infinity : -Infinity);
		}
		return parseFloat(this.toString());
	}
	
	// ----------------------
	// konpeito &#x3067;&#x6271;&#x3046;&#x6570;&#x5024;&#x578B;&#x3078;&#x5909;&#x63DB;
	// ----------------------
	
	/**
	 * return BigInteger.
	 * @returns {BigInteger}
	 */
	toBigInteger() {
		return this;
	}

	/**
	 * return BigDecimal.
	 * @param {MathContext} [mc] - MathContext setting after calculation. 
	 * @returns {BigDecimal}
	 */
	toBigDecimal(mc) {
		if(mc) {
			return new BigDecimal([this, mc]);
		}
		else {
			return new BigDecimal(this);
		}
	}
	
	/**
	 * return Fraction.
	 * @returns {Fraction}
	 */
	toFraction() {
		return new Fraction(this);
	}
	
	/**
	 * return Complex.
	 * @returns {Complex}
	 */
	toComplex() {
		return new Complex(this);
	}
	
	/**
	 * return Matrix.
	 * @returns {Matrix}
	 */
	toMatrix() {
		return new Matrix(this);
	}

	// ----------------------
	// &#x6BD4;&#x8F03;
	// ----------------------
	
	/**
	 * Equals.
	 * @param {KBigIntegerInputData} number
	 * @returns {boolean} A === B
	 */
	equals(number) {
		const x = this;
		const y = BigInteger._toBigInteger(number);
		if(!x.isFinite() || !y.isFinite()) {
			if(x.isNaN() || y.isNaN()) {
				return false;
			}
			else if(x.state === y.state) {
				return true;
			}
			else {
				return false;
			}
		}
		if(x.state !== y.state) {
			return false;
		}
		if(x.element.length !== y.element.length) {
			return false;
		}
		for(let i = 0; i &lt; y.element.length; i++) {
			if(x.element[i] !==  y.element[i]) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Compare values without sign.
	 * @param {KBigIntegerInputData} number 
	 * @returns {number} abs(A) &gt; abs(B) ? 1 : (abs(A) === abs(B) ? 0 : -1)
	 */
	compareToAbs(number) {
		const x = this;
		const y = BigInteger._toBigInteger(number);
		if(!x.isFinite() || !y.isFinite()) {
			if(x.isNaN() || y.isNaN()) {
				return NaN;
			}
			else if(x.isInfinite() || y.isInfinite()) {
				return 0;
			}
			else if(y.isInfinite()) {
				return -1;
			}
			else {
				return 1;
			}
		}
		if(x.element.length &lt; y.element.length) {
			return -1;
		}
		else if(x.element.length &gt; y.element.length) {
			return 1;
		}
		for(let i = x.element.length - 1;i &gt;= 0;i--) {
			if(x.element[i] !== y.element[i]) {
				const val = x.element[i] - y.element[i];
				return ( (val === 0) ? 0 : ((val &gt; 0) ? 1 : -1) );
			}
		}
		return 0;
	}

	/**
	 * Compare values.
	 * @param {KBigIntegerInputData} number 
	 * @returns {number} A &gt; B ? 1 : (A === B ? 0 : -1)
	 */
	compareTo(number) {
		const x = this;
		const y = BigInteger._toBigInteger(number);
		if(!x.isFinite() || !y.isFinite()) {
			if(x.isNaN() || y.isNaN()) {
				return NaN;
			}
			if(x.state === y.state) {
				return 0;
			}
			if(x.isPositiveInfinity() || y.isNegativeInfinity()) {
				return 1;
			}
			else {
				return -1;
			}
		}
		const x_sign = x.sign();
		const y_sign = y.sign();
		if(x_sign !== y_sign) {
			if(x_sign &gt; y_sign) {
				return 1;
			}
			else {
				return -1;
			}
		}
		else if(x_sign === 0) {
			return 0;
		}
		return x.compareToAbs(y) * x_sign;
	}

	/**
	 * Numeric type match.
	 * @param {KBigIntegerInputData} number 
	 * @returns {boolean}
	 */
	equalsState(number) {
		const x = this;
		const y = BigInteger._toBigInteger(number);
		return x.state === y.state;
	}

	/**
	 * Maximum number.
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} max([A, B])
	 */
	max(number) {
		const val = BigInteger._toBigInteger(number);
		if(this.compareTo(val) &gt;= 0) {
			return this.clone();
		}
		else {
			return val.clone();
		}
	}

	/**
	 * Minimum number.
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} min([A, B])
	 */
	min(number) {
		const val = BigInteger._toBigInteger(number);
		if(this.compareTo(val) &gt;= 0) {
			return val.clone();
		}
		else {
			return this.clone();
		}
	}

	/**
	 * Clip number within range.
	 * @param {KBigIntegerInputData} min 
	 * @param {KBigIntegerInputData} max
	 * @returns {BigInteger} min(max(x, min), max)
	 */
	clip(min, max) {
		const min_ = BigInteger._toBigInteger(min);
		const max_ = BigInteger._toBigInteger(max);
		if(this.isNaN() || min_.isNaN() || max_.isNaN()) {
			return BigInteger.NaN;
		}
		const arg_check = min_.compareTo(max_);
		if(arg_check === 1) {
			throw &quot;clip(min, max) error. (min &gt; max)-&gt;(&quot; + min_ + &quot; &gt; &quot; + max_ + &quot;)&quot;;
		}
		else if(arg_check === 0) {
			return min_;
		}
		if(this.compareTo(max_) === 1) {
			return max_;
		}
		else if(this.compareTo(min_) === -1) {
			return min_;
		}
		return this;
	}

	// ----------------------
	// &#x4E38;&#x3081;
	// ----------------------
	
	/**
	 * Floor.
	 * @returns {BigInteger} floor(A)
	 */
	floor() {
		return this;
	}

	/**
	 * Ceil.
	 * @returns {BigInteger} ceil(A)
	 */
	ceil() {
		return this;
	}
	
	/**
	 * Rounding to the nearest integer.
	 * @returns {BigInteger} round(A)
	 */
	round() {
		return this;
	}

	/**
	 * To integer rounded down to the nearest.
	 * @returns {BigInteger} fix(A), trunc(A)
	 */
	fix() {
		return this;
	}

	/**
	 * Fraction.
	 * @returns {BigInteger} fract(A)
	 */
	fract() {
		return BigInteger.ZERO;
	}

	// ----------------------
	// gcd, lcm
	// ----------------------
	
	/**
	 * Euclidean algorithm.
	 * @param {KBigIntegerInputData} number 
	 * @returns {BigInteger} gcd(x, y)
	 */
	gcd(number) {
		const val = BigInteger._toBigInteger(number);
		if(!this.isFinite() || !val.isFinite()) {
			return BigInteger.NaN;
		}
		/**
		 * @type {any}
		 */
		let x = this, y = val, z;
		let i = 10;
		while(y.sign() !== 0 &amp;&amp; i) {
			z = x.rem(y);
			x = y;
			y = z;
			i--;
		}
		return x;
	}

	/**
	 * Extended Euclidean algorithm.
	 * @param {KBigIntegerInputData} number 
	 * @returns {Array&lt;BigInteger&gt;} [a, b, gcd(x, y)], Result of calculating a*x + b*y = gcd(x, y).
	 */
	extgcd(number) {
		const val = BigInteger._toBigInteger(number);
		if(!this.isFinite() || !val.isFinite()) {
			return [BigInteger.NaN, BigInteger.NaN, BigInteger.NaN];
		}
		// &#x975E;&#x518D;&#x5E30;
		const ONE  = new BigInteger(1);
		const ZERO = new BigInteger(0);
		/**
		 * @type {any}
		 */
		let r0 = this, r1 = val, r2, q1;
		let a0 = ONE,  a1 = ZERO, a2;
		let b0 = ZERO, b1 = ONE,  b2;
		while(r1.sign() !== 0) {
			const y = r0.divideAndRemainder(r1);
			q1 = y[0];
			r2 = y[1];
			a2 = a0.subtract(q1.multiply(a1));
			b2 = b0.subtract(q1.multiply(b1));
			a0 = a1;
			a1 = a2;
			b0 = b1;
			b1 = b2;
			r0 = r1;
			r1 = r2;
		}
		return [a0, b0, r0];
	}

	/**
	 * Least common multiple.
	 * @param {KBigIntegerInputData} number 
	 * @returns {BigInteger} lcm(x, y)
	 */
	lcm(number) {
		const val = BigInteger._toBigInteger(number);
		if(!this.isFinite() || !val.isFinite()) {
			return BigInteger.NaN;
		}
		return this.mul(val).div(this.gcd(val));
	}

	// ----------------------
	// &#x7D20;&#x6570;&#x7CFB;
	// ----------------------
	
	/**
	 * Prime represented within the specified bit length.
	 * @param {KBigIntegerInputData} bits - Bit length.
	 * @param {Random} [random] - Class for creating random numbers.
	 * @param {KBigIntegerInputData} [certainty=100] - Repeat count (prime precision).
	 * @param {KBigIntegerInputData} [create_count=500] - Number of times to retry if prime generation fails.
	 * @returns {BigInteger}
	 */
	static probablePrime(bits, random, certainty, create_count ) {
		const certainty_ = certainty ? BigInteger._toInteger(certainty) : 100;
		const create_count_ = create_count ? BigInteger._toInteger(create_count) : 500;
		for(let i = 0; i &lt; create_count_; i++) {
			const x = BigInteger.createRandomBigInteger(bits, random);
			if(x.isProbablePrime(certainty_)) {
				return x;
			}
		}
		console.log(&quot;probablePrime &quot; + create_count);
		return BigInteger.NaN;
	}

	/**
	 * Return true if the value is prime number.
	 * - Calculate up to `2251799813685248(=2^51)`.
	 * @returns {boolean} - If the calculation range is exceeded, null is returned.
	 */
	isPrime() {
		if(!this.isFinite()) {
			return false;
		}
		// 0&#x3084;&#x8CA0;&#x306E;&#x5024;&#x306F;&#x3001;&#x7D20;&#x6570;&#x3067;&#x306F;&#x306A;&#x3044;
		if(this.sign() &lt;= 0) {
			return false;
		}
		// 47453132.81212578 = Math.sqrt(Number.MAX_SAFE_INTEGER)
		const limit = Math.sqrt(Math.pow(2, 51));
		const target_number = this.doubleValue;
		const count_max = Math.ceil(Math.sqrt(target_number));
		// 1, 2 -&gt; true
		if(target_number &lt;= 2) {
			return true;
		}
		// &#x6307;&#x5B9A;&#x3057;&#x305F;&#x5024;&#x3088;&#x308A;&#x5927;&#x304D;&#x3044;&#x5834;&#x5408;&#x306F;&#x8A08;&#x7B97;&#x4E0D;&#x53EF;&#x80FD;&#x3068;&#x3057;&#x3066; false &#x3092;&#x8FD4;&#x3059;
		if(count_max &gt; limit) {
			return null;
		}
		for(let i = 2; i &lt;= count_max; i++) {
			if((target_number % i) === 0) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Return true if the value is prime number by Miller-Labin prime number determination method.
	 * 
	 * Attention : it takes a very long time to process.
	 * @param {KBigIntegerInputData} [certainty=100] - Repeat count (prime precision).
	 * @returns {boolean}
	 */
	isProbablePrime(certainty) {
		if(!this.isFinite()) {
			return false;
		}
		const e = this.element;
		// 0&#x3084;&#x8CA0;&#x306E;&#x5024;&#x306F;&#x3001;&#x7D20;&#x6570;&#x3067;&#x306F;&#x306A;&#x3044;
		if(this.sign() &lt;= 0) {
			return false;
		}
		// 1, 2 -&gt; true
		if((e.length === 1)&amp;&amp;(e[0] &lt;= 2)) {
			return true;
		}
		// even number -&gt; false
		else if((e[0] &amp; 1) === 0) {
			return false;
		}
		// &#x30DF;&#x30E9;&#x30FC;&#x30E9;&#x30D3;&#x30F3;&#x7D20;&#x6570;&#x5224;&#x5B9A;&#x6CD5;
		// &#x304B;&#x306A;&#x308A;&#x51E6;&#x7406;&#x304C;&#x91CD;&#x305F;&#x3044;&#x3067;&#x3059;&#x3002;&#x307E;&#x3042;&#x304A;&#x904A;&#x3073;&#x7A0B;&#x5EA6;&#x306B;&#x4F7F;&#x7528;&#x3068;&#x3044;&#x3046;&#x611F;&#x3058;&#x3067;&#x3002;
		const loop	= certainty !== undefined ? BigInteger._toInteger(certainty) : 100;
		const ZERO	= BigInteger.ZERO;
		const ONE	= BigInteger.ONE;
		const n		= this;
		const LEN	= n.bitLength();
		const n_1	= n.subtract(ONE);
		const s 	= n_1.getLowestSetBit();
		const d 	= n_1.shift(-s);

		if(loop &lt;= 0) {
			return false;
		}

		for(let i = 0; i &lt; loop; i++ ) {
			//[ 1, n - 1] &#x306E;&#x7BC4;&#x56F2;&#x304B;&#x3089; a &#x3092;&#x9078;&#x629E;
			let a;
			do {
				a = BigInteger.createRandomBigInteger(LEN);
			} while(( a.compareTo(ZERO) === 0 )||( a.compareTo(n) !== -1 ));

			let t = d;
			// a^t != 1 mod n
			let y = a.modPow(t, n);
			
			while(true) {
				if((t.equals(n_1)) || (y.equals(ONE)) || (y.equals(n_1))) {
					break;
				}
				y = y.mul(y)._mod(n);
				t = t.shiftLeft(1);
			}

			if((!y.equals(n_1)) &amp;&amp; ((t.element[0] &amp; 1) === 0)) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Next prime.
	 * @param {KBigIntegerInputData} [certainty=100] - Repeat count (prime precision).
	 * @param {KBigIntegerInputData} [search_max=100000] - Search range of next prime.
	 * @returns {BigInteger}
	 */
	nextProbablePrime(certainty, search_max) {
		if(!this.isFinite()) {
			return BigInteger.NaN;
		}
		const loop	= certainty !== undefined ? (BigInteger._toInteger(certainty) &gt;&gt; 1) : 100 / 2;
		const search_max_ = search_max !== undefined ? BigInteger._toInteger(search_max) : 100000;
		const x = this.clone();
		for(let i = 0; i &lt; search_max_; i++) {
			x._add(BigInteger.ONE);
			if(x.isProbablePrime(loop)) {
				return x;
			}
		}
		throw &quot;nextProbablePrime [&quot; + search_max_ +&quot;]&quot;;
	}

	// ----------------------
	// &#x30B7;&#x30D5;&#x30C8;&#x6F14;&#x7B97;&#x7CFB;
	// ----------------------
	
	/**
	 * this &lt;&lt;= n
	 * @param {KBigIntegerInputData} shift_length - Bit shift size.
	 * @returns {BigInteger} A &lt;&lt;= n
	 * @private
	 */
	_shift(shift_length) {
		if(!this.isFinite()) {
			return this;
		}
		let n = BigInteger._toInteger(shift_length);
		if(n === 0) {
			return this;
		}
		const x = this.element;
		// 1&#x30D3;&#x30C3;&#x30C8;&#x306A;&#x3089;&#x5C02;&#x7528;&#x30B3;&#x30FC;&#x30C9;&#x3067;&#x9AD8;&#x901F;&#x8A08;&#x7B97;
		if(n === 1) {
			let i = x.length - 1;
			if((x[i] &amp; 0x8000) !==  0) {
				x[x.length] = 1;
			}
			for(;i &gt;= 0;i--) {
				x[i] &lt;&lt;= 1;
				x[i]  &amp;= 0xFFFF;
				if((i &gt; 0) &amp;&amp; ((x[i - 1] &amp; 0x8000) !==  0)) {
					x[i] += 1;
				}
			}
		}
		else if(n === -1) {
			for(let i = 0;i &lt; x.length;i++) {
				x[i] &gt;&gt;&gt;= 1;
				if((i &lt; x.length - 1) &amp;&amp; ((x[i + 1] &amp; 1) !==  0)) {
					x[i] |= 0x8000;
				}
			}
			if(x[x.length - 1] === 0) {
				x.pop();
			}
		}
		else {
			// 16&#x30D3;&#x30C3;&#x30C8;&#x5358;&#x4F4D;&#x306A;&#x3089;&#x914D;&#x5217;&#x3092;&#x8FFD;&#x52A0;&#x524A;&#x9664;&#x3059;&#x308B;&#x9AD8;&#x901F;&#x8A08;&#x7B97;
			if(n &gt;= 16) {
				const m = n &gt;&gt;&gt; 4;
				for(let i = x.length - 1; i &gt;= 0; i--) {
					x[i + m] = x[i];
				}
				for(let i = m - 1; i &gt;= 0; i--) {
					x[i] = 0;
				}
				n &amp;= 0xF;
			}
			else if(n &lt;= -16){
				const m = (-n) &gt;&gt;&gt; 4;
				x.splice(0, m);
				n += m &lt;&lt; 4;
			}
			if(n !== 0) {
				// 15&#x30D3;&#x30C3;&#x30C8;&#x4EE5;&#x5185;&#x306A;&#x3089;&#x30D3;&#x30C3;&#x30C8;&#x6F14;&#x7B97;&#x3067;&#x307E;&#x3068;&#x3081;&#x3066;&#x64CD;&#x4F5C;
				if(0 &lt; n) {
					let carry = 0;
					for(let i = 0; i &lt; x.length; i++) {
						x[i] = (x[i] &lt;&lt; n) + carry;
						if(x[i] &gt; 0xFFFF) {
							carry = x[i] &gt;&gt;&gt; 16;
							x[i] &amp;= 0xFFFF;
						}
						else {
							carry = 0;
						}
					}
					if(carry !== 0) {
						x[x.length] = carry;
					}
				}
				else {
					n = -n;
					for(let i = 0; i &lt; x.length; i++) {
						if(i !== x.length - 1) {
							x[i] += x[i + 1] &lt;&lt; 16;
							x[i] &gt;&gt;&gt;= n;
							x[i] &amp;= 0xFFFF;
						}
						else {
							x[i] &gt;&gt;&gt;= n;
						}
					}
					if(x[x.length - 1] === 0) {
						x.pop();
					}
				}
			}
		}
		return this;
	}

	/**
	 * this &lt;&lt; n
	 * @param {KBigIntegerInputData} n
	 * @returns {BigInteger} A &lt;&lt; n
	 */
	shift(n) {
		return this.clone()._shift(n);
	}

	/**
	 * this &lt;&lt; n
	 * @param {KBigIntegerInputData} n
	 * @returns {BigInteger} A &lt;&lt; n
	 */
	shiftLeft(n) {
		return this.shift(n);
	}

	/**
	 * this &gt;&gt; n
	 * @param {KBigIntegerInputData} n
	 * @returns {BigInteger} A &gt;&gt; n
	 */
	shiftRight(n) {
		return this.shift(-n);
	}

	// ----------------------
	// &#x30D3;&#x30C3;&#x30C8;&#x6F14;&#x7B97;&#x7CFB;
	// ----------------------
	
	/**
	 * Number of digits in which the number &quot;1&quot; appears first when expressed in binary.
	 * - Return -1 If 1 is not found it.
	 * @returns {number}
	 */
	getLowestSetBit() {
		if(!this.isFinite()) {
			return NaN;
		}
		for(let i = 0; i &lt; this.element.length; i++) {
			if(this.element[i] !==  0) {
				const x = this.element[i];
				for(let j = 0; j &lt; 16; j++) {
					if(((x &gt;&gt;&gt; j) &amp; 1) !==  0) {
						return i * 16 + j;
					}
				}
			}
		}
		return -1;
	}

	/**
	 * Length when the number is binary.
	 * @returns {number}
	 */
	bitLength() {
		if(!this.isFinite()) {
			return NaN;
		}
		for(let i = this.element.length - 1; i &gt;= 0; i--) {
			if(this.element[i] !==  0) {
				const x = this.element[i];
				for(let j = 15; j &gt;= 0; j--) {
					if(((x &gt;&gt;&gt; j) &amp; 1) !==  0) {
						return i * 16 + j + 1;
					}
				}
			}
		}
		return 0;
	}

	/**
	 * Sum that the bit is 1 when represented in the two&apos;s complement.
	 * @returns {number}
	 */
	bitCount() {
		if(!this.isFinite()) {
			return NaN;
		}
		let target;
		if(this.sign() &gt;= 0) {
			target = this;
		}
		else {
			target = this.add(new BigInteger(1));
		}
		const len = target.bitLength();
		let bit = 0;
		let count = 0;
		for(let i = 0;bit &lt; len;i++) {
			const x = target.element[i];
			for(let j = 0;((j &lt; 16) &amp;&amp; (bit &lt; len));j++, bit++) {
				if(((x &gt;&gt;&gt; j) &amp; 1) !==  0) {
					count = count + 1;
				}
			}
		}
		return count;
	}

	/**
	 * Logical AND. (mutable)
	 * @param {KBigIntegerInputData} number 
	 * @returns {BigInteger} A &amp;= B
	 * @private
	 */
	_and(number) {
		const val = BigInteger._toBigInteger(number);
		const e1 = this;
		const e2 = val;
		if((!e1.isFinite()) || (!e2.isFinite())) {
			let ret;
			if(e1.isNaN() || e2.isNaN()) {
				ret = BigInteger.NaN;
			}
			else {
				ret = BigInteger.ZERO;
			}
			ret = ret.clone();
			this.element = ret.element;
			this.state = ret.state;
			return this;
		}
		const s1  = e1.sign(), s2 = e2.sign();
		const len = Math.max(e1.bitLength(), e2.bitLength());
		// &#x5F15;&#x6570;&#x304C;&#x8CA0;&#x306E;&#x5834;&#x5408;&#x306F;&#x3001;2&#x306E;&#x88DC;&#x6570;
		const e1_array = e1.getTwosComplement(len).element;
		const e2_array = e2.getTwosComplement(len).element;
		const size = Math.max(e1_array.length, e2_array.length);
		this.element = [];
		for(let i = 0;i &lt; size;i++) {
			const x1 = (i &gt;= e1_array.length) ? 0 : e1_array[i];
			const x2 = (i &gt;= e2_array.length) ? 0 : e2_array[i];
			this.element[i] = x1 &amp; x2;
		}
		// &#x914D;&#x5217;&#x306E;&#x4E0A;&#x4F4D;&#x304C;&#x7A7A;&#x306B;&#x306A;&#x308B;&#x53EF;&#x80FD;&#x6027;&#x304C;&#x3042;&#x308B;&#x305F;&#x3081;&#x30CE;&#x30FC;&#x30DE;&#x30E9;&#x30A4;&#x30BA;&#x304C;&#x5FC5;&#x8981;
		this._memory_reduction();
		// &#x7B26;&#x53F7;&#x3092;&#x8A08;&#x7B97;
		if(this.state !== BIGINTEGER_NUMBER_STATE.ZERO &amp;&amp; ((s1 === 1)||(s2 === 1))) {
			this.state = BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER;
		}
		// &#x51FA;&#x529B;&#x304C;&#x8CA0;&#x306E;&#x5834;&#x5408;&#x306F;&#x3001;2&#x306E;&#x88DC;&#x6570;
		else if(this.state === BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER) {
			this.element = this.getTwosComplement(len).element;
			// &#x53CD;&#x8EE2;&#x3055;&#x305B;&#x305F;&#x3053;&#x3068;&#x3067;&#x914D;&#x5217;&#x306E;&#x4E0A;&#x4F4D;&#x304C;&#x7A7A;&#x306B;&#x306A;&#x308B;&#x53EF;&#x80FD;&#x6027;&#x304C;&#x3042;&#x308B;&#x305F;&#x3081;&#x30CE;&#x30FC;&#x30DE;&#x30E9;&#x30A4;&#x30BA;&#x304C;&#x5FC5;&#x8981;
			this._memory_reduction();
		}
		return this;
	}

	/**
	 * Logical AND.
	 * @param {KBigIntegerInputData} number 
	 * @returns {BigInteger} A &amp; B
	 */
	and(number) {
		return this.clone()._and(number);
	}

	/**
	 * Logical OR. (mutable)
	 * @param {KBigIntegerInputData} number 
	 * @returns {BigInteger} A |= B
	 * @private
	 */
	_or(number) {
		const val = BigInteger._toBigInteger(number);
		const e1 = this;
		const e2 = val;
		if((!e1.isFinite()) || (!e2.isFinite())) {
			let ret;
			if(e1.isNaN() || e2.isNaN()) {
				ret = BigInteger.NaN.clone();
			}
			else if(e1.isInfinite() || e2.isInfinite()) {
				ret = BigInteger.ZERO;
			}
			else {
				ret = e1.isInfinite() ? e2 : e1;
			}
			ret = ret.clone();
			this.element = ret.element;
			this.state = ret.state;
			return this;
		}

		const s1  = e1.sign(), s2 = e2.sign();
		const len = Math.max(e1.bitLength(), e2.bitLength());
		// &#x5F15;&#x6570;&#x304C;&#x8CA0;&#x306E;&#x5834;&#x5408;&#x306F;&#x3001;2&#x306E;&#x88DC;&#x6570;
		const e1_array = e1.getTwosComplement(len).element;
		const e2_array = e2.getTwosComplement(len).element;
		const size = Math.max(e1_array.length, e2_array.length);
		this.element = [];
		for(let i = 0;i &lt; size;i++) {
			const x1 = (i &gt;= e1_array.length) ? 0 : e1_array[i];
			const x2 = (i &gt;= e2_array.length) ? 0 : e2_array[i];
			this.element[i] = x1 | x2;
		}
		// &#x7B26;&#x53F7;&#x3092;&#x8A08;&#x7B97;
		this.state = ((s1 === -1)||(s2 === -1)) ?
			BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER :
			(Math.max(s1, s2) === 0 ? BIGINTEGER_NUMBER_STATE.ZERO : BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER);
		// &#x51FA;&#x529B;&#x304C;&#x8CA0;&#x306E;&#x5834;&#x5408;&#x306F;&#x3001;2&#x306E;&#x88DC;&#x6570;
		if(this.state === BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER) {
			this.element = this.getTwosComplement(len).element;
			// &#x53CD;&#x8EE2;&#x3055;&#x305B;&#x305F;&#x3053;&#x3068;&#x3067;&#x914D;&#x5217;&#x306E;&#x4E0A;&#x4F4D;&#x304C;&#x7A7A;&#x306B;&#x306A;&#x308B;&#x53EF;&#x80FD;&#x6027;&#x304C;&#x3042;&#x308B;&#x305F;&#x3081;&#x30CE;&#x30FC;&#x30DE;&#x30E9;&#x30A4;&#x30BA;&#x304C;&#x5FC5;&#x8981;
			this._memory_reduction();
		}
		return this;
	}

	/**
	 * Logical OR.
	 * @param {KBigIntegerInputData} number 
	 * @returns {BigInteger} A | B
	 */
	or(number) {
		return this.clone()._or(number);
	}

	/**
	 * Logical Exclusive-OR. (mutable)
	 * @param {KBigIntegerInputData} number 
	 * @returns {BigInteger} A ^= B
	 * @private
	 */
	_xor(number) {
		const val = BigInteger._toBigInteger(number);
		const e1 = this;
		const e2 = val;
		if((!e1.isFinite()) || (!e2.isFinite())) {
			let ret;
			if(e1.isNaN() || e2.isNaN()) {
				ret = BigInteger.NaN;
			}
			else if(e1.isInfinite() || e2.isInfinite()) {
				ret = BigInteger.ZERO;
			}
			else {
				ret = e1.isInfinite() ? e2 : e1; 
			}
			ret = ret.clone();
			this.element = ret.element;
			this.state = ret.state;
			return this;
		}
		const s1  = e1.sign(), s2 = e2.sign();
		const len = Math.max(e1.bitLength(), e2.bitLength());
		// &#x5F15;&#x6570;&#x304C;&#x8CA0;&#x306E;&#x5834;&#x5408;&#x306F;&#x3001;2&#x306E;&#x88DC;&#x6570;
		const e1_array = e1.getTwosComplement(len).element;
		const e2_array = e2.getTwosComplement(len).element;
		const size = Math.max(e1_array.length, e2_array.length);
		this.element = [];
		for(let i = 0;i &lt; size;i++) {
			const x1 = (i &gt;= e1_array.length) ? 0 : e1_array[i];
			const x2 = (i &gt;= e2_array.length) ? 0 : e2_array[i];
			this.element[i] = x1 ^ x2;
		}
		// &#x914D;&#x5217;&#x306E;&#x4E0A;&#x4F4D;&#x304C;&#x7A7A;&#x306B;&#x306A;&#x308B;&#x53EF;&#x80FD;&#x6027;&#x304C;&#x3042;&#x308B;&#x305F;&#x3081;&#x30CE;&#x30FC;&#x30DE;&#x30E9;&#x30A4;&#x30BA;&#x304C;&#x5FC5;&#x8981;
		this._memory_reduction();
		// &#x7B26;&#x53F7;&#x3092;&#x8A08;&#x7B97;
		this.state = ((s1 !== 0)&amp;&amp;(s1 !== s2)) ? BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER : BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER;
		// &#x51FA;&#x529B;&#x304C;&#x8CA0;&#x306E;&#x5834;&#x5408;&#x306F;&#x3001;2&#x306E;&#x88DC;&#x6570;
		if(this.state === BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER) {
			this.element = this.getTwosComplement(len).element;
			// &#x53CD;&#x8EE2;&#x3057;&#x305F;&#x3053;&#x3068;&#x3067;&#x3055;&#x3089;&#x306B;&#x7A7A;&#x306B;&#x306A;&#x308B;&#x53EF;&#x80FD;&#x6027;&#x304C;&#x3042;&#x308B;
			this._memory_reduction();
		}
		return this;
	}

	/**
	 * Logical Exclusive-OR.
	 * @param {KBigIntegerInputData} number 
	 * @returns {BigInteger} A ^ B
	 */
	xor(number) {
		return(this.clone()._xor(number));
	}

	/**
	 * Logical Not.
	 * @returns {BigInteger} A = !A
	 * @private
	 */
	_not() {
		return(this._add(new BigInteger(1))._negate());
	}

	/**
	 * Logical Not. (mutable)
	 * @returns {BigInteger} !A
	 */
	not() {
		return(this.clone()._not());
	}

	/**
	 * this | (1 &lt;&lt; n) (mutable)
	 * @param {KBigIntegerInputData} bit
	 * @returns {BigInteger}
	 * @private
	 */
	_setBit(bit) {
		const n = BigInteger._toInteger(bit);
		this._memory_allocation(n + 1);
		this.element[n &gt;&gt;&gt; 4] |= 1 &lt;&lt; (n &amp; 0xF);
		this.state = BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER;
		return this;
	}

	/**
	 * this | (1 &lt;&lt; n)
	 * @param {KBigIntegerInputData} bit
	 * @returns {BigInteger}
	 */
	setBit(bit) {
		const n = BigInteger._toInteger(bit);
		return this.clone()._setBit(n);
	}

	/**
	 * Invert a specific bit.) (mutable)
	 * @param {KBigIntegerInputData} bit
	 * @returns {BigInteger}
	 * @private
	 */
	_flipBit(bit) {
		const n = BigInteger._toInteger(bit);
		this._memory_allocation(n + 1);
		this.element[n &gt;&gt;&gt; 4] ^= 1 &lt;&lt; (n &amp; 0xF);
		this._memory_reduction();
		return this;
	}

	/**
	 * Invert a specific bit.
	 * @param {KBigIntegerInputData} bit
	 * @returns {BigInteger}
	 */
	flipBit(bit) {
		const n = BigInteger._toInteger(bit);
		return this.clone()._flipBit(n);
	}

	/**
	 * Lower a specific bit.
	 * @param {KBigIntegerInputData} bit 
	 * @returns {BigInteger}
	 */
	clearBit(bit) {
		const n = BigInteger._toInteger(bit);
		const y = this.clone();
		y.element[n &gt;&gt;&gt; 4] &amp;= ~(1 &lt;&lt; (n &amp; 0xF));
		y._memory_reduction();
		return y;
	}

	/**
	 * Test if a particular bit is on.
	 * @param {KBigIntegerInputData} bit
	 * @returns {boolean}
	 */
	testBit(bit) {
		const n = BigInteger._toInteger(bit);
		return ((this.element[n &gt;&gt;&gt; 4] &gt;&gt;&gt; (n &amp; 0xF)) &amp; 1) !== 0;
	}

	// ----------------------
	// &#x30C6;&#x30B9;&#x30C8;&#x7CFB;
	// ----------------------
	
	/**
	 * this === 0
	 * @returns {boolean}
	 */
	isZero() {
		return this.state === BIGINTEGER_NUMBER_STATE.ZERO;
	}
	
	/**
	 * this === 1
	 * @returns {boolean}
	 */
	isOne() {
		return this.state === BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER &amp;&amp; this.element.length === 1 &amp;&amp; this.element[0] === 1;
	}
	
	/**
	 * this &gt; 0
	 * @returns {boolean}
	 */
	isPositive() {
		return this.state === BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER || this.state === BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY;
	}

	/**
	 * this &lt; 0
	 * @returns {boolean}
	 */
	isNegative() {
		return this.state === BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER || this.state === BIGINTEGER_NUMBER_STATE.NEGATIVE_INFINITY;
	}

	/**
	 * this &gt;= 0
	 * @returns {boolean}
	 */
	isNotNegative() {
		return this.state === BIGINTEGER_NUMBER_STATE.ZERO || this.state === BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER || this.state === BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY;
	}
	
	/**
	 * this === NaN
	 * @returns {boolean} isNaN(A)
	 */
	isNaN() {
		return this.state === BIGINTEGER_NUMBER_STATE.NOT_A_NUMBER;
	}
	
	/**
	 * this === Infinity
	 * @returns {boolean} isPositiveInfinity(A)
	 */
	isPositiveInfinity() {
		return this.state === BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY;
	}

	/**
	 * this === -Infinity
	 * @returns {boolean} isNegativeInfinity(A)
	 */
	isNegativeInfinity() {
		return this.state === BIGINTEGER_NUMBER_STATE.NEGATIVE_INFINITY;
	}

	/**
	 * this === Infinity or -Infinity
	 * @returns {boolean} isPositiveInfinity(A) || isNegativeInfinity(A)
	 */
	isInfinite() {
		return this.isPositiveInfinity() || this.isNegativeInfinity();
	}
	
	/**
	 * Return true if the value is finite number.
	 * @returns {boolean} !isNaN(A) &amp;&amp; !isInfinite(A)
	 */
	isFinite() {
		return !this.isNaN() &amp;&amp; !this.isInfinite();
	}

	// ----------------------
	// &#x5B9A;&#x6570;
	// ----------------------
	
	/**
	 * -1
	 * @returns {BigInteger} -1
	 */
	static get MINUS_ONE() {
		return DEFINE.MINUS_ONE;
	}
	
	/**
	 * 0
	 * @returns {BigInteger} 0
	 */
	static get ZERO() {
		return DEFINE.ZERO;
	}

	/**
	 * 1
	 * @returns {BigInteger} 1
	 */
	static get ONE() {
		return DEFINE.ONE;
	}
	
	/**
	 * 2
	 * @returns {BigInteger} 2
	 */
	static get TWO() {
		return DEFINE.TWO;
	}
	
	/**
	 * 10
	 * @returns {BigInteger} 10
	 */
	static get TEN() {
		return DEFINE.TEN;
	}

	/**
	 * Positive infinity.
	 * @returns {BigInteger} Infinity
	 */
	static get POSITIVE_INFINITY() {
		return DEFINE.POSITIVE_INFINITY;
	}
	
	/**
	 * Negative Infinity.
	 * @returns {BigInteger} -Infinity
	 */
	static get NEGATIVE_INFINITY() {
		return DEFINE.NEGATIVE_INFINITY;
	}

	/**
	 * Not a Number.
	 * @returns {BigInteger} NaN
	 */
	static get NaN() {
		return DEFINE.NaN;
	}

	// ----------------------
	// &#x4E92;&#x63DB;&#x6027;
	// ----------------------
	
	/**
	 * The positive or negative sign of this number.
	 * - +1 if positive, -1 if negative, 0 if 0.
	 * @returns {number}
	 */
	signum() {
		return this.sign();
	}

	/**
	 * Subtract.
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} A - B
	 */
	subtract(number) {
		return this.sub(number);
	}

	/**
	 * Multiply.
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} A * B
	 */
	multiply(number) {
		return this.mul(number);
	}

	/**
	 * Divide.
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} fix(A / B)
	 */
	divide(number) {
		return this.div(number);
	}

	/**
	 * Remainder of division.
	 * - Result has same sign as the Dividend.
	 * @param {KBigIntegerInputData} number
	 * @returns {BigInteger} A % B
	 */
	remainder(number) {
		return this.rem(number);
	}

}

/**
 * Collection of constant values used in the class.
 * @ignore
 */
const DEFINE = {

	/**
	 * -1
	 */
	MINUS_ONE : new BigInteger(-1),

	/**
	 * 0
	 */
	ZERO : new BigInteger(0),
	
	/**
	 * 1
	 */
	ONE : new BigInteger(1),

	/**
	 * 2
	 */
	TWO : new BigInteger(2),

	/**
	 * 10
	 */
	TEN : new BigInteger(10),

	/**
	 * Positive infinity.
	 */
	POSITIVE_INFINITY : new BigInteger(Number.POSITIVE_INFINITY),

	/**
	 * Negative Infinity.
	 */
	NEGATIVE_INFINITY : new BigInteger(Number.NEGATIVE_INFINITY),

	/**
	 * Not a Number.
	 */
	NaN : new BigInteger(Number.NaN)
};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
