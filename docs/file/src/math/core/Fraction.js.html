<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/math/core/Fraction.js | konpeito</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="The collection of javascirpt library such as numerical calculation."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="konpeito"><meta property="twitter:description" content="The collection of javascirpt library such as numerical calculation."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/natade-jp/konpeito.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/konpeito.js~konpeito.html">konpeito</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-core">math/core</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/BigDecimal.js~BigDecimal.html">BigDecimal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/BigInteger.js~BigInteger.html">BigInteger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/Complex.js~Complex.html">Complex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/Fraction.js~Fraction.html">Fraction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/Matrix.js~Matrix.html">Matrix</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KBigDecimalDivideType">KBigDecimalDivideType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KBigDecimalInputData">KBigDecimalInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KBigDecimalLocalInputData">KBigDecimalLocalInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KBigDecimalScaleData">KBigDecimalScaleData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KBigIntegerInputData">KBigIntegerInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KComplexInputData">KComplexInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KFractionInputData">KFractionInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMatrixInputData">KMatrixInputData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMatrixSettings">KMatrixSettings</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-core-base">math/core/base</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/base/KonpeitoFloat.js~KonpeitoFloat.html">KonpeitoFloat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/base/KonpeitoInteger.js~KonpeitoInteger.html">KonpeitoInteger</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-core-context">math/core/context</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/context/MathContext.js~MathContext.html">MathContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/context/RoundingMode.js~RoundingMode.html">RoundingMode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/context/RoundingMode.js~RoundingModeEntity.html">RoundingModeEntity</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-core-tools">math/core/tools</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/LinearAlgebra.js~LinearAlgebra.html">LinearAlgebra</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/Probability.js~Probability.html">Probability</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/Random.js~Random.html">Random</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/Signal.js~Signal.html">Signal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/core/tools/Statistics.js~Statistics.html">Statistics</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KRandomSettings">KRandomSettings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KSignalSettings">KSignalSettings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KStatisticsSettings">KStatisticsSettings</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-tools">math/tools</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/DataAnalysis.js~DataAnalysis.html">DataAnalysis</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#math-tools-dataanalysis">math/tools/DataAnalysis</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/DataAnalysis/MultipleRegressionAnalysis.js~MultipleRegressionAnalysis.html">MultipleRegressionAnalysis</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/math/tools/DataAnalysis/PrincipalComponentAnalysis.js~PrincipalComponentAnalysis.html">PrincipalComponentAnalysis</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisAnova">KMultipleRegressionAnalysisAnova</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisOutput">KMultipleRegressionAnalysisOutput</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisPartialRegression">KMultipleRegressionAnalysisPartialRegression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisPartialRegressionData">KMultipleRegressionAnalysisPartialRegressionData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisSettings">KMultipleRegressionAnalysisSettings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KMultipleRegressionAnalysisVectorState">KMultipleRegressionAnalysisVectorState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KPrincipalComponent">KPrincipalComponent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KPrincipalComponentAnalysisOutput">KPrincipalComponentAnalysisOutput</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-KPrincipalComponentAnalysisSettings">KPrincipalComponentAnalysisSettings</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/math/core/Fraction.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&#xFEFF;/**
 * The script is part of konpeito.
 * 
 * AUTHOR:
 *  natade (http://twitter.com/natadea)
 * 
 * LICENSE:
 *  The MIT license https://opensource.org/licenses/MIT
 */

import Polyfill from &quot;../tools/Polyfill.js&quot;;
import BigInteger from &quot;./BigInteger.js&quot;;
import BigDecimal from &quot;./BigDecimal.js&quot;;
import MathContext from &quot;./context/MathContext.js&quot;;
import Complex from &quot;./Complex.js&quot;;
import Matrix from &quot;./Matrix.js&quot;;
import KonpeitoInteger from &quot;./base/KonpeitoInteger.js&quot;;

/**
 * Fraction type argument.
 * - Fraction
 * - BigInteger
 * - BigDecimal
 * - number
 * - boolean
 * - string
 * - Array&lt;KBigIntegerInputData&gt;
 * - {numerator:KBigIntegerInputData,denominator:KBigIntegerInputData}
 * - {doubleValue:number}
 * - {toString:function}
 * 
 * Initialization can be performed as follows.
 * - 10, &quot;10&quot;, &quot;10/1&quot;, &quot;10.0/1.0&quot;, [&quot;10&quot;, &quot;1&quot;], [10, 1]
 * - 0.01, &quot;0.01&quot;, &quot;0.1e-1&quot;, &quot;1/100&quot;, [1, 100], [2, 200], [&quot;2&quot;, &quot;200&quot;]
 * - &quot;1/3&quot;, &quot;0.[3]&quot;, &quot;0.(3)&quot;, &quot;0.&apos;3&apos;&quot;, &quot;0.&quot;3&quot;&quot;, [1, 3], [2, 6]
 * - &quot;3.555(123)&quot; = 3.555123123123..., &quot;147982 / 41625&quot;
 * @typedef {Fraction|BigInteger|BigDecimal|number|boolean|string|Array&lt;import(&quot;./BigInteger.js&quot;).KBigIntegerInputData&gt;|{numerator:import(&quot;./BigInteger.js&quot;).KBigIntegerInputData,denominator:import(&quot;./BigInteger.js&quot;).KBigIntegerInputData}|{doubleValue:number}|{toString:function}} KFractionInputData
 */

/**
 * Collection of functions used in Fraction.
 * @ignore
 */
class FractionTool {

	/**
	 * Create data for Fraction from strings.
	 * @param ntext {string}
	 * @return {Fraction}
	 */
	static to_fraction_data_from_number_string(ntext) {
		let scale = 0;
		let buff;
		let is_negate = false;
		// &#x6B63;&#x898F;&#x5316;
		let text = ntext.replace(/\s/g, &quot;&quot;).toLowerCase();
		// +-&#x306E;&#x7B26;&#x53F7;&#x304C;&#x3042;&#x308B;&#x304B;
		const number_text = [];
		buff = text.match(/^[+-]+/);
		if(buff !== null) {
			buff = buff[0];
			text = text.substr(buff.length);
			if(buff.indexOf(&quot;-&quot;) !== -1) {
				is_negate = true;
				number_text.push(&quot;-&quot;);
			}
		}
		// &#x6574;&#x6570;&#x90E8;&#x304C;&#x3042;&#x308B;&#x304B;
		buff = text.match(/^[0-9]+/);
		if(buff !== null) {
			buff = buff[0];
			text = text.substr(buff.length);
			number_text.push(buff);
		}
		// &#x6D6E;&#x52D5;&#x5C0F;&#x6570;&#x70B9;&#x306E;&#x8A08;&#x7B97;&#x304C;&#x306A;&#x3044;&#x5834;&#x5408;&#x306F;&#x3053;&#x3053;&#x3067;&#x5B8C;&#x4E86;
		if(text.length === 0) {
			return new Fraction([new BigInteger([number_text.join(&quot;&quot;), 10]), BigInteger.ONE]);
		}
		// &#x5DE1;&#x56DE;&#x5C0F;&#x6570;&#x70B9;&#x6307;&#x5B9A;&#x304C;&#x3042;&#x308B;&#x304B;
		let cyclic_decimal = null;
		if(/[()&apos;&quot;[\]]/.test(text)) {
			const match_data = text.match(/([^.]*)\.(\d*)[([&apos;&quot;](\d+)[)\]&apos;&quot;](.*)/);
			if(match_data === null) {
				throw &quot;Fraction Unsupported argument &quot; + text;
			}
			// &#x5DE1;&#x56DE;&#x5C11;&#x6570;&#x306E;&#x5834;&#x6240;
			const cyclic_decimal_scale = match_data[2].length;
			const cyclic_decimal_text = match_data[3];
			// &#x5DE1;&#x56DE;&#x5C11;&#x6570;&#x4EE5;&#x5916;&#x3092;&#x62BD;&#x51FA;
			if(cyclic_decimal_scale === 0) {
				text = match_data[1] + match_data[4];
			}
			else {
				text = match_data[1] + &quot;.&quot; + match_data[2] + match_data[4];
			}

			const numerator = new BigInteger([cyclic_decimal_text, 10]);
			const denominator_string = [];
			for(let i = 0; i &lt; cyclic_decimal_text.length; i++) {
				denominator_string.push(&quot;9&quot;);
			}
			const denominator = new BigInteger([denominator_string.join(&quot;&quot;), 10]);
			cyclic_decimal = new Fraction([numerator, denominator]);
			cyclic_decimal = cyclic_decimal.scaleByPowerOfTen(-cyclic_decimal_scale);
		}
		// &#x5C0F;&#x6570;&#x90E8;&#x304C;&#x3042;&#x308B;&#x304B;
		buff = text.match(/^\.[0-9]+/);
		if(buff !== null) {
			buff = buff[0];
			text = text.substr(buff.length);
			buff = buff.substr(1);
			scale = scale + buff.length;
			number_text.push(buff);
		}
		// &#x6307;&#x6570;&#x8868;&#x8A18;&#x304C;&#x3042;&#x308B;&#x304B;
		buff = text.match(/^e[+-]?[0-9]+/);
		if(buff !== null) {
			buff = buff[0].substr(1);
			scale = scale - parseInt(buff, 10);
		}

		let f = null;
		{
			let numerator = null;
			let denominator = null;
			// &#x51FA;&#x529B;&#x7528;&#x306E;&#x6587;&#x5B57;&#x3092;&#x4F5C;&#x6210;
			if(scale === 0) {
				numerator = new BigInteger([number_text.join(&quot;&quot;), 10]);
				denominator = BigInteger.ONE;
			}
			if(scale &lt; 0) {
				for(let i = 0; i &lt; -scale; i++) {
					number_text.push(&quot;0&quot;);
				}
				numerator = new BigInteger([number_text.join(&quot;&quot;), 10]);
				denominator = BigInteger.ONE;
			}
			else if(scale &gt; 0) {
				numerator = new BigInteger([number_text.join(&quot;&quot;), 10]);
				const denominator_string = [&quot;1&quot;];
				for(let i = 0; i &lt; scale; i++) {
					denominator_string.push(&quot;0&quot;);
				}
				denominator = new BigInteger([denominator_string.join(&quot;&quot;), 10]);
			}
			f = new Fraction([numerator, denominator]);
		}
		if(cyclic_decimal) {
			if(!is_negate) {
				f = f.add(cyclic_decimal);
			}
			else {
				f = f.sub(cyclic_decimal);
			}
		}
		return f;
	}

	/**
	 * Create data for Fraction from fractional string.
	 * @param ntext {string}
	 * @return {Fraction}
	 */
	static to_fraction_data_from_fraction_string(ntext) {
		// &#x7279;&#x6B8A;&#x306A;&#x72B6;&#x614B;
		if(/nan|inf/i.test(ntext)) {
			const ret = new Fraction();
			ret.denominator = BigInteger.ONE;
			if(/nan/i.test(ntext)) {
				ret.numerator = BigInteger.NaN;
			}
			else if(!/-/.test(ntext)) {
				ret.numerator = BigInteger.POSITIVE_INFINITY;
			}
			else {
				ret.numerator = BigInteger.NEGATIVE_INFINITY;
			}
			return ret;
		}
		if(ntext.indexOf(&quot;/&quot;) === -1) {
			return FractionTool.to_fraction_data_from_number_string(ntext);
		}
		else {
			const fraction_value = ntext.split(&quot;/&quot;);
			const numerator_value = FractionTool.to_fraction_data_from_number_string(fraction_value[0]);
			const denominator_value = FractionTool.to_fraction_data_from_number_string(fraction_value[1]);
			return numerator_value.div(denominator_value);
		}
	}

	/**
	 * Create data for Fraction from number.
	 * @param number {number|boolean}
	 * @return {Fraction}
	 */
	static to_fraction_data_from_number(number) {
		const value = typeof number !== &quot;boolean&quot; ? number : (number ? 1 : 0);
		let numerator = null;
		let denominator = null;
		if(!isFinite(value)) {
			const ret = new Fraction();
			ret.denominator = BigInteger.ONE;
			if(value === Infinity) {
				ret.numerator = BigInteger.POSITIVE_INFINITY;
			}
			else if(value === - Infinity) {
				ret.numerator = BigInteger.NEGATIVE_INFINITY;
			}
			else {
				ret.numerator = BigInteger.NaN;
			}
			return ret;
		}
		// 0.0
		else if(value === 0.0) {
			const ret = new Fraction();
			ret.denominator = BigInteger.ONE;
			ret.numerator = BigInteger.ZERO;
			return ret;
		}
		// &#x6574;&#x6570;
		else if( Math.abs(value - Math.round(value)) &lt;= Number.EPSILON) {
			numerator = new BigInteger(Math.round(value));
			denominator = BigInteger.ONE;
		}
		// &#x6D6E;&#x52D5;&#x5C0F;&#x6570;
		else {
			let scale = Math.trunc(Math.log(Math.abs(value)) / Math.log(10));
			let x = value / Math.pow(10, scale);
			// &#x30B9;&#x30B1;&#x30FC;&#x30EB;&#x3092;&#x9006;&#x306B;&#x3059;&#x308B;
			scale = - scale;
			for(let i = 0; i &lt; 14; i++) {
				x = x * 10;
				scale = scale + 1;
				if(Math.abs(x - Math.round(x)) &lt;= Number.EPSILON) {
					break;
				}
			}
			// &#x6700;&#x3082;&#x4E0B;&#x306E;&#x6841;&#x306F;&#x56DB;&#x6368;&#x4E94;&#x5165;&#x3059;&#x308B;
			x = Math.round(x * 1e14) / 1e14;
			if(scale &lt;= 0) {
				numerator = new BigInteger(value);
				denominator = BigInteger.ONE;
			}
			else {
				numerator = new BigInteger(x);
				const denominator_string = [&quot;1&quot;];
				for(let i = 0; i &lt; scale; i++) {
					denominator_string.push(&quot;0&quot;);
				}
				denominator = new BigInteger([denominator_string.join(&quot;&quot;), 10]);
			}
		}
		return new Fraction([numerator, denominator]);
	}

	/**
	 * Normalization.
	 * - Reduce fraction using gcd.
	 * - Add the sign to the numerator.
	 * - If the number is zero, the denominator is one.
	 * @param value {Fraction}
	 * @returns {void}
	 */
	static normalization(value) {
		if(value.denominator.equals(BigInteger.ONE)) {
			return;
		}
		if(value.denominator.equals(BigInteger.MINUS_ONE)) {
			value.numerator = value.numerator.negate();
			value.denominator = BigInteger.ONE;
			return;
		}
		if(value.numerator.equals(BigInteger.ZERO)) {
			value.denominator = BigInteger.ONE;
			return;
		}
		const gcd = value.numerator.gcd(value.denominator);
		let numerator = value.numerator.div(gcd);
		let denominator = value.denominator.div(gcd);
		if(denominator.sign() &lt; 0) {
			numerator = numerator.negate();
			denominator = denominator.negate();
		}
		value.numerator = numerator;
		value.denominator = denominator;
	}

}

/**
 * Fraction class (immutable).
 */
export default class Fraction extends KonpeitoInteger {

	/**
	 * Create an fraction.
	 * 
	 * Initialization can be performed as follows.
	 * - 10, &quot;10&quot;, &quot;10/1&quot;, &quot;10.0/1.0&quot;, [&quot;10&quot;, &quot;1&quot;], [10, 1]
	 * - 0.01, &quot;0.01&quot;, &quot;0.1e-1&quot;, &quot;1/100&quot;, [1, 100], [2, 200], [&quot;2&quot;, &quot;200&quot;]
	 * - &quot;1/3&quot;, &quot;0.[3]&quot;, &quot;0.(3)&quot;, &quot;0.&apos;3&apos;&quot;, &quot;0.&quot;3&quot;&quot;, [1, 3], [2, 6]
	 * - &quot;3.555(123)&quot; = 3.555123123123..., &quot;147982 / 41625&quot;
	 * @param {KFractionInputData} [number] - Fraction data. See how to use the function.
	 */
	constructor(number) {
		super();
		
		// &#x5206;&#x5B50;
		/**
		 * numerator
		 * @type {BigInteger}
		 */
		this.numerator = null;

		// &#x5206;&#x6BCD;
		/**
		 * denominator
		 * @type {BigInteger}
		 */
		this.denominator = null;

		if(arguments.length === 0) {
			this.numerator = BigInteger.ZERO;
			this.denominator = BigInteger.ONE;
		}
		else if(arguments.length === 1) {
			let is_normalization = false;
			if((typeof number === &quot;number&quot;) || (typeof number === &quot;boolean&quot;)) {
				const x = FractionTool.to_fraction_data_from_number(number);
				this.numerator = x.numerator;
				this.denominator = x.denominator;
			}
			else if(typeof number === &quot;string&quot;) {
				const x = FractionTool.to_fraction_data_from_fraction_string(number);
				this.numerator = x.numerator;
				this.denominator = x.denominator;
			}
			else if(number instanceof BigInteger) {
				this.numerator = number;
				this.denominator = BigInteger.ONE;
			}
			else if(number instanceof Fraction) {
				this.numerator = number.numerator;
				this.denominator = number.denominator;
			}
			else if((number instanceof Array) &amp;&amp; (number.length === 2)) {
				this.numerator = (number[0] instanceof BigInteger) ? number[0] : new BigInteger(number[0]);
				this.denominator = (number[1] instanceof BigInteger) ? number[1] : new BigInteger(number[1]);
				is_normalization = true;
			}
			else if(number instanceof BigDecimal) {
				const bigint = number.unscaledValue();
				if(!bigint.isFinite()) {
					this.numerator = bigint;
					this.denominator = BigInteger.ONE;
				}
				else {
					const value = new Fraction(number.unscaledValue());
					const x = value.scaleByPowerOfTen(-number.scale());
					this.numerator = x.numerator;
					this.denominator = x.denominator;
				}
			}
			else if(typeof number === &quot;object&quot;) {
				if(&quot;doubleValue&quot; in number) {
					const x = FractionTool.to_fraction_data_from_number(number.doubleValue);
					this.numerator = x.numerator;
					this.denominator = x.denominator;
				}
				else if((&quot;numerator&quot; in number) &amp;&amp; (&quot;denominator&quot; in number)) {
					this.numerator = (number.numerator instanceof BigInteger) ? number.numerator : new BigInteger(number.numerator);
					this.denominator = (number.denominator instanceof BigInteger) ? number.denominator : new BigInteger(number.denominator);
					is_normalization = true;
				}
				else {
					const x1 = FractionTool.to_fraction_data_from_fraction_string(number.toString());
					this.numerator = x1.numerator;
					this.denominator = x1.denominator;
				}
			}
			else {
				throw &quot;Fraction Unsupported argument &quot; + number;
			}
			if(is_normalization) {
				FractionTool.normalization(this);
			}
		}
		else {
			throw &quot;Fraction Unsupported argument &quot; + number;
		}
	}

	/**
	 * Create an entity object of this class.
	 * @param {KFractionInputData} number 
	 * @returns {Fraction}
	 */
	static create(number) {
		if(number instanceof Fraction) {
			return number;
		}
		else {
			return new Fraction(number);
		}
	}

	/**
	 * Convert number to Fraction type.
	 * @param {KFractionInputData} number 
	 * @returns {Fraction}
	 */
	static valueOf(number) {
		return Fraction.create(number);
	}

	/**
	 * Convert to Fraction.
	 * @param {KFractionInputData} number 
	 * @returns {Fraction}
	 * @ignore
	 */
	static _toFraction(number) {
		if(number instanceof Fraction) {
			return number;
		}
		else {
			return new Fraction(number);
		}
	}

	/**
	 * Convert to real number.
	 * @param {KFractionInputData} number 
	 * @returns {number}
	 * @ignore
	 */
	static _toFloat(number) {
		if(typeof number === &quot;number&quot;) {
			return number;
		}
		else if(number instanceof Fraction) {
			return number.doubleValue;
		}
		else {
			return (new Fraction(number)).doubleValue;
		}
	}

	/**
	 * Convert to integer.
	 * @param {KFractionInputData} number 
	 * @returns {number}
	 * @ignore
	 */
	static _toInteger(number) {
		if(typeof number === &quot;number&quot;) {
			return Math.trunc(number);
		}
		else if(number instanceof Fraction) {
			return number.intValue;
		}
		else {
			return (new Fraction(number)).intValue;
		}
	}

	/**
	 * Deep copy.
	 * @returns {Fraction} 
	 */
	clone() {
		return new Fraction(this);
	}

	/**
	 * Absolute value.
	 * @returns {Fraction} abs(A)
	 */
	abs() {
		if(!this.isFinite()) {
			return this.isNegativeInfinity() ? Fraction.POSITIVE_INFINITY : this;
		}
		if(this.sign() &gt;= 0) {
			return this;
		}
		return this.negate();
	}

	/**
	 * this * -1
	 * @returns {Fraction} -A
	 */
	negate() {
		if(!this.isFinite()) {
			if(this.isPositiveInfinity()) {
				return Fraction.NEGATIVE_INFINITY;
			}
			else if(this.isNegativeInfinity()) {
				return Fraction.POSITIVE_INFINITY;
			}
			else {
				return this;
			}
		}
		return new Fraction([this.numerator.negate(), this.denominator]);
	}

	/**
	 * The positive or negative sign of this number.
	 * - +1 if positive, -1 if negative, 0 if 0.
	 * @returns {number}
	 */
	sign() {
		if(!this.isFinite()) {
			return this.isNaN() ? NaN : (this.isPositiveInfinity() ? 1 : -1);
		}
		return this.numerator.sign();
	}
	
	/**
	 * Convert to string.
	 * @returns {string} 
	 */
	toString() {
		if(!this.isFinite()) {
			return this.isNaN() ? &quot;NaN&quot; : (this.isPositiveInfinity() ? &quot;Infinity&quot; : &quot;-Infinity&quot;);
		}
		if(this.isInteger()) {
			return this.numerator.toString();
		}
		return this.toFractionString();
	}

	/**
	 * Convert to JSON.
	 * @returns {string} 
	 */
	toJSON() {
		return this.toString();
	}

	/**
	 * Convert to string. For example, output `1/3` if `0.333...`.
	 * @returns {string} 
	 */
	toFractionString() {
		if(!this.isFinite()) {
			return this.isNaN() ? &quot;NaN&quot; : (this.isPositiveInfinity() ? &quot;Infinity&quot; : &quot;-Infinity&quot;);
		}
		return this.numerator.toString() + &quot;/&quot; + this.denominator.toString();
	}

	/**
	 * Convert to string. For example, output `0.(3)` if `0.333...`.
	 * @param {KFractionInputData} [depth_max] - Maximum number of divisions.
	 * @returns {string} 
	 */
	toPlainString(depth_max) {
		if(!this.isFinite()) {
			return this.isNaN() ? &quot;NaN&quot; : (this.isPositiveInfinity() ? &quot;Infinity&quot; : &quot;-Infinity&quot;);
		}
		if(this.isInteger()) {
			return this.numerator.toString();
		}
		const sign = this.numerator.sign();
		let src = this.numerator.abs();
		const tgt = this.denominator;
		let output = null;
		const output_array = [];
		/**
		 * @type {any}
		 */
		const remaind_map = {};
		let check_max;
		if(depth_max !== undefined) {
			check_max = Fraction._toInteger(depth_max);
		}
		else {
			check_max = (src.toString().length + tgt.toString().length) * 10;
		}
		for(let i = 0; i &lt; check_max; i++) {
			const result = src.divideAndRemainder(tgt);
			const result_divide		= result[0];
			const result_remaind	= result[1];
			const remstr = result_remaind.toString();
			output_array.push(result_divide.toString());
			// &#x540C;&#x4E00;&#x306E;&#x4F59;&#x308A;&#x304C;&#x3042;&#x308B;&#x3068;&#x3044;&#x3046;&#x3053;&#x3068;&#x306F;&#x5FAA;&#x74B0;&#x5C0F;&#x6570;
			if(remaind_map[remstr] !== undefined) {
				output = output_array.join(&quot;&quot;);
				const n = output.indexOf(&quot;.&quot;) + remaind_map[remstr] + 1;
				output = output.substr(0, n) + &quot;(&quot; + output.substr(n, output.length - n) + &quot;)&quot;;
				break;
			}
			else {
				remaind_map[remstr] = i;
			}
			if(result_remaind.isZero()) {
				break;
			}
			if(i === 0) {
				output_array.push(&quot;.&quot;);
			}
			src = result_remaind.scaleByPowerOfTen(1);
		}
		if(output === null) {
			output = output = output_array.join(&quot;&quot;);
		}
		return (sign &lt; 0 ? &quot;-&quot; : &quot;&quot;) + output;
	}

	// ----------------------
	// &#x56DB;&#x5247;&#x6F14;&#x7B97;
	// ----------------------
	
	/**
	 * Add.
	 * @param {KFractionInputData} num
	 * @return {Fraction} A + B
	 */
	add(num) {
		const x = this;
		const y = Fraction._toFraction(num);
		if(!x.isFinite() || !y.isFinite()) {
			if(x.isNaN() || y.isNaN() || (x.isInfinite() &amp;&amp; y.isInfinite() &amp;&amp; !x.equalsState(y))) {
				return Fraction.NaN;
			}
			else if(x.isPositiveInfinity() || y.isPositiveInfinity()) {
				return Fraction.POSITIVE_INFINITY;
			}
			else {
				return Fraction.NEGATIVE_INFINITY;
			}
		}
		let f;
		if(x.isInteger() &amp;&amp; y.isInteger()) {
			f = new Fraction([ x.numerator.add(y.numerator), BigInteger.ONE]);
		}
		else {
			f = new Fraction([
				x.numerator.mul(y.denominator).add(y.numerator.mul(x.denominator)),
				x.denominator.mul(y.denominator)
			]);
		}
		return f;
	}

	/**
	 * Subtract.
	 * @param {KFractionInputData} num
	 * @return {Fraction} A - B
	 */
	sub(num) {
		const x = this;
		const y = Fraction._toFraction(num);
		if(!x.isFinite() || !y.isFinite()) {
			if(x.isNaN() || y.isNaN() || x.equalsState(y)) {
				return Fraction.NaN;
			}
			else if(x.isNegativeInfinity() || y.isPositiveInfinity()) {
				return Fraction.NEGATIVE_INFINITY;
			}
			else {
				return Fraction.POSITIVE_INFINITY;
			}
		}
		let f;
		if(x.isInteger() &amp;&amp; y.isInteger()) {
			f = new Fraction([ x.numerator.sub(y.numerator), BigInteger.ONE]);
		}
		else {
			f = new Fraction([
				x.numerator.mul(y.denominator).sub(y.numerator.mul(x.denominator)),
				x.denominator.mul(y.denominator)
			]);
		}
		return f;
	}

	/**
	 * Multiply.
	 * @param {KFractionInputData} num
	 * @return {Fraction} A * B
	 */
	mul(num) {
		const x = this;
		const y = Fraction._toFraction(num);
		if(!x.isFinite() || !y.isFinite()) {
			if(x.isNaN() || y.isNaN() || (x.isZero() || y.isZero())) {
				return Fraction.NaN;
			}
			else if(x.sign() * y.sign() &gt; 0) {
				return Fraction.POSITIVE_INFINITY;
			}
			else {
				return Fraction.NEGATIVE_INFINITY;
			}
		}
		let f;
		if(x.isInteger() &amp;&amp; y.isInteger()) {
			f = new Fraction([ x.numerator.mul(y.numerator), BigInteger.ONE]);
		}
		else {
			f = new Fraction([ x.numerator.mul(y.numerator), x.denominator.mul(y.denominator) ]);
		}
		return f;
	}

	/**
	 * Divide.
	 * @param {KFractionInputData} num
	 * @return {Fraction} A / B
	 */
	div(num) {
		const x = this;
		const y = Fraction._toFraction(num);
		if(!x.isFinite() || !y.isFinite()) {
			if(x.isNaN() || y.isNaN() || (x.isInfinite() &amp;&amp; y.isInfinite())) {
				return Fraction.NaN;
			}
			else if(x.isInfinite()) {
				if(x.sign() * y.sign() &gt;= 0) {
					return Fraction.POSITIVE_INFINITY;
				}
				else {
					return Fraction.NEGATIVE_INFINITY;
				}
			}
			else {
				return Fraction.ZERO;
			}
		}
		else if(y.isZero()) {
			if(x.isZero()) {
				return Fraction.NaN;
			}
			else {
				return x.sign() &gt;= 0 ? Fraction.POSITIVE_INFINITY : Fraction.NEGATIVE_INFINITY;
			}
		}
		let f;
		if(x.isInteger() &amp;&amp; y.isInteger()) {
			f = new Fraction([ x.numerator, y.numerator]);
		}
		else {
			f = new Fraction([ x.numerator.mul(y.denominator), y.numerator.mul(x.denominator)]);
		}
		return f;
	}

	/**
	 * Inverse number of this value.
	 * @return {Fraction} 1 / A
	 */
	inv() {
		{
			if(!this.isFinite()) {
				return this.isNaN() ? Fraction.NaN : Fraction.ZERO;
			}
			if(this.isZero()) {
				return Fraction.NaN;
			}
		}
		return new Fraction([ this.denominator, this.numerator]);
	}

	/**
	 * Modulo, positive remainder of division.
	 * - Result has same sign as the Dividend.
	 * @param {KFractionInputData} num
	 * @return {Fraction} A rem B
	 */
	rem(num) {
		const x = this;
		const y = Fraction._toFraction(num);
		if(!x.isFinite() || !y.isFinite() || y.isZero()) {
			return Fraction.NaN;
		}
		// x - y * fix(x/y)
		return x.sub(y.mul(x.div(y).fix()));
	}

	/**
	 * Modulo, positive remainder of division.
	 * - Result has same sign as the Divisor.
	 * @param {KFractionInputData} num
	 * @returns {Fraction} A mod B
	 */
	mod(num) {
		const x = this;
		const y = Fraction._toFraction(num);
		if(y.isZero()) {
			return x;
		}
		const ret = x.rem(y);
		if(!x.equalsState(y)) {
			return ret.add(y);
		}
		else {
			return ret;
		}
	}

	// ----------------------
	// &#x6307;&#x6570;
	// ----------------------
	
	/**
	 * Power function.
	 * - Supports only integers.
	 * @param {KFractionInputData} num
	 * @returns {Fraction} pow(A, B)
	 */
	pow(num) {
		const x = this;
		const y = Fraction._toFraction(num);
		{
			if(x.isNaN() || y.isNaN()) {
				return Fraction.NaN;
			}
			if(y.isZero()) {
				return Fraction.ONE;
			}
			else if(x.isZero()) {
				return Fraction.ZERO;
			}
			else if(x.isOne()) {
				return Fraction.ONE;
			}
			else if(x.isInfinite()) {
				if(x.isPositiveInfinity()) {
					return Fraction.POSITIVE_INFINITY;
				}
				else {
					if(y.isPositiveInfinity()) {
						return Fraction.NaN;
					}
					else {
						return new Fraction(Infinity * Math.pow(-1, Math.round(y.doubleValue)));
					}
				}
			}
			else if(y.isInfinite()) {
				if(x.isNegative()) {
					// &#x8907;&#x7D20;&#x6570;
					return Fraction.NaN;
				}
				if(x.compareTo(Fraction.ONE) &lt; 0) {
					if(y.isPositiveInfinity()) {
						return Fraction.ZERO;
					}
					else if(y.isNegativeInfinity()) {
						return Fraction.POSITIVE_INFINITY;
					}
				}
				else {
					if(y.isPositiveInfinity()) {
						return Fraction.POSITIVE_INFINITY;
					}
					else if(y.isNegativeInfinity()) {
						return Fraction.ZERO;
					}
				}
			}
		}
		const numerator = x.numerator.pow(y.intValue);
		const denominator = x.denominator.pow(y.intValue);
		return new Fraction([ numerator, denominator ]);
	}

	/**
	 * Square.
	 * @returns {Fraction} pow(A, 2)
	 */
	square() {
		return this.mul(this);
	}

	// ----------------------
	// &#x305D;&#x306E;&#x4ED6;&#x306E;&#x6F14;&#x7B97;
	// ----------------------
	
	/**
	 * Factorial function, x!.
	 * - Supports only integers.
	 * @returns {Fraction} n!
	 */
	factorial() {
		if(!this.isFinite()) {
			return this;
		}
		return new Fraction([this.toBigInteger().factorial(), Fraction.ONE]);
	}

	/**
	 * Multiply a multiple of ten.
	 * - Supports only integers.
	 * @param {KFractionInputData} n
	 * @returns {Fraction}
	 */
	scaleByPowerOfTen(n) {
		if(!this.isFinite()) {
			return this;
		}
		const scale = Fraction._toInteger(n);
		if(scale === 0) {
			return this;
		}
		let f;
		if(scale &gt; 0) {
			f = new Fraction([ this.numerator.scaleByPowerOfTen(scale), this.denominator]);
		}
		else if(scale &lt; 0) {
			f = new Fraction([ this.numerator, this.denominator.scaleByPowerOfTen(-scale)]);
		}
		return f;
	}

	// ----------------------
	// &#x4ED6;&#x306E;&#x578B;&#x306B;&#x5909;&#x63DB;&#x7528;
	// ----------------------
	
	/**
	 * boolean value.
	 * @returns {boolean}
	 */
	get booleanValue() {
		return this.numerator.booleanValue;
	}

	/**
	 * integer value.
	 * @returns {number}
	 */
	get intValue() {
		if(!this.isFinite()) {
			return this.isNaN() ? NaN : (this.isPositiveInfinity() ? Infinity : -Infinity);
		}
		if(this.isInteger()) {
			return Math.trunc(this.numerator.doubleValue);
		}
		return Math.trunc(this.doubleValue);
	}

	/**
	 * floating point.
	 * @returns {number}
	 */
	get doubleValue() {
		if(!this.isFinite()) {
			return this.isNaN() ? NaN : (this.isPositiveInfinity() ? Infinity : -Infinity);
		}
		if(this.isInteger()) {
			return this.numerator.doubleValue;
		}
		const x = new BigDecimal([this.numerator, MathContext.UNLIMITED]);
		const y = new BigDecimal([this.denominator, MathContext.UNLIMITED]);
		return x.div(y, {context : MathContext.DECIMAL64}).doubleValue;
	}

	// ----------------------
	// konpeito &#x3067;&#x6271;&#x3046;&#x6570;&#x5024;&#x578B;&#x3078;&#x5909;&#x63DB;
	// ----------------------
	
	/**
	 * return BigInteger.
	 * @returns {BigInteger}
	 */
	toBigInteger() {
		return new BigInteger(this.fix().numerator);
	}
	
	/**
	 * return BigDecimal.
	 * @param {MathContext} [mc] - MathContext setting after calculation. 
	 * @returns {BigDecimal}
	 */
	toBigDecimal(mc) {
		if(!this.isFinite()) {
			return new BigDecimal(this.doubleValue);
		}
		if(this.isInteger()) {
			return new BigDecimal(this.numerator);
		}
		const x = new BigDecimal([this.numerator, MathContext.UNLIMITED]);
		const y = new BigDecimal([this.denominator, MathContext.UNLIMITED]);
		if(mc) {
			return x.div(y, {context: mc});
		}
		else {
			return x.div(y, {context: BigDecimal.getDefaultContext()});
		}
	}
	
	/**
	 * return Fraction.
	 * @returns {Fraction}
	 */
	toFraction() {
		return this;
	}
	
	/**
	 * return Complex.
	 * @returns {Complex}
	 */
	toComplex() {
		return new Complex(this);
	}
	
	/**
	 * return Matrix.
	 * @returns {Matrix}
	 */
	toMatrix() {
		return new Matrix(this);
	}

	// ----------------------
	// &#x6BD4;&#x8F03;
	// ----------------------
	
	/**
	 * Equals.
	 * @param {KFractionInputData} num
	 * @returns {boolean} A === B
	 */
	equals(num) {
		const x = this;
		const y = Fraction._toFraction(num);
		if(!x.isFinite() || !y.isFinite()) {
			if(x.isNaN() || y.isNaN()) {
				return false;
			}
			else if(x.equalsState(y)) {
				return true;
			}
			else {
				return false;
			}
		}
		return x.numerator.equals(y.numerator) &amp;&amp; x.denominator.equals(y.denominator);
	}

	/**
	 * Numeric type match.
	 * @param {KFractionInputData} number 
	 * @returns {boolean}
	 */
	equalsState(number) {
		const x = this;
		const y = Fraction._toFraction(number);
		return x.numerator.equalsState(y.numerator);
	}

	/**
	 * Compare values.
	 * @param {KFractionInputData} num
	 * @returns {number} A &gt; B ? 1 : (A === B ? 0 : -1)
	 */
	compareTo(num) {
		const x = this;
		const y = Fraction._toFraction(num);
		if(!x.isFinite() || !y.isFinite()) {
			return x.numerator.compareTo(y.numerator);
		}
		return x.sub(y).sign();
	}

	/**
	 * Maximum number.
	 * @param {KFractionInputData} number
	 * @returns {Fraction} max([A, B])
	 */
	max(number) {
		const val = Fraction._toFraction(number);
		if(this.isNaN() || val.isNaN()) {
			return Fraction.NaN;
		}
		if(this.compareTo(val) &gt;= 0) {
			return this;
		}
		else {
			return val;
		}
	}

	/**
	 * Minimum number.
	 * @param {KFractionInputData} number
	 * @returns {Fraction} min([A, B])
	 */
	min(number) {
		const val = Fraction._toFraction(number);
		if(this.isNaN() || val.isNaN()) {
			return Fraction.NaN;
		}
		if(this.compareTo(val) &gt;= 0) {
			return val;
		}
		else {
			return this;
		}
	}

	/**
	 * Clip number within range.
	 * @param {KFractionInputData} min 
	 * @param {KFractionInputData} max
	 * @returns {Fraction} min(max(x, min), max)
	 */
	clip(min, max) {
		const min_ = Fraction._toFraction(min);
		const max_ = Fraction._toFraction(max);
		if(this.isNaN() || min_.isNaN() || max_.isNaN()) {
			return Fraction.NaN;
		}
		const arg_check = min_.compareTo(max_);
		if(arg_check === 1) {
			throw &quot;clip(min, max) error. (min &gt; max)-&gt;(&quot; + min_ + &quot; &gt; &quot; + max_ + &quot;)&quot;;
		}
		else if(arg_check === 0) {
			return min_;
		}
		if(this.compareTo(max_) === 1) {
			return max_;
		}
		else if(this.compareTo(min_) === -1) {
			return min_;
		}
		return this;
	}

	// ----------------------
	// &#x4E38;&#x3081;
	// ----------------------
	
	/**
	 * Floor.
	 * @returns {Fraction} floor(A)
	 */
	floor() {
		if(this.isInteger() || !this.isFinite()) {
			return this;
		}
		const x = this.fix();
		if(this.sign() &gt; 0) {
			return x;
		}
		else {
			return new Fraction([x.numerator.sub(BigInteger.ONE), Fraction.ONE]);
		}
	}

	/**
	 * Ceil.
	 * @returns {Fraction} ceil(A)
	 */
	ceil() {
		if(this.isInteger() || !this.isFinite()) {
			return this;
		}
		const x = this.fix();
		if(this.sign() &gt; 0) {
			return new Fraction([x.numerator.add(BigInteger.ONE), Fraction.ONE]);
		}
		else {
			return x;
		}
	}
	
	/**
	 * Rounding to the nearest integer.
	 * @returns {Fraction} round(A)
	 */
	round() {
		if(this.isInteger() || !this.isFinite()) {
			return this;
		}
		const x = this.floor();
		const fract = this.sub(x);
		if(fract.compareTo(Fraction.HALF) &gt;= 0) {
			return new Fraction([x.numerator.add(BigInteger.ONE), Fraction.ONE]);
		}
		else {
			return x;
		}
	}

	/**
	 * To integer rounded down to the nearest.
	 * @returns {Fraction} fix(A), trunc(A)
	 */
	fix() {
		if(this.isInteger() || !this.isFinite()) {
			return this;
		}
		return new Fraction([this.numerator.div(this.denominator), Fraction.ONE]);
	}

	/**
	 * Fraction.
	 * @returns {Fraction} fract(A)
	 */
	fract() {
		if(!this.isFinite()) {
			return Fraction.NaN;
		}
		if(this.isInteger()) {
			return Fraction.ZERO;
		}
		return this.sub(this.floor());
	}

	// ----------------------
	// &#x30C6;&#x30B9;&#x30C8;&#x7CFB;
	// ----------------------
	
	/**
	 * Return true if the value is integer.
	 * @return {boolean}
	 */
	isInteger() {
		if(!this.isFinite()) {
			return false;
		}
		return this.denominator.equals(BigInteger.ONE);
	}

	/**
	 * this === 0
	 * @return {boolean} A === 0
	 */
	isZero() {
		if(!this.isFinite()) {
			return false;
		}
		return this.numerator.isZero();
	}

	/**
	 * this === 1
	 * @return {boolean} A === 1
	 */
	isOne() {
		if(!this.isFinite()) {
			return false;
		}
		return this.numerator.equals(BigInteger.ONE) &amp;&amp; this.denominator.equals(BigInteger.ONE);
	}

	/**
	 * this &gt; 0
	 * @returns {boolean}
	 */
	isPositive() {
		return this.numerator.isPositive();
	}

	/**
	 * this &lt; 0
	 * @returns {boolean}
	 */
	isNegative() {
		return this.numerator.isNegative();
	}

	/**
	 * this &gt;= 0
	 * @returns {boolean}
	 */
	isNotNegative() {
		return this.numerator.isNotNegative();
	}
	
	/**
	 * this === NaN
	 * @returns {boolean} isNaN(A)
	 */
	isNaN() {
		return this.numerator.isNaN();
	}
	
	/**
	 * this === Infinity
	 * @returns {boolean} isPositiveInfinity(A)
	 */
	isPositiveInfinity() {
		return this.numerator.isPositiveInfinity();
	}

	/**
	 * this === -Infinity
	 * @returns {boolean} isNegativeInfinity(A)
	 */
	isNegativeInfinity() {
		return this.numerator.isNegativeInfinity();
	}

	/**
	 * this === Infinity or -Infinity
	 * @returns {boolean} isPositiveInfinity(A) || isNegativeInfinity(A)
	 */
	isInfinite() {
		return this.numerator.isInfinite();
	}
	
	/**
	 * Return true if the value is finite number.
	 * @returns {boolean} !isNaN(A) &amp;&amp; !isInfinite(A)
	 */
	isFinite() {
		return this.numerator.isFinite();
	}

	/**
	 * Return true if the value is repeating decimal.
	 * @returns {boolean} 
	 */
	isRepeatingDecimal() {
		if(!this.isFinite()) {
			return false;
		}
		return !this.isInteger() &amp;&amp; !(this.denominator.rem(2).isZero() || this.denominator.rem(5).isZero());
	}

	// ----------------------
	// &#x30D3;&#x30C3;&#x30C8;&#x6F14;&#x7B97;&#x7CFB;
	// ----------------------
	
	/**
	 * Logical AND.
	 * - Calculated as an integer.
	 * @param {KFractionInputData} number 
	 * @returns {Fraction} A &amp; B
	 */
	and(number) {
		const n_src = this;
		const n_tgt = Fraction._toFraction(number);
		const src	= n_src.round().toBigInteger();
		const tgt	= n_tgt.round().toBigInteger();
		return new Fraction(src.and(tgt));
	}

	/**
	 * Logical OR.
	 * - Calculated as an integer.
	 * @param {KFractionInputData} number 
	 * @returns {Fraction} A | B
	 */
	or(number) {
		const n_src = this;
		const n_tgt = Fraction._toFraction(number);
		const src	= n_src.round().toBigInteger();
		const tgt	= n_tgt.round().toBigInteger();
		return new Fraction(src.or(tgt));
	}

	/**
	 * Logical Exclusive-OR.
	 * - Calculated as an integer.
	 * @param {KFractionInputData} number 
	 * @returns {Fraction} A ^ B
	 */
	xor(number) {
		const n_src = this;
		const n_tgt = Fraction._toFraction(number);
		const src	= n_src.round().toBigInteger();
		const tgt	= n_tgt.round().toBigInteger();
		return new Fraction(src.xor(tgt));
	}

	/**
	 * Logical Not. (mutable)
	 * - Calculated as an integer.
	 * @returns {Fraction} !A
	 */
	not() {
		const n_src = this;
		const src	= n_src.round().toBigInteger();
		return new Fraction(src.not());
	}
	
	/**
	 * this &lt;&lt; n
	 * - Calculated as an integer.
	 * @param {KFractionInputData} n
	 * @returns {Fraction} A &lt;&lt; n
	 */
	shift(n) {
		const src		= this.round().toBigInteger();
		const number	= Fraction._toInteger(n);
		return new Fraction(src.shift(number));
	}
	
	// ----------------------
	// factor
	// ----------------------

	/**
	 * Factorization.
	 * - Calculated as an integer.
	 * - Calculate up to `9007199254740991`.
	 * @returns {Fraction[]} factor
	 */
	factor() {
		const x = this.round().toBigInteger().factor();
		const y = [];
		for(let i = 0; i &lt; x.length; i++) {
			y.push(new Fraction(x[i]));
		}
		return y;
	}

	// ----------------------
	// gcd, lcm
	// ----------------------
	
	/**
	 * Euclidean algorithm.
	 * - Calculated as an integer.
	 * @param {KFractionInputData} number 
	 * @returns {Fraction} gcd(x, y)
	 */
	gcd(number) {
		const x = this.round().toBigInteger();
		const y = Fraction._toFraction(number).toBigInteger();
		const result = x.gcd(y);
		return new Fraction(result);
	}

	/**
	 * Extended Euclidean algorithm.
	 * - Calculated as an integer.
	 * @param {KFractionInputData} number 
	 * @returns {Array&lt;Fraction&gt;} [a, b, gcd(x, y)], Result of calculating a*x + b*y = gcd(x, y).
	 */
	extgcd(number) {
		const x = this.round().toBigInteger();
		const y = Fraction._toFraction(number).toBigInteger();
		const result = x.extgcd(y);
		return [new Fraction(result[0]), new Fraction(result[1]), new Fraction(result[2])];
	}

	/**
	 * Least common multiple.
	 * - Calculated as an integer.
	 * @param {KFractionInputData} number 
	 * @returns {Fraction} lcm(x, y)
	 */
	lcm(number) {
		const x = this.round().toBigInteger();
		const y = Fraction._toFraction(number).toBigInteger();
		const result = x.lcm(y);
		return new Fraction(result);
	}

	// ----------------------
	// mod
	// ----------------------

	/**
	 * Modular exponentiation.
	 * - Calculated as an integer.
	 * @param {KFractionInputData} exponent
	 * @param {KFractionInputData} m 
	 * @returns {Fraction} A^B mod m
	 */
	modPow(exponent, m) {
		const A = this.round().toBigInteger();
		const B = Fraction._toFraction(exponent).toBigInteger();
		const m_ = Fraction._toFraction(m).toBigInteger();
		const result = A.modPow(B, m_);
		return new Fraction(result);
	}

	/**
	 * Modular multiplicative inverse.
	 * - Calculated as an integer.
	 * @param {KFractionInputData} m
	 * @returns {Fraction} A^(-1) mod m
	 */
	modInverse(m) {
		const A = this.round().toBigInteger();
		const m_ = Fraction._toFraction(m).toBigInteger();
		const result = A.modInverse(m_);
		return new Fraction(result);
	}
	
	// ----------------------
	// &#x7D20;&#x6570;
	// ----------------------
	
	/**
	 * Return true if the value is prime number.
	 * - Calculated as an integer.
	 * - Calculate up to `9007199254740991`.
	 * @returns {boolean} - If the calculation range is exceeded, null is returned.
	 */
	isPrime() {
		const src = this.round().toBigInteger();
		return src.isPrime();
	}
	
	/**
	 * Return true if the value is prime number by Miller-Labin prime number determination method.
	 * 
	 * Attention : it takes a very long time to process.
	 * - Calculated as an integer.
	 * @param {KFractionInputData} [certainty=100] - Repeat count (prime precision).
	 * @returns {boolean}
	 */
	isProbablePrime(certainty) {
		const src = this.round().toBigInteger();
		return src.isProbablePrime(certainty !== undefined ? Fraction._toInteger(certainty) : undefined);
	}

	/**
	 * Next prime.
	 * @param {KFractionInputData} [certainty=100] - Repeat count (prime precision).
	 * @param {KFractionInputData} [search_max=100000] - Search range of next prime.
	 * @returns {Fraction}
	 */
	nextProbablePrime(certainty, search_max) {
		const src = this.round().toBigInteger();
		const p1 = certainty !== undefined ? Fraction._toInteger(certainty) : undefined;
		const p2 = search_max !== undefined ? Fraction._toInteger(search_max) : undefined;
		return new Fraction(src.nextProbablePrime(p1, p2));
	}

	// ----------------------
	// &#x5B9A;&#x6570;
	// ----------------------
	
	/**
	 * -1
	 * @returns {Fraction} -1
	 */
	static get MINUS_ONE() {
		if(DEFINE.MINUS_ONE === null) {
			DEFINE.MINUS_ONE = new Fraction([BigInteger.MINUS_ONE, BigInteger.ONE]);
		}
		return DEFINE.MINUS_ONE;
	}

	/**
	 * 0
	 * @returns {Fraction} 0
	 */
	static get ZERO() {
		if(DEFINE.ZERO === null) {
			DEFINE.ZERO = new Fraction([BigInteger.ZERO, BigInteger.ONE]);
		}
		return DEFINE.ZERO;
	}

	/**
	 * 0.5
	 * @returns {Fraction} 0.5
	 */
	static get HALF() {
		if(DEFINE.HALF === null) {
			DEFINE.HALF = new Fraction([BigInteger.ONE, BigInteger.TWO]);
		}
		return DEFINE.HALF;
	}
	
	/**
	 * 1
	 * @returns {Fraction} 1
	 */
	static get ONE() {
		if(DEFINE.ONE === null) {
			DEFINE.ONE = new Fraction([BigInteger.ONE, BigInteger.ONE]);
		}
		return DEFINE.ONE;
	}
	
	/**
	 * 2
	 * @returns {Fraction} 2
	 */
	static get TWO() {
		if(DEFINE.TWO === null) {
			DEFINE.TWO = new Fraction([BigInteger.TWO, BigInteger.ONE]);
		}
		return DEFINE.TWO;
	}
	
	/**
	 * 10
	 * @returns {Fraction} 10
	 */
	static get TEN() {
		if(DEFINE.TEN === null) {
			DEFINE.TEN = new Fraction([BigInteger.TEN, BigInteger.ONE]);
		}
		return DEFINE.TEN;
	}

	/**
	 * Positive infinity.
	 * @returns {Fraction} Infinity
	 */
	static get POSITIVE_INFINITY() {
		if(DEFINE.POSITIVE_INFINITY === null) {
			DEFINE.POSITIVE_INFINITY = new Fraction(Number.POSITIVE_INFINITY);
		}
		return DEFINE.POSITIVE_INFINITY;
	}
	
	/**
	 * Negative Infinity.
	 * @returns {Fraction} -Infinity
	 */
	static get NEGATIVE_INFINITY() {
		if(DEFINE.NEGATIVE_INFINITY === null) {
			DEFINE.NEGATIVE_INFINITY = new Fraction(Number.NEGATIVE_INFINITY);
		}
		return DEFINE.NEGATIVE_INFINITY;
	}

	/**
	 * Not a Number.
	 * @returns {Fraction} NaN
	 */
	static get NaN() {
		if(DEFINE.NaN === null) {
			DEFINE.NaN = new Fraction(Number.NaN);
		}
		return DEFINE.NaN;
	}
	
	// ----------------------
	// &#x4E92;&#x63DB;&#x6027;
	// ----------------------
	
	/**
	 * The positive or negative sign of this number.
	 * - +1 if positive, -1 if negative, 0 if 0.
	 * @returns {number}
	 */
	signum() {
		return this.sign();
	}

	/**
	 * Subtract.
	 * @param {KFractionInputData} number
	 * @returns {Fraction} A - B
	 */
	subtract(number) {
		return this.sub(number);
	}

	/**
	 * Multiply.
	 * @param {KFractionInputData} number
	 * @returns {Fraction} A * B
	 */
	multiply(number) {
		return this.mul(number);
	}

	/**
	 * Divide.
	 * @param {KFractionInputData} number
	 * @returns {Fraction} fix(A / B)
	 */
	divide(number) {
		return this.div(number);
	}

	/**
	 * Remainder of division.
	 * - Result has same sign as the Dividend.
	 * @param {KFractionInputData} number
	 * @returns {Fraction} A % B
	 */
	remainder(number) {
		return this.rem(number);
	}

}

/**
 * Collection of constant values used in the class.
 * @ignore
 */
const DEFINE = {

	/**
	 * -1
	 * @type {any}
	 */
	MINUS_ONE : null,

	/**
	 * 0
	 * @type {any}
	 */
	ZERO : null,
	
	/**
	 * 1
	 * @type {any}
	 */
	ONE : null,

	/**
	 * 0.5
	 * @type {any}
	 */
	HALF : null,

	/**
	 * 2
	 * @type {any}
	 */
	TWO : null,

	/**
	 * 10
	 * @type {any}
	 */
	TEN : null,
	
	/**
	 * Positive infinity.
	 * @type {any}
	 */
	POSITIVE_INFINITY : null,

	/**
	 * Negative Infinity.
	 * @type {any}
	 */
	NEGATIVE_INFINITY : null,

	/**
	 * Not a Number.
	 * @type {any}
	 */
	NaN : null,

};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
