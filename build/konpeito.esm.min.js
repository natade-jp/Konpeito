/*!
 * konpeito.js (version 6.0.3, 2021/5/25)
 * https://github.com/natade-jp/konpeito
 * Copyright 2013-2021 natade < https://github.com/natade-jp >
 *
 * The MIT license.
 * https://opensource.org/licenses/MIT
 */
class Polyfill{static run(){void 0===Math.imul&&(Math.imul=function(t,n){let i=(65535&t)*(65535&n)>>>0,e=(65535&t)*(n>>>16);return i=i+((65535&e)<<16)>>>0,e=(t>>>16)*(65535&n),4294967295&(i+=(65535&e)<<16)}),void 0===Math.trunc&&(Math.trunc=function(t){return t>0?Math.floor(t):Math.ceil(t)}),void 0===Number.isFinite&&(Number.isFinite=isFinite),void 0===Number.isInteger&&(Number.isInteger=function(t){return isFinite(t)&&Math.trunc(t)===t}),void 0===Number.isNaN&&(Number.isNaN=isNaN),void 0===Number.NaN&&(Number.NaN=NaN),void 0===Number.EPSILON&&(Number.EPSILON=2.220446049250313e-16),void 0===Number.MIN_SAFE_INTEGER&&(Number.MIN_SAFE_INTEGER=-9007199254740991),void 0===!Number.MAX_SAFE_INTEGER&&(Number.MAX_SAFE_INTEGER=9007199254740991),void 0===!Number.parseFloat&&(Number.parseFloat=parseFloat),void 0===!Number.parseInt&&(Number.parseInt=parseInt),void 0===!Number.isSafeInteger&&(Number.isSafeInteger=function(t){return Number.isInteger(t)&&Math.abs(t)<=Number.MAX_SAFE_INTEGER})}}Polyfill.run();class RandomBase{constructor(t){}setSeed(t){}genrand_int32(){return 0}}class MaximumLengthSequence extends RandomBase{constructor(t){super(),this.x=[];for(let t=0;t<521;t++)this.x[t]=0;if(void 0!==t)this.setSeed(t);else{const t=(new Date).getTime()+MaximumLengthSequence.seedUniquifier&4294967295;MaximumLengthSequence.seedUniquifier=MaximumLengthSequence.seedUniquifier+1&4294967295,this.setSeed(t)}}_rnd521(){const t=this.x;for(let n=0;n<32;n++)t[n]^=t[n+489];for(let n=32;n<521;n++)t[n]^=t[n-32]}setSeed(t){let n=0;const i=this.x;let e=t;for(let t=0;t<=16;t++){for(let t=0;t<32;t++)n=(n>>>1)+((e=Math.imul(e,1566083941)+1)<0?2147483648:0);i[t]=n}for(let t=16;t<521;t++)n=16===t?t:t-17,i[t]=i[n]<<23&4294967295^i[t-16]>>>9^i[t-1];for(let t=0;t<4;t++)this._rnd521();this.xi=0,this.haveNextNextGaussian=!1,this.nextNextGaussian=0}genrand_int32(){521===this.xi&&(this._rnd521(),this.xi=0);const t=this.x[this.xi]>>>0;return this.xi=this.xi+1,t}}MaximumLengthSequence.seedUniquifier=2271560481;class Xorshift extends RandomBase{constructor(t){if(super(),this.x=123456789,this.y=362436069,this.z=521288629,this.w=88675123,void 0!==t)this.setSeed(t);else{const t=(new Date).getTime()+Xorshift.seedUniquifier&4294967295;Xorshift.seedUniquifier=Xorshift.seedUniquifier+1&4294967295,this.setSeed(t)}}setSeed(t){let n=t;n=Math.imul(n,214013)+2531011>>>0,this.z=n,n=Math.imul(n,214013)+2531011>>>0,this.w=n,this.haveNextNextGaussian=!1,this.nextNextGaussian=0}genrand_int32(){const t=this.x^this.x<<11;return this.x=this.y,this.y=this.z,this.z=this.w,this.w=this.w^this.w>>>19^t^t>>>8,this.w}}Xorshift.seedUniquifier=2271560481;class Random{constructor(t){let n=void 0,i="fast";this.rand=null,this.haveNextNextGaussian=!1,this.nextNextGaussian=0,"number"==typeof t?n=t:"object"==typeof t&&(void 0!==t.seed&&(n=t.seed),void 0!==t.algorithm&&(i=t.algorithm)),/fast|xorshift/i.test(i)?this.rand=new Xorshift(n):this.rand=new MaximumLengthSequence(n)}static create(t){return new Random(t)}setSeed(t){this.rand.setSeed(t)}genrand_int32(){return this.rand.genrand_int32()}next(t){return 0===t?0:32===t?this.genrand_int32():t<32?this.genrand_int32()>>>32-t:63===t?2147483648*this.genrand_int32()+this.genrand_int32():64===t?4294967296*this.genrand_int32()+this.genrand_int32():t<63?this.genrand_int32()*(1<<t-32)+(this.genrand_int32()>>>64-t):void 0}nextBytes(t){const n=new Array(t);for(let t=0;t<n.length;t++)n[t]=this.next(8);return n}nextInt(t){if(void 0!==t&&"number"==typeof t){let n,i;do{i=(n=this.genrand_int32()>>>0)%t}while(n-i+t>4294967296);return i}return 4294967295&this.next(32)}nextBoolean(){return 0!==this.next(1)}nextDouble(){return(134217728*this.next(26)+this.next(27))/9007199254740992}nextGaussian(){if(this.haveNextNextGaussian)return this.haveNextNextGaussian=!1,this.nextNextGaussian;const t=Math.sqrt(-2*Math.log(this.nextDouble())),n=2*Math.PI*this.nextDouble(),i=t*Math.sin(n);return this.nextNextGaussian=t*Math.cos(n),this.haveNextNextGaussian=!0,i}}class RoundingModeEntity{static toString(){return"NONE"}static getAddNumber(t){return 0}}class RoundingMode_UP extends RoundingModeEntity{static toString(){return"UP"}static getAddNumber(t){const n=t%10;return 0===n?0:n>0?10-n:-(10+n)}}class RoundingMode_DOWN extends RoundingModeEntity{static toString(){return"DOWN"}static getAddNumber(t){return-t%10}}class RoundingMode_CEILING extends RoundingModeEntity{static toString(){return"CEILING"}static getAddNumber(t){const n=t%10;return 0===n?0:n>0?10-n:-n}}class RoundingMode_FLOOR extends RoundingModeEntity{static toString(){return"FLOOR"}static getAddNumber(t){const n=t%10;return 0===n?0:n>0?-n:-(10+n)}}class RoundingMode_HALF_UP extends RoundingModeEntity{static toString(){return"HALF_UP"}static getAddNumber(t){const n=t%10,i=n>=0?1:-1;return Math.abs(n)<5?-1*n:i*(10-Math.abs(n))}}class RoundingMode_HALF_DOWN extends RoundingModeEntity{static toString(){return"HALF_DOWN"}static getAddNumber(t){const n=t%10,i=n>=0?1:-1;return Math.abs(n)<6?-1*n:i*(10-Math.abs(n))}}class RoundingMode_HALF_EVEN extends RoundingModeEntity{static toString(){return"HALF_EVEN"}static getAddNumber(t){let n,i,e=t%100;e<0?(n=-1,i=1&Math.ceil(e/10)):(n=1,i=1&Math.floor(e/10));let r;return r=1===i?5:6,e%=10,Math.abs(e)<r?-1*e:n*(10-Math.abs(e))}}class RoundingMode_UNNECESSARY extends RoundingModeEntity{static toString(){return"UNNECESSARY"}static getAddNumber(t){if(0===t%10)return 0;throw"ArithmeticException"}}class RoundingMode{static valueOf(t){let n;if("string"==typeof t)n=t;else{if(!(t instanceof Object))throw"Unsupported argument "+t;n=t.toString()}const i=[RoundingMode_UP,RoundingMode_DOWN,RoundingMode_FLOOR,RoundingMode_CEILING,RoundingMode_HALF_UP,RoundingMode_HALF_DOWN,RoundingMode_HALF_EVEN,RoundingMode_UNNECESSARY],e=n.toUpperCase();for(let t=0;t<i.length;t++)if(i[t].toString()===e)return i[t];throw"IllegalArgumentException : "+n}static get UP(){return RoundingMode_UP}static get DOWN(){return RoundingMode_DOWN}static get CEILING(){return RoundingMode_CEILING}static get FLOOR(){return RoundingMode_FLOOR}static get HALF_UP(){return RoundingMode_HALF_UP}static get HALF_DOWN(){return RoundingMode_HALF_DOWN}static get HALF_EVEN(){return RoundingMode_HALF_EVEN}static get UNNECESSARY(){return RoundingMode_UNNECESSARY}}class MathContext{constructor(t,n){if(this.precision=0,this.roundingMode=void 0===n?RoundingMode.HALF_UP:n,"number"==typeof t)this.precision=t;else if(t instanceof MathContext)this.roundingMode=void 0===n?t.roundingMode:n,this.precision=t.precision;else if("string"==typeof t){let n;null!==(n=t.match(/precision=\d+/))&&(n=n[0].substring("precision=".length,n[0].length),this.precision=parseInt(n,10)),null!==(n=t.match(/roundingMode=\w+/))&&(n=n[0].substring("roundingMode=".length,n[0].length),this.roundingMode=RoundingMode.valueOf(n))}if(this.precision<0)throw"IllegalArgumentException"}static create(t,n){return t instanceof MathContext?t:new MathContext(t,n)}getPrecision(){return this.precision}getRoundingMode(){return this.roundingMode}equals(t){return t instanceof MathContext&&t.toString()===this.toString()}toString(){return"precision="+this.precision+" roundingMode="+this.roundingMode.toString()}increasePrecision(t){if(0===this.precision)return this;const n=this.precision+(void 0===t?1:t);return new MathContext(Math.max(1,n),this.roundingMode)}decreasePrecision(t){if(0===this.precision)return this;const n=this.precision-(void 0===t?1:t);return new MathContext(Math.max(1,n),this.roundingMode)}static get UNLIMITED(){return DEFINE.UNLIMITED}static get DECIMAL32(){return DEFINE.DECIMAL32}static get DECIMAL64(){return DEFINE.DECIMAL64}static get DECIMAL128(){return DEFINE.DECIMAL128}static get DECIMAL256(){return DEFINE.DECIMAL256}}const DEFINE={UNLIMITED:new MathContext(0,RoundingMode.HALF_UP),DECIMAL32:new MathContext(7,RoundingMode.HALF_EVEN),DECIMAL64:new MathContext(16,RoundingMode.HALF_EVEN),DECIMAL128:new MathContext(34,RoundingMode.HALF_EVEN),DECIMAL256:new MathContext(72,RoundingMode.HALF_EVEN)},isInteger=function(t){return t-Math.trunc(t)!=0};class Probability{static gammaln(t){if(!isFinite(t))return isNaN(t)?NaN:1/0;const n=Math.log(2*Math.PI),i=[-15238221.539407417,691472.268851313,-36108.77125372499,8553103/6/650,-156.84828462600203,854513/138/462,-174611/330/380,43867/798/306,-3617/510/240,7/6/182,-691/2730/132,5/66/90,-1/30/56,1/42/30,-1/30/12,1/6/2];let e=1,r=t;for(;r<i.length;)e*=r,r++;const o=1/(r*r);let a=i[0];for(let t=1;t<i.length;t++)a*=o,a+=i[t];return a/=r,a+=.5*n,a+=-Math.log(e)-r+(r-.5)*Math.log(r)}static q_gamma(t,n,i){if(!isFinite(t))return t===1/0?0:NaN;let e,r,o,a,s,u=1,c=1+t-n;if(t<1+n)return 1-Probability.p_gamma(t,n,i);for(r=(o=Math.exp(n*Math.log(t)-t-i))/c,e=2;e<1e3;e++)if(a=((e-1-n)*(c-u)+(e+t)*c)/e,u=c,c=a,o*=(e-1-n)/e,a=o/(u*c),s=r,(r+=a)==s)return r;return Number.NaN}static p_gamma(t,n,i){if(!isFinite(t))return t===1/0?1:NaN;let e,r,o,a;if(t>=1+n)return 1-Probability.q_gamma(t,n,i);if(0===t)return 0;for(r=o=Math.exp(n*Math.log(t)-t-i)/n,e=1;e<1e3;e++)if(o*=t/(n+e),a=r,(r+=o)==a)return r;return Number.NaN}static gamma(t){return t<0?Math.PI/(Math.sin(Math.PI*t)*Math.exp(Probability.gammaln(1-t))):Math.exp(Probability.gammaln(t))}static gammainc(t,n,i){if("lower"===i)return Probability.p_gamma(t,n,Probability.gammaln(n));if("upper"===i)return Probability.q_gamma(t,n,Probability.gammaln(n));if(void 0===i)return Probability.gammainc(t,n,"lower");throw"gammainc unsupported argument ["+i+"]"}static gampdf(t,n,i){if(t===-1/0)return 0;let e=1/(Probability.gamma(n)*Math.pow(i,n));return e*=Math.pow(t,n-1),e*=Math.exp(-t/i)}static gamcdf(t,n,i){return t<0?0:Probability.gammainc(t/i,n)}static gaminv(t,n,i){if(t<0||t>1)return Number.NaN;if(0==t)return 0;if(1==t)return Number.POSITIVE_INFINITY;let e,r,o=n*i;for(let a=0;a<100&&(r=o-(Probability.gamcdf(o,n,i)-t)/Probability.gampdf(o,n,i),e=r-o,!(Math.abs(e)<=1e-12));a++)(o=r)<0&&(o=1e-12);return o}static beta(t,n){return Math.exp(Probability.gammaln(t)+Probability.gammaln(n)-Probability.gammaln(t+n))}static p_beta(t,n,i){let e,r,o,a;if(n<=0)return Number.POSITIVE_INFINITY;if(i<=0)return t<1?0:1===t?1:Number.POSITIVE_INFINITY;if(t>(n+1)/(n+i+2))return 1-Probability.p_beta(1-t,i,n);if(t<=0)return 0;for(o=n*Math.log(t),o+=i*Math.log(1-t),o+=Probability.gammaln(n+i),o-=Probability.gammaln(n)+Probability.gammaln(i),o=Math.exp(o),r=o/=n,e=1;e<1e3;e++)if(o*=n+i+e-1,o*=t,o/=n+e,a=r,(r+=o)===a)return r;return Number.NaN}static q_beta(t,n,i){return 1-Probability.p_beta(t,n,i)}static betainc(t,n,i,e){if("lower"===e)return Probability.p_beta(t,n,i);if("upper"===e)return Probability.q_beta(t,n,i);if(void 0===e)return Probability.betainc(t,n,i,"lower");throw"betainc unsupported argument ["+e+"]"}static betapdf(t,n,i){return t<0&&isInteger(i-1)||1-t<0&&isInteger(i-1)?0:Math.pow(t,n-1)*Math.pow(1-t,i-1)/Probability.beta(n,i)}static betacdf(t,n,i){return Probability.betainc(t,n,i)}static betainv(t,n,i){if(t<0||t>1)return Number.NaN;if(0==t&&n>0&&i>0)return 0;if(1==t&&n>0&&i>0)return 1;let e;e=0==i?1-1e-14:0==n?1e-14:n/(n+i);let r,o;for(let a=0;a<100&&(o=e-(Probability.betacdf(e,n,i)-t)/Probability.betapdf(e,n,i),r=o-e,!(Math.abs(r)<=1e-14));a++)(e=o)>1?e=1-1e-14:e<0&&(e=1e-14);return e}static factorial(t){const n=Probability.gamma(t+1);return Math.trunc(t)===t?Math.round(n):n}static nchoosek(t,n){let i=1;const e=Math.min(n,t-n);for(let n=1;n<=e;n++)if((i*=(t+1-n)/n)>=Number.MAX_SAFE_INTEGER)return 1/0;return i}static erf(t){return Probability.p_gamma(t*t,.5,.5*Math.log(Math.PI))*(t>=0?1:-1)}static erfc(t){return 1-Probability.erf(t)}static erfinv(t){return Probability.erfcinv(1-t)}static erfcinv(t){return-Probability.norminv(.5*t)/Math.sqrt(2)}static normpdf(t,n,i){const e="number"==typeof n?n:0,r="number"==typeof i?i:1;let o=1/Math.sqrt(2*Math.PI*r*r);return o*=Math.exp(-(t-e)*(t-e)/(2*r*r))}static normcdf(t,n,i){const e="number"==typeof n?n:0,r="number"==typeof i?i:1;return(1+Probability.erf((t-e)/(r*Math.sqrt(2))))/2}static norminv(t,n,i){if(t<0||t>1)return Number.NaN;if(0==t)return Number.NEGATIVE_INFINITY;if(1==t)return Number.POSITIVE_INFINITY;const e="number"==typeof n?n:0,r="number"==typeof i?i:1;let o,a,s=e;for(let n=0;n<200&&(a=s-(Probability.normcdf(s,e,r)-t)/Probability.normpdf(s,e,r),o=a-s,!(Math.abs(o)<=1e-12));n++)s=a;return s}static binopdf(t,n,i){return isFinite(i)?Probability.nchoosek(n,t)*Math.pow(i,t)*Math.pow(1-i,n-t):isNaN(i)?NaN:0}static binocdf(t,n,i,e){return Probability.betainc(1-i,n-Math.floor(t),1+Math.floor(t),e)}static binoinv(t,n,i){if(t<0||1<t||i<0||1<i)return Number.NaN;if(0==t||0==i)return 0;if(1==i)return n;let e=1,r=n,o=0,a=0;for(let s=0;s<200;s++){o=Math.round((e+r)/2);const s=Probability.binocdf(o,n,i);if(o===a)break;s>t?r=o:e=o,a=o}return o}static poisspdf(t,n){if(!isFinite(t))return isNaN(t)?Number.NaN:0;const i=1/Math.E;let e=1,r=0;for(let o=1;o<=t;o++)e=e*n/o,r<n&&(e*=i,r++);for(;r<n;r++)e*=i;return e}static poisscdf(t,n){return t<0?0:1-Probability.gammainc(n,Math.floor(t+1))}static poissinv(t,n){if(t<0||1<t)return Number.NaN;if(0==t)return 0;if(1==t)return Number.POSITIVE_INFINITY;let i=1,e=20*n,r=0,o=0;for(let a=0;a<200;a++){r=Math.round((i+e)/2);const a=Probability.poisscdf(r,n);if(r===o)break;a>t?e=r:i=r,o=r}return r}static tpdf(t,n){let i=1/(Math.sqrt(n)*Probability.beta(.5,.5*n));return i*=Math.pow(1+t*t/n,.5*-(n+1))}static tcdf(t,n){const i=t*t/(n+t*t);return.5*(1+Probability.betainc(i,.5,.5*n)*(t<0?-1:1))}static tinv(t,n){if(t<0||t>1)return Number.NaN;if(0==t)return Number.NEGATIVE_INFINITY;if(1==t)return Number.POSITIVE_INFINITY;if(t<.5){const i=Probability.betainv(2*t,.5*n,.5);return-Math.sqrt(n/i-n)}{const i=Probability.betainv(2*(1-t),.5*n,.5);return Math.sqrt(n/i-n)}}static tdist(t,n,i){return(1-Probability.tcdf(Math.abs(t),n))*i}static tinv2(t,n){return-Probability.tinv(.5*t,n)}static chi2pdf(t,n){if(t<0)return 0;if(0===t)return.5;let i=Math.pow(t,n/2-1)*Math.exp(-t/2);return i/=Math.pow(2,n/2)*Probability.gamma(n/2)}static chi2cdf(t,n){return Probability.gammainc(t/2,n/2)}static chi2inv(t,n){return Probability.gaminv(t,n/2,2)}static fpdf(t,n,i){if(n<0||i<0)return Number.NaN;if(t<=0)return 0;let e=1;return e*=Math.pow(n*t/(n*t+i),n/2),e*=Math.pow(1-n*t/(n*t+i),i/2),e/=t*Probability.beta(n/2,i/2)}static fcdf(t,n,i){return Probability.betacdf(n*t/(n*t+i),n/2,i/2)}static finv(t,n,i){return(1/Probability.betainv(1-t,i/2,n/2)-1)*i/n}}class LinearAlgebraTool{static tridiagonalize(t){const n=Matrix._toMatrix(t).getNumberMatrixArray(),i=function(t,n,i,e){let r=0;const o=i||0,a=e||t.length;for(let i=o;i<a;i++)r+=t[i]*n[i];return r},e=n.length,r=[],o=[];for(let t=0;t<e-2;t++){const a=n[t];r[t]=a[t];{const n=function(t,n,e){const r=n||0,o=e||t.length;let a=Math.sqrt(i(t,t,r,o));const s=[];if(Math.abs(a)>=1e-10){t[r]<0&&(a=-a);let n;for(let i=r,e=0;i<o;i++,e++)i===r?(s[e]=t[i]+a,n=1/Math.sqrt(s[e]*a),s[e]=s[e]*n):s[e]=t[i]*n}return{y1:-a,v:s}}(a,t+1,e);o[t]=n.y1;for(let i=0;i<n.v.length;i++)a[t+1+i]=n.v[i]}if(!(Math.abs(o[t])<1e-10)){for(let i=t+1;i<e;i++){let o=0;for(let e=t+1;e<i;e++)o+=n[e][i]*a[e];for(let t=i;t<e;t++)o+=n[i][t]*a[t];r[i]=o}const o=i(a,r,t+1,e)/2;for(let i=e-1;i>t;i--){const t=a[i],s=r[i]-o*t;r[i]=s;for(let o=i;o<e;o++){const e=t*r[o]+s*a[o];n[i][o]=n[i][o]-e}}}}e>=2&&(r[e-2]=n[e-2][e-2],o[e-2]=n[e-2][e-1]),e>=1&&(r[e-1]=n[e-1][e-1]);for(let t=e-1;t>=0;t--){const r=n[t];if(t<e-2)for(let o=t+1;o<e;o++){const a=n[o],s=i(r,a,t+1,e);for(let n=t+1;n<e;n++)a[n]-=s*r[n]}for(let t=0;t<e;t++)r[t]=0;r[t]=1}const a=Matrix.createMatrixDoEachCalculation(function(t,n){return t===n?new Complex(r[t]):1===Math.abs(t-n)?new Complex(o[Math.trunc(.5*(t+n))]):Complex.ZERO},e,e);return{P:new Matrix(n).T(),H:a}}static eig(t){const n=Matrix._toMatrix(t);let i=!1;const e=LinearAlgebraTool.tridiagonalize(n),r=e.P.getNumberMatrixArray(),o=e.H.getNumberMatrixArray(),a=n.row_length,s=[],u=[];for(let t=0;t<a;t++)s[t]=o[t][t],u[t]=0===t?0:o[t][t-1];for(let t=a-1;t>0;t--){let n=t;for(n=t;n>=1&&!(Math.abs(u[n])<=1e-10*(Math.abs(s[n-1])+Math.abs(s[n])));n--);if(n!=t){let e=0;for(;;){if(++e>100){i=!0;break}let o=(s[t-1]-s[t])/2,c=u[t]*u[t],l=Math.sqrt(o*o+c);o<0&&(l=-l);let h=s[n]-s[t]+c/(o+l),g=u[n+1];for(let i=n;i<t;i++){let e,l;Math.abs(h)>=Math.abs(g)?l=(c=-g/h)*(e=1/Math.sqrt(c*c+1)):e=(c=-h/g)*(l=1/Math.sqrt(c*c+1)),c=((o=s[i]-s[i+1])*l+2*e*u[i+1])*l,s[i]-=c,s[i+1]+=c,i>n&&(u[i]=e*u[i]-l*g),u[i+1]+=l*(e*o-2*l*u[i+1]);for(let t=0;t<a;t++)h=r[t][i],g=r[t][i+1],r[t][i]=e*h-l*g,r[t][i+1]=l*h+e*g;i<t-1&&(h=u[i+1],g=-l*u[i+2],u[i+2]*=e)}if(Math.abs(u[t])<=1e-10*(Math.abs(s[t-1])+Math.abs(s[t])))break}if(i)break}}return function(t,n){const i=n.length,e=[];for(let t=0;t<i;t++)e[t]={sigma:n[t],index:t};const r=function(t,n){return t.sigma===n.sigma?0:t.sigma<n.sigma?1:-1};e.sort(r);const o=Matrix.zeros(i),a=Matrix.zeros(i);for(let t=0;t<i;t++)a.matrix_array[t][t]=new Complex(e[t].sigma),o.matrix_array[t][e[t].index]=Complex.ONE;return{V:t.mul(o),D:a}}(new Matrix(r),s)}static doGramSchmidtOrthonormalization(t){const n=Matrix._toMatrix(t),i=n.column_length,e=n.matrix_array,r=Matrix.zeros(i),o=Matrix.zeros(i),a=r.matrix_array,s=o.matrix_array,u=[],c=new Array(i);for(let t=0;t<i;t++){for(let n=0;n<i;n++)c[n]=e[n][t];if(t>0){for(let n=0;n<t;n++)for(let r=0;r<i;r++)s[n][t]=s[n][t].add(e[r][t].dot(a[r][n]));for(let n=0;n<t;n++)for(let e=0;e<i;e++)c[e]=c[e].sub(s[n][t].mul(a[e][n]))}for(let n=0;n<i;n++)s[t][t]=s[t][t].add(c[n].square());if(s[t][t]=s[t][t].sqrt(),s[t][t].isZero(1e-10)){u.push(t);for(let n=0;n<i;n++)a[n][t]=Complex.ZERO}else for(let n=0;n<i;n++)a[n][t]=c[n].div(s[t][t])}return{Q:r,R:o,non_orthogonalized:u}}static createOrthogonalVector(t,n){const i=new Matrix(t),e=i.column_length,r=i.matrix_array,o=n||1e-10,a=LinearAlgebraTool.getLinearDependenceVector(i,o);for(let t=a.length-1;t>=0;t--)r.splice(a[t],1),i.row_length--;const s=e-r.length;if(s<=0)return null;const u=new Random(0);let c=null;for(let t=0;t<100;t++){const t=i.T(),n=Matrix.createMatrixDoEachCalculation(function(){return new Complex(u.nextGaussian())},t.row_length,s);if(t._concatRight(n),0===(c=LinearAlgebraTool.doGramSchmidtOrthonormalization(t)).non_orthogonalized.length)break}if(0!==c.non_orthogonalized.length)return console.log("miss"),null;const l=new Array(s),h=c.Q.matrix_array;for(let t=0;t<s;t++){l[t]=new Array(e);for(let n=0;n<e;n++)l[t][n]=h[n][e-s+t]}return new Matrix(l)}static getMaxRowNumber(t,n,i,e){const r=Matrix._toMatrix(t);let o=0,a=0,s=i||0;const u=e||r.row_length;for(;s<u;s++){const t=r.matrix_array[s][n].norm;t>a&&(a=t,o=s)}return{index:o,max:a}}static getLinearDependenceVector(t,n){const i=new Matrix(t),e=i.matrix_array,r=n?Matrix._toDouble(n):1e-10,o=new Array(i.row_length);for(let t=0;t<i.row_length;t++)o[t]=t;for(let t=0;t<i.column_length;t++){let n=0;{let a=0,s=0;for(const i in o){const r=o[i],u=e[r][t].norm;u>a&&(a=u,s=parseInt(i,10),n=r)}if(a<=r)continue;if(o.splice(s,1),t===i.column_length-1)break}for(const r in o){const a=o[r],s=e[a][t].div(e[n][t]);for(let r=t;r<i.column_length;r++)e[a][r]=e[a][r].sub(e[n][r].mul(s))}}return o}}class LinearAlgebra{static inner(t,n,i){const e=Matrix._toMatrix(t),r=Matrix._toMatrix(n),o=e.matrix_array,a=r.matrix_array,s=i?Matrix._toInteger(i):1;if(e.isScalar()&&r.isScalar())return new Matrix(e.scalar.dot(r.scalar));if(e.isVector()&&r.isVector()){let t=Complex.ZERO;for(let n=0;n<e.length;n++)t=t.add(e.getComplex(n).dot(r.getComplex(n)));return new Matrix(t)}if(e.row_length!==r.row_length||e.column_length!==r.column_length)throw"Matrix size does not match";if(1===s){const t=new Array(1);t[0]=new Array(e.column_length);for(let n=0;n<e.column_length;n++){let i=Complex.ZERO;for(let t=0;t<e.row_length;t++)i=i.add(o[t][n].dot(a[t][n]));t[0][n]=i}return new Matrix(t)}if(2===s){const t=new Array(e.row_length);for(let n=0;n<e.row_length;n++){let i=Complex.ZERO;for(let t=0;t<e.column_length;t++)i=i.add(o[n][t].dot(a[n][t]));t[n]=[i]}return new Matrix(t)}throw"dim"}static norm(t,n){const i=Matrix._toMatrix(t),e=void 0===n?2:Matrix._toDouble(n);if(1===e){const t=i.matrix_array;if(i.isRow()){let n=0;for(let e=0;e<i.column_length;e++)n+=t[0][e].norm;return n}if(i.isColumn()){let n=0;for(let e=0;e<i.row_length;e++)n+=t[e][0].norm;return n}let n=0;for(let e=0;e<i.column_length;e++){let r=0;for(let n=0;n<i.row_length;n++)r+=t[n][e].norm;n<r&&(n=r)}return n}if(2===e){const t=i.matrix_array;if(i.isRow()){let n=0;for(let e=0;e<i.column_length;e++)n+=t[0][e].square().real;return Math.sqrt(n)}if(i.isColumn()){let n=0;for(let e=0;e<i.row_length;e++)n+=t[e][0].square().real;return Math.sqrt(n)}return i.svd().S.diag().max().scalar.real}if(e===Number.POSITIVE_INFINITY||e===Number.NEGATIVE_INFINITY){const t=i.matrix_array;let n=e===Number.POSITIVE_INFINITY?0:Number.POSITIVE_INFINITY;const r=e===Number.POSITIVE_INFINITY?Math.max:Math.min;if(i.isRow()){for(let e=0;e<i.column_length;e++)n=r(n,t[0][e].norm);return n}if(i.isColumn()){for(let e=0;e<i.row_length;e++)n=r(n,t[e][0].norm);return n}n=0;for(let e=0;e<i.row_length;e++){let r=0;for(let n=0;n<i.column_length;n++)r+=t[e][n].norm;n=Math.max(n,r)}return n}if(i.isVector()){let t=0;for(let n=0;n<i.length;n++)t+=Math.pow(i.getComplex(n).norm,e);return Math.pow(t,1/e)}throw"norm"}static cond(t,n){const i=Matrix._toMatrix(t);if(2===(void 0===n?2:Matrix._toInteger(n))){if(i.isZeros())return Number.POSITIVE_INFINITY;if(i.isVector())return 1;if(i.isUnitary())return 1;const t=i.svd().S.diag();return t.max().scalar.real/t.min().scalar.real}return i.norm(n)*i.pinv().norm(n)}static rcond(t){return 1/LinearAlgebra.cond(Matrix._toMatrix(t),1)}static rank(t,n){const i=Matrix._toMatrix(t),e=void 0!==n?Matrix._toDouble(n):void 0;return i.row_length<=i.column_length?Math.min(i.row_length,i.column_length)-LinearAlgebraTool.getLinearDependenceVector(i,e).length:i.row_length-LinearAlgebraTool.getLinearDependenceVector(i,e).length}static trace(t){const n=Matrix._toMatrix(t),i=Math.min(n.row_length,n.column_length);let e=Complex.ZERO;for(let t=0;t<i;t++)e=e.add(n.matrix_array[t][t]);return e}static det(t){const n=Matrix._toMatrix(t);if(!n.isSquare())throw"not square";const i=n.length;if(i<5){const t=function(n){if(2===n.length)return n[0][0].mul(n[1][1]).sub(n[0][1].mul(n[1][0]));let i=Complex.ZERO;for(let e=0;e<n.length;e++){const r=[],o=n[e][0];for(let t=0,i=0;t<n.length;t++)if(e!==t){r[i]=[];for(let e=1,o=0;e<n.length;e++,o++)r[i][o]=n[t][e];i++}i=e%2==0?i.add(o.mul(t(r))):i.sub(o.mul(t(r)))}return i};return new Matrix(t(n.matrix_array))}{const t=LinearAlgebra.lup(n),e=(i-t.P.diag().sum().scalar.real)/2;let r=t.U.diag().prod();return e%2==1&&(r=r.negate()),new Matrix(r)}}static lup(t){const n=new Matrix(t),i=Matrix.zeros(n.row_length),e=n,r=Matrix.eye(n.row_length),o=i.matrix_array,a=e.matrix_array;for(let t=0;t<n.column_length;t++){let s;{const n=LinearAlgebraTool.getMaxRowNumber(e,t,t);if(s=n.index,0===n.max)continue;t!==s&&(i._exchangeRow(t,s),e._exchangeRow(t,s),r._exchangeRow(t,s))}for(let i=t+1;i<n.row_length;i++){const e=a[i][t].div(a[t][t]);o[i][t]=e;for(let r=t;r<n.column_length;r++)a[i][r]=a[i][r].sub(a[t][r].mul(e))}}return i._resize(n.row_length,Math.min(n.row_length,n.column_length)),e._resize(Math.min(n.row_length,n.column_length),n.column_length),i._each(function(t,n,i){return n===i?Complex.ONE:t}),{L:i,U:e,P:r}}static lu(t){const n=LinearAlgebra.lup(t);return{L:n.P.T().mul(n.L),U:n.U}}static linsolve(t,n){const i=Matrix._toMatrix(t),e=Matrix._toMatrix(n);if(!i.isSquare())throw"Matrix size does not match";const r=e;if(e.row_length!==i.row_length||e.column_length>1)throw"Matrix size does not match";const o=new Matrix(i);o._concatRight(r);const a=o.matrix_array,s=o.column_length,u=i.column_length;for(let t=0;t<u-1;t++){{const n=LinearAlgebraTool.getMaxRowNumber(o,t,t).index;o._exchangeRow(t,n)}{const n=a[t][t].inv();for(let i=t,e=t;e<s;e++)a[i][e]=a[i][e].mul(n)}for(let n=t+1;n<u;n++){const i=a[n][t];for(let e=t;e<s;e++)a[n][e]=a[n][e].sub(a[t][e].mul(i))}}const c=new Array(u);c[u-1]=a[u-1][u].div(a[u-1][u-1]);for(let t=u-2;t>=0;t--){c[t]=a[t][s-1];for(let n=t+1;n<u;n++)c[t]=c[t].sub(a[t][n].mul(c[n]));c[t]=c[t].div(a[t][t])}const l=new Array(i.row_length);for(let t=0;t<i.row_length;t++)l[t]=[c[t]];return new Matrix(l)}static qr(t){const n=new Matrix(t),i=n.row_length,e=n.row_length,r=n.row_length,o=n.column_length,a=Math.max(n.row_length,n.column_length);n._resize(a,a);const s=LinearAlgebraTool.doGramSchmidtOrthonormalization(n);let u=s.Q;const c=s.R,l=s.non_orthogonalized;if(l.length===n.row_length)u=Matrix.eye(n.row_length);else if(0!==l.length){const t={};for(let n=0;n<l.length;n++)t[l[n]]=1;const n=[];for(let i=0;i<a;i++)if(!t[i]){const t=[];for(let n=0;n<a;n++)t[n]=u.matrix_array[n][i];n.push(t)}const i=LinearAlgebraTool.createOrthogonalVector(n);for(let t=0;t<l.length;t++){const n=l[t];for(let e=0;e<a;e++)u.matrix_array[e][n]=i.matrix_array[t][e]}}return u._resize(i,e),c._resize(r,o),{Q:u,R:c}}static tridiagonalize(t){const n=new Matrix(t);if(!n.isSquare())throw"not square matrix";if(!n.isSymmetric())throw"not Symmetric";if(n.isComplex())throw"not Real Matrix";return LinearAlgebraTool.tridiagonalize(n)}static eig(t){const n=new Matrix(t);if(!n.isSquare())throw"not square matrix";if(!n.isSymmetric())throw"not Symmetric";if(n.isComplex())throw"not Real Matrix";return LinearAlgebraTool.eig(n)}static svd(t){const n=new Matrix(t);if(n.isComplex())throw"Unimplemented";const i=LinearAlgebra.rank(n),e=LinearAlgebra.eig(n.T().mul(n)),r=Matrix.zeros(n.row_length,n.column_length);r._each(function(t,n,r){if(n===r&&n<i)return e.D.getComplex(n,n).sqrt()});const o=Math.min(n.row_length,n.column_length),a=Matrix.createMatrixDoEachCalculation(function(t,n){if(t===n){const n=r.matrix_array[t][t];return n.isZero()?Complex.ZERO:n.inv()}return Complex.ZERO},o),s=e.V.resize(e.V.row_length,o),u=n.mul(s).mul(a);return{U:LinearAlgebra.qr(u).Q,S:r,V:e.V}}static inv(t){const n=new Matrix(t);if(n.isScalar())return new Matrix(Complex.ONE.div(n.scalar));if(!n.isSquare())throw"not square";if(n.isDiagonal()){const t=n.T(),i=Math.min(t.row_length,t.column_length);for(let n=0;n<i;n++)t.matrix_array[n][n]=t.matrix_array[n][n].inv();return t}const i=n.column_length,e=new Matrix(n);e._concatRight(Matrix.eye(i));const r=e.matrix_array,o=e.column_length;for(let t=0;t<i;t++){{const n=LinearAlgebraTool.getMaxRowNumber(e,t,t).index;e._exchangeRow(t,n)}{const n=r[t][t].inv();for(let i=t,e=t;e<o;e++)r[i][e]=r[i][e].mul(n)}for(let n=0;n<i;n++)if(n!==t){const i=r[n][t];for(let e=t;e<o;e++)r[n][e]=r[n][e].sub(r[t][e].mul(i))}}const a=new Array(i);for(let t=0;t<i;t++){a[t]=new Array(i);for(let n=0;n<i;n++)a[t][n]=r[t][i+n]}return new Matrix(a)}static pinv(t){const n=new Matrix(t),i=LinearAlgebra.svd(n),e=i.U,r=i.S,o=i.V,a=Matrix.createMatrixDoEachCalculation(function(t,n){if(t===n){const n=r.matrix_array[t][t];return n.isZero()?Complex.ZERO:n.inv()}return Complex.ZERO},n.column_length,n.row_length);return o.mul(a).mul(e.T())}}class Statistics{static max(t,n){const i=Matrix._toMatrix(t),e=n&&n.dimension?n.dimension:"auto",r=function(t){let n=t[0];for(let i=1;i<t.length;i++)n.compareTo(t[i])<0&&(n=t[i]);return[n]};return i.eachVector(r,e)}static min(t,n){const i=Matrix._toMatrix(t),e=n&&n.dimension?n.dimension:"auto",r=function(t){let n=t[0];for(let i=1;i<t.length;i++)n.compareTo(t[i])>0&&(n=t[i]);return[n]};return i.eachVector(r,e)}static sum(t,n){const i=Matrix._toMatrix(t),e=n&&n.dimension?n.dimension:"auto",r=function(t){let n=Complex.ZERO,i=Complex.ZERO;for(let e=0;e<t.length;e++){const r=t[e].add(i),o=n.add(r);i=o.sub(n).sub(r),n=o}return[n]};return i.eachVector(r,e)}static mean(t,n){const i=Matrix._toMatrix(t),e=n&&n.dimension?n.dimension:"auto",r=function(t){let n=Complex.ZERO,i=Complex.ZERO;for(let e=0;e<t.length;e++){const r=t[e].add(i),o=n.add(r);i=o.sub(n).sub(r),n=o}return[n.div(t.length)]};return i.eachVector(r,e)}static prod(t,n){const i=Matrix._toMatrix(t),e=n&&n.dimension?n.dimension:"auto",r=function(t){let n=Complex.ONE;for(let i=0;i<t.length;i++)n=n.mul(t[i]);return[n]};return i.eachVector(r,e)}static geomean(t,n){const i=Matrix._toMatrix(t),e=n&&n.dimension?n.dimension:"auto",r=function(t){let n=Complex.ONE;for(let i=0;i<t.length;i++)n=n.mul(t[i]);return[n.pow(Complex.create(t.length).inv())]};return i.eachVector(r,e)}static median(t,n){const i=Matrix._toMatrix(t),e=n&&n.dimension?n.dimension:"auto",r=function(t,n){return t.compareTo(n)},o=function(t){t.sort(r);let n;if(t.length%2==1)n=t[Math.floor(t.length/2)];else{const i=t[Math.floor(t.length/2)-1],e=t[Math.floor(t.length/2)];n=i.add(e).div(Complex.TWO)}return[n]};return i.eachVector(o,e)}static mode(t,n){const i=Matrix._toMatrix(t),e=n&&n.dimension?n.dimension:"auto",r=function(t,n){return t.compareTo(n)},o=function(t){t.sort(r);const n={};for(let i=0;i<t.length;i++){const e=t[i].real+" "+t[i].imag;n[e]?n[e].value++:n[e]={complex:t[i],value:1}}let i=Complex.ZERO,e=Number.NEGATIVE_INFINITY;for(const t in n){const r=n[t];r.value>e&&(e=r.value,i=r.complex)}return[i]};return i.eachVector(o,e)}static moment(t,n,i){const e=Matrix._toMatrix(t),r=Statistics.mean(e),o=i&&"number"==typeof i.correction?Matrix._toDouble(i.correction):1,a=i&&i.dimension?i.dimension:"auto",s=Matrix._toComplex(n);let u=0;const c=function(t){let n;n=r.isScalar()?r.scalar:r.getComplex(u++);let i=Complex.ZERO;for(let e=0;e<t.length;e++){const r=t[e].sub(n);i=i.add(r.pow(s))}return 1===t.length?[i.div(t.length)]:[i.div(t.length-1+o)]};return e.eachVector(c,a)}static var(t,n){const i=Matrix._toMatrix(t),e=Statistics.mean(i),r=n&&"number"==typeof n.correction?Matrix._toDouble(n.correction):0,o=n&&n.dimension?n.dimension:"auto";let a=0;const s=function(t){if(1===t.length)return[Complex.ZERO];const n=e.getComplex(a++);let i=0;for(let e=0;e<t.length;e++){const r=t[e].sub(n).norm;i+=r*r}return[Complex.create(i/(t.length-1+r))]};return i.eachVector(s,o)}static std(t,n){const i=Matrix._toMatrix(t),e=n&&"number"==typeof n.correction?Matrix._toDouble(n.correction):0,r=n&&n.dimension?n.dimension:"auto",o=Statistics.var(i,{correction:e,dimension:r});return o._each(function(t){return t.sqrt()}),o}static mad(t,n,i){const e=Matrix._toMatrix(t),r=n?"string"==typeof n?n:Matrix._toInteger(n):"mean",o=i&&i.dimension?i.dimension:"auto";if("mean"===r||0===r)return Statistics.mean(e.sub(Statistics.mean(e,{dimension:o})).abs(),{dimension:o});if("median"===r||1===r)return Statistics.median(e.sub(Statistics.median(e,{dimension:o})).abs(),{dimension:o});throw"mad unsupported argument "+r}static skewness(t,n){const i=Matrix._toMatrix(t),e=n&&"number"==typeof n.correction?Matrix._toDouble(n.correction):1,r=n&&n.dimension?n.dimension:"auto",o=Statistics.moment(i,3,{correction:e,dimension:r}),a=Statistics.std(i,{correction:e,dimension:r});return 1===e?o.dotdiv(a.dotpow(3)):o.dotdiv(a.dotpow(3)).dotmul(2)}static cov(t,n,i){const e=Matrix._toMatrix(t);let r=0,o=null;if(void 0!==n&&(void 0!==i?(r=i&&"number"==typeof i.correction?Matrix._toDouble(i.correction):0,o=Matrix._toMatrix(n)):"object"==typeof n&&"correction"in n?r=Matrix._toDouble(n.correction):o=Matrix._toMatrix(n)),null===o){if(e.isVector())return Statistics.var(e,{correction:r});const t=1===e.row_length?1:r,n=e.matrix_array,i=Statistics.mean(e).matrix_array[0],o=new Array(e.column_length);for(let r=0;r<e.column_length;r++){const a=i[r];o[r]=new Array(e.column_length);for(let s=r;s<e.column_length;s++){const u=i[s];let c=Complex.ZERO;for(let t=0;t<e.row_length;t++)c=c.add(n[t][r].sub(a).dot(n[t][s].sub(u)));o[r][s]=c.div(e.row_length-1+t)}}for(let t=1;t<o[0].length;t++)for(let n=0;n<t;n++)o[t][n]=o[n][t];return new Matrix(o)}{if(!e.isVector()&&!o.isVector())throw"vector not specified";if(e.length!==o.length)throw"X.length !== Y.length";const t=Statistics.mean(e).scalar,n=Statistics.mean(o).scalar,i=e.length,a=1===i?1:r;let s=Complex.ZERO;for(let r=0;r<i;r++)s=s.add(e.getComplex(r).sub(t).dot(o.getComplex(r).sub(n)));return new Matrix(s.div(i-1+a))}}static standardization(t,n){const i=Matrix._toMatrix(t),e=i.sub(Statistics.mean(i,n));return e.dotdiv(Statistics.std(e,n))}static corrcoef(t,n,i){const e=Matrix._toMatrix(t);let r=null;if(void 0!==n&&(void 0!==i?r=Matrix._toMatrix(n):"object"==typeof n&&"correction"in n||(r=Matrix._toMatrix(n))),null===r)return Statistics.cov(Statistics.standardization(e,i),i);{if(!e.isVector()&&!r.isVector())throw"vector not specified";if(e.length!==r.length)throw"X.length["+e.length+"] !== Y.length["+r.length+"]";const t=Statistics.cov(e,r,i),n=e.std(i),o=r.std(i);return t.div(n.mul(o))}}static sort(t,n,i){const e=Matrix._toMatrix(t),r=i&&i.dimension?i.dimension:"auto";let o;o="ascend"===(n||"ascend")?function(t,n){return t.compareTo(n)}:function(t,n){return n.compareTo(t)};const a=function(t){return t.sort(o),t};return e.eachVector(a,r)}}class FFT{static bit_reverse_32(t){let n=4294967295&t;return n=(1431655765&n)<<1|n>>1&1431655765,n=(858993459&n)<<2|n>>2&858993459,n=(252645135&n)<<4|n>>4&252645135,n=(16711935&n)<<8|n>>8&16711935,n=(65535&n)<<16|n>>16&65535}static create_bit_reverse_table(t){const n=1<<t,i=[];for(let e=0;e<n;e++)i[e]=FFT.bit_reverse_32(e)>>>32-t;return i}constructor(t){this.size=t,this.inv_size=1/this.size,this.bit_size=Math.round(Math.log(this.size)/Math.log(2)),this.is_fast=1<<this.bit_size===this.size,this.bitrv=null,this.fft_re=new Array(this.size),this.fft_im=new Array(this.size);{const t=-2*Math.PI/this.size;let n=0;for(let i=0,e=0;i<this.size;i++){this.fft_re[i]=Math.cos(e),this.fft_im[i]=Math.sin(e);const r=t+n,o=e+r;n=o-e-r,e=o}}this.is_fast&&(this.bitrv=FFT.create_bit_reverse_table(this.bit_size))}free(){delete this.size,delete this.inv_size,delete this.bit_size,delete this.is_fast,delete this.bitrv,delete this.fft_re,delete this.fft_im}fft(t,n){const i=new Array(this.size),e=new Array(this.size);if(this.is_fast){for(let r=0;r<this.size;r++)i[r]=t[this.bitrv[r]],e[r]=n[this.bitrv[r]];{let t=1,n=this.size/2,r=2;for(let o=1<<this.bit_size-1;o>0;o>>=1){for(let a=0;a<n;a++){let n=a*r;for(let r=0,a=0;r<t;r++,n++,a+=o){const r=i[n+t]*this.fft_re[a]-e[n+t]*this.fft_im[a],o=e[n+t]*this.fft_re[a]+i[n+t]*this.fft_im[a];i[n+t]=i[n]-r,e[n+t]=e[n]-o,i[n]+=r,e[n]+=o}}n/=2,r*=2,t*=2}}}else if(SignalTool.isContainsZero(n))for(let r=0;r<this.size;r++){i[r]=0,e[r]=0;for(let o=0,a=0;o<this.size;o++,a=o*r%this.size)i[r]+=t[o]*this.fft_re[a]-n[o]*this.fft_im[a],e[r]+=t[o]*this.fft_im[a]+n[o]*this.fft_re[a]}else for(let n=0;n<this.size;n++){i[n]=0,e[n]=0;for(let r=0,o=0;r<this.size;r++,o=r*n%this.size)i[n]+=t[r]*this.fft_re[o],e[n]+=t[r]*this.fft_im[o]}return{real:i,imag:e}}ifft(t,n){const i=new Array(this.size),e=new Array(this.size);if(this.is_fast){for(let r=0;r<this.size;r++)i[r]=t[this.bitrv[r]],e[r]=n[this.bitrv[r]];{let t,n,r=1,o=this.size/2,a=2;for(let s=1<<this.bit_size-1;s>0;s>>=1){for(let u=0;u<o;u++){let o=u*a;for(let a=0,u=0;a<r;a++,o++,u+=s)t=i[o+r]*this.fft_re[u]+e[o+r]*this.fft_im[u],n=e[o+r]*this.fft_re[u]-i[o+r]*this.fft_im[u],i[o+r]=i[o]-t,e[o+r]=e[o]-n,i[o]+=t,e[o]+=n}o/=2,a*=2,r*=2}}}else if(SignalTool.isContainsZero(n))for(let r=0;r<this.size;r++){i[r]=0,e[r]=0;for(let o=0,a=0;o<this.size;o++,a=r*o%this.size)i[r]+=t[o]*this.fft_re[a]+n[o]*this.fft_im[a],e[r]+=-t[o]*this.fft_im[a]+n[o]*this.fft_re[a]}else for(let n=0;n<this.size;n++){i[n]=0,e[n]=0;for(let r=0,o=0;r<this.size;r++,o=n*r%this.size)i[n]+=t[r]*this.fft_re[o],e[n]+=-t[r]*this.fft_im[o]}for(let t=0;t<this.size;t++)i[t]*=this.inv_size,e[t]*=this.inv_size;return{real:i,imag:e}}}class FFTCache{constructor(t,n){this.object=t,this.table=[],this.table_max=n}get(t){for(let n=0;n<this.table.length;n++)if(this.table[n].size===t){const t=this.table.splice(n,1)[0];return this.table.unshift(t),t}const n=new this.object(t);if(this.table.length===this.table_max){const t=this.table.pop();t.free()}return this.table.unshift(n),n}}const fft_cache=new FFTCache(FFT,4);class DCT{constructor(t){this.size=t,this.dct_size=2*t,this.dct_re=new Array(this.size),this.dct_im=new Array(this.size);{const t=1/Math.sqrt(this.size),n=t*Math.sqrt(2);for(let i=0;i<this.size;i++){const e=-Math.PI*i/this.dct_size;this.dct_re[i]=Math.cos(e)*(0===i?t:n),this.dct_im[i]=Math.sin(e)*(0===i?t:n)}}}free(){delete this.size,delete this.dct_size,delete this.dct_re,delete this.dct_im}dct(t){const n=new Array(this.dct_size),i=new Array(this.dct_size);for(let e=0;e<this.dct_size;e++)n[e]=e<this.size?t[e]:0,i[e]=0;const e=fft_cache.get(this.dct_size).fft(n,i);for(let t=0;t<this.size;t++)n[t]=e.real[t]*this.dct_re[t]-e.imag[t]*this.dct_im[t];return n.splice(this.size),n}idct(t){const n=new Array(this.dct_size),i=new Array(this.dct_size),e=2*this.size;for(let r=0;r<this.dct_size;r++)n[r]=r<this.size?e*t[r]*this.dct_re[r]:0,i[r]=r<this.size?e*t[r]*-this.dct_im[r]:0;const r=fft_cache.get(this.dct_size).ifft(n,i);return r.real.splice(this.size),r.real}}const dct_cache=new FFTCache(DCT,4);class SignalTool{static isContainsZero(t){for(let n=0;n<t.length;n++)if(0!==t[n])return!0;return!1}static fft(t,n){return fft_cache.get(t.length).fft(t,n)}static ifft(t,n){return fft_cache.get(t.length).ifft(t,n)}static dct(t){return dct_cache.get(t.length).dct(t)}static idct(t){return dct_cache.get(t.length).idct(t)}static powerfft(t,n){const i=t.length,e=SignalTool.fft(t,n),r=new Array(i);for(let t=0;t<i;t++)r[t]=e.real[t]*e.real[t]+e.imag[t]*e.imag[t];return r}static conv(t,n,i,e){let r=!1;if(t.length===i.length){r=!0;for(let o=0;o<t.length;o++)if(t[o]!==i[o]||n[o]!==e[o]){r=!1;break}}const o=t.length,a=2*o;if(1<<Math.round(Math.log(o)/Math.log(2))===o){if(r){const i=t.length,e=new Array(a),r=new Array(a);for(let o=0;o<a;o++)e[o]=o<i?t[o]:0,r[o]=o<i?n[o]:0;const o=SignalTool.fft(e,r);for(let t=0;t<a;t++)e[t]=o.real[t]*o.real[t]-o.imag[t]*o.imag[t],r[t]=o.real[t]*o.imag[t]+o.imag[t]*o.real[t];const s=SignalTool.ifft(e,r);return s.real.splice(a-1),s.imag.splice(a-1),s}if(t.length===i.length){const r=t.length,o=new Array(a),s=new Array(a),u=new Array(a),c=new Array(a);for(let l=0;l<a;l++)o[l]=l<r?t[l]:0,s[l]=l<r?n[l]:0,u[l]=l<r?i[l]:0,c[l]=l<r?e[l]:0;const l=SignalTool.fft(o,s),h=SignalTool.fft(u,c),g=new Array(a),f=new Array(a);for(let t=0;t<a;t++)g[t]=l.real[t]*h.real[t]-l.imag[t]*h.imag[t],f[t]=l.real[t]*h.imag[t]+l.imag[t]*h.real[t];const m=SignalTool.ifft(g,f);return m.real.splice(a-1),m.imag.splice(a-1),m}}let s=!SignalTool.isContainsZero(n);s&&(s=!SignalTool.isContainsZero(e));{const r=new Array(t.length+i.length-1),o=new Array(t.length+i.length-1);for(let t=0;t<r.length;t++)r[t]=0,o[t]=0;if(s)for(let n=0;n<i.length;n++)for(let e=0;e<t.length;e++)r[n+e]+=t[e]*i[n];else for(let a=0;a<i.length;a++)for(let s=0;s<t.length;s++)r[a+s]+=t[s]*i[a]-n[s]*e[a],o[a+s]+=t[s]*e[a]+n[s]*i[a];return{real:r,imag:o}}}static xcorr(t,n,i,e){let r=!1;if(t.length===i.length){r=!0;for(let o=0;o<t.length;o++)if(t[o]!==i[o]||n[o]!==e[o]){r=!1;break}}if(t.length===i.length){const o=t.length,a=2*o,s=Math.round(Math.log(o)/Math.log(2)),u=1<<s===o;if(u){let s=null;if(r){const i=new Array(a),e=new Array(a);for(let r=0;r<a;r++)i[r]=r<o?t[r]:0,e[r]=r<o?n[r]:0;const r=SignalTool.powerfft(i,e);s=SignalTool.ifft(r,e),i.pop(),e.pop();for(let t=0,n=o+1;t<i.length;t++,n++)a<=n&&(n=0),i[t]=s.real[n],e[t]=s.imag[n];return{real:i,imag:e}}{const r=new Array(a),u=new Array(a),c=new Array(a),l=new Array(a);for(let s=0;s<a;s++)r[s]=s<o?t[s]:0,u[s]=s<o?n[s]:0,c[s]=s<o?i[o-s-1]:0,l[s]=s<o?-e[o-s-1]:0;const h=SignalTool.fft(r,u),g=SignalTool.fft(c,l),f=new Array(a),m=new Array(a);for(let t=0;t<a;t++)f[t]=h.real[t]*g.real[t]-h.imag[t]*g.imag[t],m[t]=h.real[t]*g.imag[t]+h.imag[t]*g.real[t];return(s=SignalTool.ifft(f,m)).real.splice(a-1),s.imag.splice(a-1),s}}}let o=!SignalTool.isContainsZero(n);if(o&&(o=!SignalTool.isContainsZero(e)),r){const n=t.length,e=2*n;if(o){const r=new Array(n);for(let e=0;e<n;e++){r[e]=0;const o=n-e;for(let n=0;n<o;n++)r[e]+=t[n]*i[n+e]}const o=new Array(e-1),a=new Array(e-1);for(let t=0,i=n-1;t<n;t++,i--)o[t]=r[i],o[n+t-1]=r[t];for(let t=0;t<a.length;t++)a[t]=0;return{real:o,imag:a}}}{const r=new Array(i.length),o=new Array(i.length);for(let t=0;t<i.length;t++)r[t]=i[i.length-t-1],o[t]=-e[i.length-t-1];const a=SignalTool.conv(t,n,r,o);if(t.length===i.length)return a;const s=Math.abs(t.length-i.length),u=new Array(s);for(let t=0;t<s;t++)u[t]=0;return t.length>i.length?{real:u.concat(a.real),imag:u.concat(a.imag)}:{real:a.real.concat(u),imag:a.imag.concat(u)}}}static window(t,n,i){const e=void 0!==i?i:"symmetric",r=t.toLocaleLowerCase(),o=n,a=new Array(o);let s;"symmetric"===e||0===e?s=function(t){return t/(o-1)*(2*Math.PI)}:"periodic"!==e&&0===e||(s=function(t){return t/o*(2*Math.PI)});const u=function(t,n,i,e,r){for(let u=0;u<o;u++)a[u]=t,a[u]-=n*Math.cos(1*s(u)),a[u]+=i*Math.cos(2*s(u)),a[u]-=e*Math.cos(3*s(u)),a[u]+=r*Math.cos(4*s(u))};switch(r){case"rectangle":u(1,0,0,0,0);break;case"hann":u(.5,.5,0,0,0);break;case"hamming":u(.54,.46,0,0,0);break;case"blackman":u(.42,.5,.08,0,0);break;case"blackmanharris":u(.35875,.48829,.14128,.01168,0);break;case"blackmannuttall":u(.3635819,.4891775,.1365995,.0106411,0);break;case"flattop":u(1,1.93,1.29,.388,.032);break;case"sin":for(let t=0;t<o;t++)a[t]=Math.sin(.5*s(t));break;case"vorbis":for(let t=0;t<o;t++){const n=Math.sin(.5*s(t));a[t]=Math.sin(.5*Math.PI*n*n)}}return a}static hann(t,n){return SignalTool.window("hann",t,n)}static hamming(t,n){return SignalTool.window("hamming",t,n)}}class Signal{static fft(t,n){const i=n&&n.dimension?n.dimension:"auto",e=function(t){const n=new Array(t.length),i=new Array(t.length);for(let e=0;e<t.length;e++)n[e]=t[e].real,i[e]=t[e].imag;const e=SignalTool.fft(n,i),r=new Array(t.length);for(let n=0;n<t.length;n++)r[n]=new Complex([e.real[n],e.imag[n]]);return r};return Matrix._toMatrix(t).eachVector(e,i)}static ifft(t,n){const i=n&&n.dimension?n.dimension:"auto",e=function(t){const n=new Array(t.length),i=new Array(t.length);for(let e=0;e<t.length;e++)n[e]=t[e].real,i[e]=t[e].imag;const e=SignalTool.ifft(n,i),r=new Array(t.length);for(let n=0;n<t.length;n++)r[n]=new Complex([e.real[n],e.imag[n]]);return r};return Matrix._toMatrix(t).eachVector(e,i)}static powerfft(t,n){const i=n&&n.dimension?n.dimension:"auto",e=function(t){const n=new Array(t.length),i=new Array(t.length);for(let e=0;e<t.length;e++)n[e]=t[e].real,i[e]=t[e].imag;const e=SignalTool.powerfft(n,i),r=new Array(t.length);for(let n=0;n<t.length;n++)r[n]=new Complex(e[n]);return r};return Matrix._toMatrix(t).eachVector(e,i)}static dct(t,n){const i=n&&n.dimension?n.dimension:"auto",e=Matrix._toMatrix(t);if(e.isComplex())throw"dct don't support complex numbers.";const r=function(t){const n=new Array(t.length);for(let i=0;i<t.length;i++)n[i]=t[i].real;const i=SignalTool.dct(n),e=new Array(t.length);for(let n=0;n<t.length;n++)e[n]=new Complex(i[n]);return e};return e.eachVector(r,i)}static idct(t,n){const i=n&&n.dimension?n.dimension:"auto",e=Matrix._toMatrix(t);if(e.isComplex())throw"idct don't support complex numbers.";const r=function(t){const n=new Array(t.length);for(let i=0;i<t.length;i++)n[i]=t[i].real;const i=SignalTool.idct(n),e=new Array(t.length);for(let n=0;n<t.length;n++)e[n]=new Complex(i[n]);return e};return e.eachVector(r,i)}static fft2(t){return Signal.fft(t,{dimension:"both"})}static ifft2(t){return Signal.ifft(t,{dimension:"both"})}static dct2(t){return Signal.dct(t,{dimension:"both"})}static idct2(t){return Signal.idct(t,{dimension:"both"})}static conv(t,n){const i=Matrix._toMatrix(t),e=Matrix._toMatrix(n);if(i.isMatrix()||e.isMatrix())throw"conv don't support matrix numbers.";const r=new Array(i.length),o=new Array(i.length),a=new Array(e.length),s=new Array(e.length);if(i.isRow())for(let t=0;t<i.column_length;t++)r[t]=i.matrix_array[0][t].real,o[t]=i.matrix_array[0][t].imag;else for(let t=0;t<i.row_length;t++)r[t]=i.matrix_array[t][0].real,o[t]=i.matrix_array[t][0].imag;if(e.isRow())for(let t=0;t<e.column_length;t++)a[t]=e.matrix_array[0][t].real,s[t]=e.matrix_array[0][t].imag;else for(let t=0;t<e.row_length;t++)a[t]=e.matrix_array[t][0].real,s[t]=e.matrix_array[t][0].imag;const u=SignalTool.conv(r,o,a,s),c=new Array(u.real.length);for(let t=0;t<u.real.length;t++)c[t]=new Complex([u.real[t],u.imag[t]]);const l=new Matrix([c]);return e.isRow()?l:l.transpose()}static xcorr(t,n){const i=Matrix._toMatrix(t);if(!n)return i.xcorr(i);const e=Matrix._toMatrix(n);if(i.isMatrix()||e.isMatrix())throw"conv don't support matrix numbers.";const r=new Array(i.length),o=new Array(i.length),a=new Array(e.length),s=new Array(e.length);if(i.isRow())for(let t=0;t<i.column_length;t++)r[t]=i.matrix_array[0][t].real,o[t]=i.matrix_array[0][t].imag;else for(let t=0;t<i.row_length;t++)r[t]=i.matrix_array[t][0].real,o[t]=i.matrix_array[t][0].imag;if(e.isRow())for(let t=0;t<e.column_length;t++)a[t]=e.matrix_array[0][t].real,s[t]=e.matrix_array[0][t].imag;else for(let t=0;t<e.row_length;t++)a[t]=e.matrix_array[t][0].real,s[t]=e.matrix_array[t][0].imag;const u=SignalTool.xcorr(r,o,a,s),c=new Array(u.real.length);for(let t=0;t<u.real.length;t++)c[t]=new Complex([u.real[t],u.imag[t]]);const l=new Matrix([c]);return i.isRow()?l:l.transpose()}static window(t,n,i){const e=Matrix._toInteger(n),r=SignalTool.window(t,e,i);return new Matrix(r).transpose()}static hann(t,n){return Signal.window("hann",t,n)}static hamming(t,n){return Signal.window("hamming",t,n)}static fftshift(t,n){const i=Matrix._toMatrix(t);if(i.isVector()){const t=Math.floor(i.length/2);return i.circshift(t,n)}const e=Math.floor(i.column_length/2),r=Math.floor(i.row_length/2);if(void 0!==n){const t=n.dimension;if("row"===t||1===t)return i.circshift(e,n);if("column"===t||2===t)return i.circshift(r,n)}return i.circshift(e,{dimension:"row"}).circshift(r,{dimension:"column"})}}class KonpeitoInteger{constructor(t){}static create(t){return null}static valueOf(t){return null}toString(){return"no"}toJSON(){return this.toString()}clone(){return null}abs(){return null}negate(){return null}sign(){return null}add(t){return null}sub(t){return null}mul(t){return null}div(t){return null}inv(){return null}rem(t){return null}mod(t){return null}modPow(t,n){return null}modInverse(t){return null}factorial(){return null}scaleByPowerOfTen(t){return null}pow(t){return null}square(){return null}get booleanValue(){return null}get intValue(){return null}get doubleValue(){return null}toBigInteger(){return null}toBigDecimal(t){return null}toFraction(){return null}toComplex(){return null}toMatrix(){return null}equals(t){return null}compareTo(t){return null}floor(){return null}ceil(){return null}round(){return null}fix(){return null}fract(){return BigInteger.ZERO}factor(){return null}gcd(t){return null}extgcd(t){return null}lcm(t){return null}isPrime(){return null}isProbablePrime(t){return null}nextProbablePrime(t,n){return null}shift(t){return null}and(t){return null}or(t){return null}xor(t){return null}not(){return null}isZero(){return null}isOne(){return null}isPositive(){return null}isNegative(){return null}isNotNegative(){return null}isNaN(){return null}isPositiveInfinity(){return null}isNegativeInfinity(){return null}isInfinite(){return null}isFinite(){return null}static get MINUS_ONE(){return null}static get ZERO(){return null}static get ONE(){return null}static get TWO(){return null}static get TEN(){return null}static get POSITIVE_INFINITY(){return null}static get NEGATIVE_INFINITY(){return null}static get NaN(){return null}signum(){return this.sign()}subtract(t){return this.sub(t)}multiply(t){return this.mul(t)}divide(t){return this.div(t)}remainder(t){return this.rem(t)}}class KonpeitoFloat extends KonpeitoInteger{constructor(t){super()}sqrt(){return null}cbrt(){return null}rsqrt(){return null}log(){return null}exp(){return null}expm1(){return null}log1p(){return null}log2(){return null}log10(){return null}sin(){return null}cos(){return null}tan(){return null}atan(){return null}atan2(t){return null}asin(){return null}acos(){return null}sinh(){return null}asinh(){return null}cosh(){return null}acosh(){return null}tanh(){return null}atanh(){return null}sec(){return null}asec(){return null}sech(){return null}asech(){return null}cot(){return null}acot(){return null}coth(){return null}acoth(){return null}csc(){return null}acsc(){return null}csch(){return null}acsch(){return null}logit(){return null}sinc(){return null}static get PI(){return null}static get QUARTER_PI(){return null}static get HALF_PI(){return null}static get TWO_PI(){return null}static get E(){return null}static get LN2(){return null}static get LN10(){return null}static get LOG2E(){return null}static get LOG10E(){return null}static get SQRT2(){return null}static get SQRT1_2(){return null}static get HALF(){return null}}class MatrixTool{static toPositionArrayFromObject(t,n,i){if("string"==typeof t){const e=MatrixTool.toArrayFromString(t);if(":"===e){const t=new Array(n);for(let e=0;e<n;e++)t[e]=e+i;return t}if(e instanceof Array){const t=e,n=new Array(t.length);for(let i=0;i<t.length;i++)n[i]=Math.trunc(t[i].real);return n}throw"toArrayFromString["+t+"]["+e+"]"}let e=t;if(e instanceof Matrix||e instanceof Complex||"number"==typeof e||(e=Matrix._toMatrix(e)),e instanceof Matrix){if(!e.isVector())throw"getMatrix argument "+e;const t=e.length,n=new Array(e.length);if(e.isRow())for(let i=0;i<t;i++)n[i]=Math.trunc(e.matrix_array[0][i].real);else if(e.isColumn())for(let i=0;i<t;i++)n[i]=Math.trunc(e.matrix_array[i][0].real);return n}return[Matrix._toInteger(e)]}static match2(t,n){const i=[];let e=t;for(let t=0;t<1e3;t++){const t=e.match(n);if(null===t){e.length&&i.push([!1,e]);break}t.index>0&&i.push([!1,e.substr(0,t.index)]),i.push([!0,t[0]]),e=e.substr(t.index+t[0].length)}return i}static trimBracket(t){let n=t,i=!1;if(/'$/.test(n)){const t=n.match(/(\s*')*$/g)[0],e=t.split("'").length-1;i=e%2==1,n=n.substring(0,n.length-t.length)}return/^\[/.test(n)&&/\]$/.test(n)?{text:n.substring(1,n.length-1),is_transpose:i}:null}static toMatrixArrayFromStringForArrayJSON(t){const n=[];let i=t.match(/\[[^\]]+\]/g);null===i&&(i=[t]);for(let t=0;t<i.length;t++){const e=i[t],r=e.substring(1,e.length-1).split(","),o=[];for(let t=0;t<r.length;t++){const n=r[t];o[t]=new Complex(n)}n[t]=o}return n}static InterpolationCalculation(t,n,i,e){const r=t.compareTo(i),o=void 0===e||e;if(0===r)return[t];if(n.isZero())throw"IllegalArgumentException";if(n.isNegative()&&-1===r)throw"IllegalArgumentException";const a=[];let s=t;a[0]=s;for(let t=1;t<65536;t++){if(s=s.add(n),o){if(i.compareTo(s)===r)break}else if(i.compareTo(s)*r>=0)break;a[t]=s}return a}static toArrayFromMatch2String(t){const n=t,i=[];for(let t=0;t<n.length;t++){const e=n[t];if(e[0])if(t<n.length-2&&!n[t+1][0]&&/:/.test(n[t+1][1])){let r,o,a;t<n.length-4&&!n[t+3][0]&&/:/.test(n[t+3][1])?(r=new Complex(e[1]),o=new Complex(n[t+2][1]),a=new Complex(n[t+4][1]),t+=4):(r=new Complex(e[1]),o=Complex.ONE,a=new Complex(n[t+2][1]),t+=2);const s=MatrixTool.InterpolationCalculation(r,o,a,!0);for(let t=0;t<s.length;t++)i.push(s[t])}else i.push(new Complex(e[1]))}return i}static toArrayFromString(t){if(":"===t.trim())return":";const n=t.toLowerCase().replace(/infinity|inf/g,"1e100000"),i=new RegExp("("+/[+-]? *(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan))?[ij]( *[+] *[- ]?(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan)))?/.source+")|("+/[+-]? *(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan))( *[+-] *[- ]?(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan))?[ij])?/.source+")","i");return MatrixTool.toArrayFromMatch2String(MatrixTool.match2(n,i))}static toMatrixArrayFromStringForArraySPACE(t){const n=t.split(";"),i=new Array(n.length);for(let t=0;t<n.length;t++)i[t]=MatrixTool.toArrayFromString(n[t]);return i}static toMatrixArrayFromStringInBracket(t){return/[[\]]/.test(t)?MatrixTool.toMatrixArrayFromStringForArrayJSON(t):MatrixTool.toMatrixArrayFromStringForArraySPACE(t)}static toMatrixArrayFromString(t){const n=t.replace(/^\s*|\s*$/g,""),i=MatrixTool.trimBracket(n);if(i){let t=MatrixTool.toMatrixArrayFromStringInBracket(i.text);return i.is_transpose&&(t=new Matrix(t).T().matrix_array),t}return/[;,]|[0-9]\s+[0-9]/.test(t)?MatrixTool.toMatrixArrayFromStringInBracket(t.replace(/[[\]]/g,"").replace(/,/g," ")):[[new Complex(t)]]}static isCorrectMatrixArray(t){if(0===t.length)return!1;const n=t[0].length;if(0===n)return!1;for(let i=1;i<t.length;i++)if(t[i].length!==n)return!1;return!0}}class Matrix extends KonpeitoFloat{constructor(t){super();let n=null,i=!1;if(1!==arguments.length)throw"Matrix : Many arguments ["+arguments.length+"]";{const e=t;if(e instanceof Matrix){n=new Array(e.row_length);for(let t=0;t<e.row_length;t++){n[t]=new Array(e.column_length);for(let i=0;i<e.column_length;i++)n[t][i]=e.matrix_array[t][i]}}else if(e instanceof Complex)n=[[e]];else if(e instanceof Array){n=[];for(let t=0;t<e.length;t++){const i=e[t];if(i instanceof Array){const e=new Array(i.length);for(let t=0;t<i.length;t++){const n=i[t];if(n instanceof Complex)e[t]=n;else if(n instanceof Matrix){if(!n.isScalar())throw"Matrix in matrix";e[t]=n.scalar}else e[t]=new Complex(n)}n[t]=e}else if(0===t&&(n[0]=new Array(e.length)),i instanceof Complex)n[0][t]=i;else if(i instanceof Matrix){if(!i.isScalar())throw"Matrix in matrix";n[0][t]=i.scalar}else n[0][t]=new Complex(i)}}else"string"==typeof e?(i=!0,n=MatrixTool.toMatrixArrayFromString(e)):e instanceof Object&&"doubleValue"in e?n=[[new Complex(e.doubleValue)]]:e instanceof Object?(i=!0,n=MatrixTool.toMatrixArrayFromString(e.toString())):n=[[new Complex(e)]]}if(i)for(let t=0;t<n.length;t++)":"===n[t]&&n.splice(t--,1);if(!MatrixTool.isCorrectMatrixArray(n))throw console.log(n),"new Matrix IllegalArgumentException";this.matrix_array=n,this.row_length=this.matrix_array.length,this.column_length=this.matrix_array[0].length,this.string_cash=null}static create(t){return 1===arguments.length&&t instanceof Matrix?t:new Matrix(t)}static valueOf(t){return Matrix.create(t)}static _toMatrix(t){return t instanceof Matrix?t:new Matrix(t)}static _toComplex(t){if(t instanceof Complex)return t;const n=Matrix._toMatrix(t);if(n.isScalar())return n.scalar;throw"not scalar. ["+t+"]"}static _toDouble(t){if("number"==typeof t)return t;const n=Matrix._toComplex(t);if(n.isReal())return n.real;throw"not support complex numbers."}static _toInteger(t){return Math.trunc(Matrix._toDouble(t))}_clearCash(){this.string_cash&&delete this.string_cash}clone(){return new Matrix(this.matrix_array)}toString(){if(this.string_cash)return this.string_cash;if(this.isScalar())return this.scalar.toString();const t=Math.pow(10,9);let n=!1,i=!1,e=0;this._each(function(r,o,a){r.isReal()||(n=!0),Number.isFinite(r.real)&&Math.abs(r.real)>=t&&(i=!0),Number.isFinite(r.imag)&&Math.abs(r.imag)>=t&&(i=!0),e=Math.max(e,r.getDecimalPosition())}),e>0&&(e=4);let r=0;const o=[],a=function(t){const n=i?t.toExponential(4):t.toFixed(e);if(/inf/i.test(n))return t===Number.POSITIVE_INFINITY?"Inf":"-Inf";if(/nan/i.test(n))return"NaN";if(!i)return n;const r=n.split("e");let o=r[1];return 2===o.length?o=o.substr(0,1)+"00"+o.substr(1):3===o.length&&(o=o.substr(0,1)+"0"+o.substr(1)),r[0]+"e"+o};this._each(function(t){const i={};let e=t.real;if(i.re_sign=e<0?"-":" ",e=Math.abs(e),i.re_str=a(e),r=Math.max(r,i.re_str.length+1),n){let n=t.imag;i.im_sign=n<0?"-":"+",n=Math.abs(n),i.im_str=a(n),r=Math.max(r,i.im_str.length+1)}o.push(i)});const s=function(t,n){return"                                        ".substr(0,n-t.length)+t},u=[],c=this;return this._each(function(t,i,e){const a=o.shift();let l=s(a.re_sign+a.re_str,r);n&&(l+=" "+a.im_sign+s(a.im_str,r)+"i"),u.push(l),u.push(e<c.column_length-1?" ":"\n")}),this.string_cash=u.join(""),this.string_cash}toOneLineString(){if(this.isScalar())return this.scalar.toString();let t="[ ";for(let n=0;n<this.row_length;n++)for(let i=0;i<this.column_length;i++)t+=this.matrix_array[n][i].toString(),i<this.column_length-1?t+=", ":n<this.row_length-1&&(t+="; ");return t+=" ]"}toJSON(){if(this.isScalar())return this.scalar.toJSON();let t="[";for(let n=0;n<this.row_length;n++)for(let i=0;i<this.column_length;i++)t+=this.matrix_array[n][i].toJSON(),i<this.column_length-1?t+=",":n<this.row_length-1&&(t+=";");return t+="]"}equals(t,n){const i=this,e=Matrix._toMatrix(t);if(i.row_length!==e.row_length||i.column_length!==e.column_length)return!1;if(1===i.row_length&&1===i.column_length)return i.scalar.equals(e.scalar,n);const r=i.matrix_array,o=e.matrix_array;for(let t=0;t<this.row_length;t++)for(let i=0;i<this.column_length;i++)if(!r[t][i].equals(o[t][i],n))return!1;return!0}getNumberMatrixArray(){const t=new Array(this.row_length);for(let n=0;n<this.row_length;n++){t[n]=new Array(this.column_length);for(let i=0;i<this.column_length;i++)t[n][i]=this.matrix_array[n][i].real}return t}getComplexMatrixArray(){const t=new Array(this.row_length);for(let n=0;n<this.row_length;n++){t[n]=new Array(this.column_length);for(let i=0;i<this.column_length;i++)t[n][i]=this.matrix_array[n][i]}return t}_each(t){let n=!1;for(let i=0;i<this.row_length;i++)for(let e=0;e<this.column_length;e++){const r=t(this.matrix_array[i][e],i,e);void 0!==r&&(this.matrix_array[i][e]=r instanceof Complex?r:r instanceof Matrix?r.scalar:new Complex(r),n=!0)}return n&&this._clearCash(),this}cloneMatrixDoEachCalculation(t){return this.clone()._each(t)}static createMatrixDoEachCalculation(t,n,i){if(0===arguments.length||arguments.length>3)throw"IllegalArgumentException";const e=Matrix._toInteger(n),r=i?Matrix._toInteger(i):e,o=new Array(e);for(let n=0;n<e;n++){o[n]=new Array(r);for(let i=0;i<r;i++){const e=t(n,i);o[n][i]=void 0===e?Complex.ZERO:Matrix._toComplex(e)}}return new Matrix(o)}eachVectorAuto(t){if(this.isRow()){const n=new Array(this.row_length);for(let t=0;t<this.column_length;t++)n[t]=this.matrix_array[0][t];return new Matrix(t(n))}{const n=Matrix.ZERO;n._resize(1,this.column_length);for(let i=0;i<this.column_length;i++){const e=new Array(this.row_length);for(let t=0;t<this.row_length;t++)e[t]=this.matrix_array[t][i];const r=t(e);n._resize(Math.max(n.row_length,r.length),n.column_length);for(let t=0;t<r.length;t++)n.matrix_array[t][i]=r[t]}return n}}eachVectorBoth(t){const n=Matrix.ZERO;n._resize(this.row_length,1);for(let i=0;i<this.row_length;i++){const e=new Array(this.column_length);for(let t=0;t<this.column_length;t++)e[t]=this.matrix_array[i][t];const r=t(e);n._resize(n.row_length,Math.max(n.column_length,r.length));for(let t=0;t<r.length;t++)n.matrix_array[i][t]=r[t]}const i=Matrix.ZERO;i._resize(1,n.column_length);for(let e=0;e<n.column_length;e++){const r=new Array(n.row_length);for(let t=0;t<n.row_length;t++)r[t]=n.matrix_array[t][e];const o=t(r);i._resize(Math.max(i.row_length,o.length),i.column_length);for(let t=0;t<o.length;t++)i.matrix_array[t][e]=o[t]}return i}eachVectorRow(t){const n=Matrix.ZERO;n._resize(this.row_length,1);for(let i=0;i<this.row_length;i++){const e=new Array(this.column_length);for(let t=0;t<this.column_length;t++)e[t]=this.matrix_array[i][t];const r=t(e);n._resize(n.row_length,Math.max(n.column_length,r.length));for(let t=0;t<r.length;t++)n.matrix_array[i][t]=r[t]}return n}eachVectorColumn(t){const n=Matrix.ZERO;n._resize(1,this.column_length);for(let i=0;i<this.column_length;i++){const e=new Array(this.row_length);for(let t=0;t<this.row_length;t++)e[t]=this.matrix_array[t][i];const r=t(e);n._resize(Math.max(n.row_length,r.length),n.column_length);for(let t=0;t<r.length;t++)n.matrix_array[t][i]=r[t]}return n}eachVector(t,n){let i=void 0!==n?n:"auto";if("string"==typeof i?i=i.toLocaleLowerCase():"number"!=typeof i&&(i=Matrix._toInteger(i)),"auto"===i||0===i)return this.eachVectorAuto(t);if("row"===i||1===i)return this.eachVectorRow(t);if("column"===i||2===i)return this.eachVectorColumn(t);if("both"===i||3===i)return this.eachVectorBoth(t);throw"eachVector argument "+n}getMatrix(t,n,i=!1){const e=i?1:0,r=MatrixTool.toPositionArrayFromObject(t,this.row_length,e),o=MatrixTool.toPositionArrayFromObject(n,this.column_length,e),a=this.matrix_array,s=new Array(r.length);for(let t=0;t<r.length;t++){const n=new Array(o.length);for(let i=0;i<o.length;i++)n[i]=a[r[t]-e][o[i]-e];s[t]=n}return new Matrix(s)}setMatrix(t,n,i,e=!1){const r=e?1:0,o=MatrixTool.toPositionArrayFromObject(t,this.row_length,r),a=MatrixTool.toPositionArrayFromObject(n,this.column_length,r),s=new Matrix(this).matrix_array,u=Matrix._toMatrix(i),c=u.matrix_array;for(let t=0;t<o.length;t++)for(let n=0;n<a.length;n++)s[o[t]-r][a[n]-r]=c[t%u.row_length][n%u.column_length];return new Matrix(s)}getComplex(t,n){let i=null,e=null;return 1===arguments.length?i=Matrix._toInteger(t):2===arguments.length&&(i=Matrix._toInteger(t),e=Matrix._toInteger(n)),this.isRow()?this.matrix_array[0][i]:this.isColumn()?this.matrix_array[i][0]:this.matrix_array[i][e]}get booleanValue(){return this.matrix_array[0][0].booleanValue}get intValue(){return this.matrix_array[0][0].intValue}get doubleValue(){return this.matrix_array[0][0].doubleValue}toBigInteger(){return new BigInteger(this.intValue)}toBigDecimal(t){return new BigDecimal(t?[this.doubleValue,t]:this.doubleValue)}toFraction(){return new Fraction(this.doubleValue)}toComplex(){return this.scalar}toMatrix(){return this}get scalar(){return this.matrix_array[0][0]}get length(){return this.row_length>this.column_length?this.row_length:this.column_length}get width(){return this.column_length}get height(){return this.row_length}get norm1(){return LinearAlgebra.norm(this,1)}get norm2(){return LinearAlgebra.norm(this,2)}norm(t){return LinearAlgebra.norm(this,t)}cond(t){return LinearAlgebra.cond(this,t)}rcond(){return LinearAlgebra.rcond(this)}rank(t){return LinearAlgebra.rank(this,t)}trace(){return LinearAlgebra.trace(this)}det(){return LinearAlgebra.det(this)}static memset(t,n,i){if(0===arguments.length||arguments.length>3)throw"IllegalArgumentException";const e=Matrix._toMatrix(t);if(e.isScalar()){const t=e.scalar;return Matrix.createMatrixDoEachCalculation(function(){return t},n,i)}{const t=e.matrix_array,r=e.row_length,o=e.column_length;return Matrix.createMatrixDoEachCalculation(function(n,i){return t[n%r][i%o]},n,i)}}static eye(t,n){return Matrix.createMatrixDoEachCalculation(function(t,n){return t===n?Complex.ONE:Complex.ZERO},t,n)}static zeros(t,n){if(0===arguments.length||arguments.length>2)throw"IllegalArgumentException";return Matrix.memset(Complex.ZERO,t,n)}static ones(t,n){if(0===arguments.length||arguments.length>2)throw"IllegalArgumentException";return Matrix.memset(Complex.ONE,t,n)}diag(){if(this.isVector()){const t=this;return Matrix.createMatrixDoEachCalculation(function(n,i){return n===i?t.getComplex(n):Complex.ZERO},this.length)}{const t=Math.min(this.row_length,this.column_length),n=new Array(t);for(let i=0;i<t;i++)n[i]=new Array(1),n[i][0]=this.matrix_array[i][i];return new Matrix(n)}}isScalar(){return 1===this.row_length&&1==this.column_length}isRow(){return 1===this.row_length}isColumn(){return 1===this.column_length}isVector(){return 1===this.row_length||1===this.column_length}isMatrix(){return 1!==this.row_length&&1!==this.column_length}isSquare(){return this.row_length===this.column_length}isReal(t){let n=!0;return this._each(function(i){n&&i.isComplex(t)&&(n=!1)}),n}isComplex(t){return!this.isReal(t)}isZeros(t){let n=!0;const i=t||1e-10;return this._each(function(t){n&&!t.isZero(i)&&(n=!1)}),n}isIdentity(t){let n=!0;const i=t||1e-10;return this._each(function(t,e,r){n&&(e===r?t.isOne(i)||(n=!1):t.isZero(i)||(n=!1))}),n}isDiagonal(t){let n=!0;const i=t||1e-10;return this._each(function(t,e,r){n&&e!==r&&!t.isZero(i)&&(n=!1)}),n}isTridiagonal(t){let n=!0;const i=t||1e-10;return this._each(function(t,e,r){n&&Math.abs(e-r)>1&&!t.isZero(i)&&(n=!1)}),n}isRegular(t){if(!this.isSquare())return!1;const n=t||1e-10;return this.rank(n)===this.row_length}isOrthogonal(t){if(!this.isSquare())return!1;const n=t||1e-10;return this.mul(this.transpose()).isIdentity(n)}isUnitary(t){if(!this.isSquare())return!1;const n=t||1e-10;return this.mul(this.ctranspose()).isIdentity(n)}isSymmetric(t){if(!this.isSquare())return!1;const n=t||1e-10;for(let t=0;t<this.row_length;t++)for(let i=t+1;i<this.column_length;i++)if(!this.matrix_array[t][i].equals(this.matrix_array[i][t],n))return!1;return!0}isHermitian(t){if(!this.isSquare())return!1;const n=t||1e-10;for(let t=0;t<this.row_length;t++)for(let i=t;i<this.column_length;i++)if(t===i){if(!this.matrix_array[t][i].isReal(n))return!1}else if(!this.matrix_array[t][i].equals(this.matrix_array[i][t].conj(),n))return!1;return!0}isTriangleUpper(t){let n=!0;const i=t||1e-10;return this._each(function(t,e,r){n&&e>r&&!t.isZero(i)&&(n=!1)}),n}isTriangleLower(t){let n=!0;const i=t||1e-10;return this._each(function(t,e,r){n&&e<r&&!t.isZero(i)&&(n=!1)}),n}isPermutation(t){if(!this.isSquare())return!1;const n=t||1e-10,i=new Array(this.row_length),e=new Array(this.column_length);for(let t=0;t<this.row_length;t++)for(let r=0;r<this.column_length;r++){const o=this.matrix_array[t][r];if(o.isOne(n)){if(i[t]||e[r])return!1;i[t]=1,e[r]=1}else if(!o.isZero(n))return!1}for(let t=0;t<this.row_length;t++)if(void 0===i[t]||void 0===e[t])return!1;return!0}size(t){if(void 0!==t){let n=t;if("string"==typeof n?n=n.toLocaleLowerCase():"number"!=typeof n&&(n=Matrix._toInteger(n)),"row"===n||1===n)return new Matrix(this.row_length);if("column"===n||2===n)return new Matrix(this.column_length)}return new Matrix([[this.row_length,this.column_length]])}compareTo(t,n){const i=this,e=Matrix._toMatrix(t);if(i.isScalar()&&e.isScalar())return i.scalar.compareTo(e.scalar,n);throw"IllegalArgumentException"}compareToMatrix(t,n){const i=this,e=Matrix._toMatrix(t),r=i.matrix_array,o=e.matrix_array,a=Math.max(i.row_length,e.row_length),s=Math.max(i.column_length,e.column_length);return Matrix.createMatrixDoEachCalculation(function(t,a){return r[t%i.row_length][a%i.column_length].compareTo(o[t%e.row_length][a%e.column_length],n)},a,s)}add(t){const n=this,i=Matrix._toMatrix(t);if(n.row_length!==i.row_length&&n.column_length!==i.column_length)throw"Matrix size does not match";const e=n.matrix_array,r=i.matrix_array,o=Math.max(n.row_length,i.row_length),a=Math.max(n.column_length,i.column_length);return Matrix.createMatrixDoEachCalculation(function(t,o){return e[t%n.row_length][o%n.column_length].add(r[t%i.row_length][o%i.column_length])},o,a)}sub(t){const n=this,i=Matrix._toMatrix(t);if(n.row_length!==i.row_length&&n.column_length!==i.column_length)throw"Matrix size does not match";const e=n.matrix_array,r=i.matrix_array,o=Math.max(n.row_length,i.row_length),a=Math.max(n.column_length,i.column_length);return Matrix.createMatrixDoEachCalculation(function(t,o){return e[t%n.row_length][o%n.column_length].sub(r[t%i.row_length][o%i.column_length])},o,a)}mul(t){const n=this,i=Matrix._toMatrix(t),e=n.matrix_array,r=i.matrix_array;if(n.isScalar()&&i.isScalar())return new Matrix(n.scalar.mul(i.scalar));if(n.isScalar()){const t=new Array(i.row_length);for(let e=0;e<i.row_length;e++){t[e]=new Array(i.column_length);for(let o=0;o<i.column_length;o++)t[e][o]=n.scalar.mul(r[e][o])}return new Matrix(t)}if(i.isScalar()){const t=new Array(n.row_length);for(let r=0;r<n.row_length;r++){t[r]=new Array(n.column_length);for(let o=0;o<n.column_length;o++)t[r][o]=e[r][o].mul(i.scalar)}return new Matrix(t)}if(n.column_length!==i.row_length)throw"Matrix size does not match";{const t=new Array(n.row_length);for(let o=0;o<n.row_length;o++){t[o]=new Array(i.column_length);for(let a=0;a<i.column_length;a++){let i=Complex.ZERO;for(let t=0;t<n.column_length;t++)i=i.add(e[o][t].mul(r[t][a]));t[o][a]=i}}return new Matrix(t)}}div(t){const n=this,i=Matrix._toMatrix(t),e=n.matrix_array;if(n.isScalar()&&i.isScalar())return new Matrix(n.scalar.div(i.scalar));if(i.isScalar()){const t=new Array(n.row_length);for(let r=0;r<n.row_length;r++){t[r]=new Array(n.column_length);for(let o=0;o<n.column_length;o++)t[r][o]=e[r][o].div(i.scalar)}return new Matrix(t)}if(i.row_length===i.column_length){const t=i.det().scalar.norm;return t>1e-10?this.mul(i.inv()):this.mul(i.pinv())}if(n.column_length!==i.column_length)throw"Matrix size does not match";throw"warning"}inv(){return LinearAlgebra.inv(this)}dotmul(t){const n=this,i=Matrix._toMatrix(t);if(!n.isScalar()&&!i.isScalar()&&n.row_length!==i.row_length&&n.column_length!==i.column_length)throw"Matrix size does not match";const e=n.matrix_array,r=i.matrix_array,o=Math.max(n.row_length,i.row_length),a=Math.max(n.column_length,i.column_length);return Matrix.createMatrixDoEachCalculation(function(t,o){return e[t%n.row_length][o%n.column_length].mul(r[t%i.row_length][o%i.column_length])},o,a)}dotdiv(t){const n=this,i=Matrix._toMatrix(t);if(!n.isScalar()&&!i.isScalar()&&n.row_length!==i.row_length&&n.column_length!==i.column_length)throw"Matrix size does not match";const e=n.matrix_array,r=i.matrix_array,o=Math.max(n.row_length,i.row_length),a=Math.max(n.column_length,i.column_length);return Matrix.createMatrixDoEachCalculation(function(t,o){return e[t%n.row_length][o%n.column_length].div(r[t%i.row_length][o%i.column_length])},o,a)}dotinv(){const t=this,n=t.matrix_array;return Matrix.createMatrixDoEachCalculation(function(t,i){return n[t][i].inv()},t.row_length,t.column_length)}nmul(t){return this.dotmul(t)}ndiv(t){return this.dotdiv(t)}ninv(){return this.dotinv()}npow(t){return this.dotpow(t)}rem(t){const n=this,i=Matrix._toMatrix(t);if(!n.isScalar()&&!i.isScalar()&&n.row_length!==i.row_length&&n.column_length!==i.column_length)throw"Matrix size does not match";const e=n.matrix_array,r=i.matrix_array,o=Math.max(n.row_length,i.row_length),a=Math.max(n.column_length,i.column_length);return Matrix.createMatrixDoEachCalculation(function(t,o){return e[t%n.row_length][o%n.column_length].rem(r[t%i.row_length][o%i.column_length])},o,a)}mod(t){const n=this,i=Matrix._toMatrix(t);if(!n.isScalar()&&!i.isScalar()&&n.row_length!==i.row_length&&n.column_length!==i.column_length)throw"Matrix size does not match";const e=n.matrix_array,r=i.matrix_array,o=Math.max(n.row_length,i.row_length),a=Math.max(n.column_length,i.column_length);return Matrix.createMatrixDoEachCalculation(function(t,o){return e[t%n.row_length][o%n.column_length].mod(r[t%i.row_length][o%i.column_length])},o,a)}real(){return this.cloneMatrixDoEachCalculation(function(t){return new Complex(t.real)})}imag(){return this.cloneMatrixDoEachCalculation(function(t){return new Complex(t.imag)})}arg(){return this.cloneMatrixDoEachCalculation(function(t){return new Complex(t.arg)})}sign(){return this.cloneMatrixDoEachCalculation(function(t){return new Complex(t.sign())})}floor(){return this.cloneMatrixDoEachCalculation(function(t){return t.floor()})}ceil(){return this.cloneMatrixDoEachCalculation(function(t){return t.ceil()})}round(){return this.cloneMatrixDoEachCalculation(function(t){return t.round()})}fix(){return this.cloneMatrixDoEachCalculation(function(t){return t.fix()})}fract(){return this.cloneMatrixDoEachCalculation(function(t){return t.fract()})}abs(){return this.cloneMatrixDoEachCalculation(function(t){return t.abs()})}conj(){return this.cloneMatrixDoEachCalculation(function(t){return t.conj()})}negate(){return this.cloneMatrixDoEachCalculation(function(t){return t.negate()})}pow(t){if(this.isScalar())return new Matrix(this.scalar.pow(Matrix._toDouble(t)));{if(!this.isSquare())throw"not square "+this;let n=Matrix._toInteger(t);if(n<0)throw"error negative number "+n;let i,e;for(i=this.clone(),e=Matrix.eye(this.length);0!==n;)0!=(1&n)&&(e=e.mul(i)),i=i.mul(i),n>>>=1;return e}}dotpow(t){const n=this,i=Matrix._toMatrix(t);if(!n.isScalar()&&!i.isScalar()&&n.row_length!==i.row_length&&n.column_length!==i.column_length)throw"Matrix size does not match";const e=n.matrix_array,r=i.matrix_array,o=Math.max(n.row_length,i.row_length),a=Math.max(n.column_length,i.column_length);return Matrix.createMatrixDoEachCalculation(function(t,o){return e[t%n.row_length][o%n.column_length].pow(r[t%i.row_length][o%i.column_length])},o,a)}square(){return this.pow(2)}sqrt(){return this.cloneMatrixDoEachCalculation(function(t){return t.sqrt()})}cbrt(){return this.cloneMatrixDoEachCalculation(function(t){return t.cbrt()})}rsqrt(){return this.cloneMatrixDoEachCalculation(function(t){return t.rsqrt()})}log(){return this.cloneMatrixDoEachCalculation(function(t){return t.log()})}exp(){return this.cloneMatrixDoEachCalculation(function(t){return t.exp()})}expm1(){return this.cloneMatrixDoEachCalculation(function(t){return t.expm1()})}log1p(){return this.cloneMatrixDoEachCalculation(function(t){return t.log1p()})}log2(){return this.cloneMatrixDoEachCalculation(function(t){return t.log2()})}log10(){return this.cloneMatrixDoEachCalculation(function(t){return t.log10()})}sin(){return this.cloneMatrixDoEachCalculation(function(t){return t.sin()})}cos(){return this.cloneMatrixDoEachCalculation(function(t){return t.cos()})}tan(){return this.cloneMatrixDoEachCalculation(function(t){return t.tan()})}atan(){return this.cloneMatrixDoEachCalculation(function(t){return t.atan()})}atan2(t){const n=Matrix._toComplex(t);return this.cloneMatrixDoEachCalculation(function(t){return t.atan2(n)})}asin(){return this.cloneMatrixDoEachCalculation(function(t){return t.asin()})}acos(){return this.cloneMatrixDoEachCalculation(function(t){return t.acos()})}sinh(){return this.cloneMatrixDoEachCalculation(function(t){return t.sinh()})}asinh(){return this.cloneMatrixDoEachCalculation(function(t){return t.asinh()})}cosh(){return this.cloneMatrixDoEachCalculation(function(t){return t.cosh()})}acosh(){return this.cloneMatrixDoEachCalculation(function(t){return t.acosh()})}tanh(){return this.cloneMatrixDoEachCalculation(function(t){return t.tanh()})}atanh(){return this.cloneMatrixDoEachCalculation(function(t){return t.atanh()})}sec(){return this.cloneMatrixDoEachCalculation(function(t){return t.sec()})}asec(){return this.cloneMatrixDoEachCalculation(function(t){return t.asec()})}sech(){return this.cloneMatrixDoEachCalculation(function(t){return t.sech()})}asech(){return this.cloneMatrixDoEachCalculation(function(t){return t.asech()})}cot(){return this.cloneMatrixDoEachCalculation(function(t){return t.cot()})}acot(){return this.cloneMatrixDoEachCalculation(function(t){return t.acot()})}coth(){return this.cloneMatrixDoEachCalculation(function(t){return t.coth()})}acoth(){return this.cloneMatrixDoEachCalculation(function(t){return t.acoth()})}csc(){return this.cloneMatrixDoEachCalculation(function(t){return t.csc()})}acsc(){return this.cloneMatrixDoEachCalculation(function(t){return t.acsc()})}csch(){return this.cloneMatrixDoEachCalculation(function(t){return t.csch()})}acsch(){return this.cloneMatrixDoEachCalculation(function(t){return t.acsch()})}logit(){return this.cloneMatrixDoEachCalculation(function(t){return t.logit()})}sinc(){return this.cloneMatrixDoEachCalculation(function(t){return t.sinc()})}static rand(t,n,i){return Matrix.createMatrixDoEachCalculation(function(){return Complex.rand(i)},t,n)}static randn(t,n,i){return Matrix.createMatrixDoEachCalculation(function(){return Complex.randn(i)},t,n)}testInteger(t){return this.cloneMatrixDoEachCalculation(function(n){return n.isInteger(t)?Complex.ONE:Complex.ZERO})}testComplexInteger(t){return this.cloneMatrixDoEachCalculation(function(n){return n.isComplexInteger(t)?Complex.ONE:Complex.ZERO})}testZero(t){return this.cloneMatrixDoEachCalculation(function(n){return n.isZero(t)?Complex.ONE:Complex.ZERO})}testOne(t){return this.cloneMatrixDoEachCalculation(function(n){return n.isOne(t)?Complex.ONE:Complex.ZERO})}testComplex(t){return this.cloneMatrixDoEachCalculation(function(n){return n.isComplex(t)?Complex.ONE:Complex.ZERO})}testReal(t){return this.cloneMatrixDoEachCalculation(function(n){return n.isReal(t)?Complex.ONE:Complex.ZERO})}testNaN(){return this.cloneMatrixDoEachCalculation(function(t){return t.isNaN()?Complex.ONE:Complex.ZERO})}testPositive(){return this.cloneMatrixDoEachCalculation(function(t){return t.isPositive()?Complex.ONE:Complex.ZERO})}testNegative(){return this.cloneMatrixDoEachCalculation(function(t){return t.isNegative()?Complex.ONE:Complex.ZERO})}testNotNegative(){return this.cloneMatrixDoEachCalculation(function(t){return t.isNotNegative()?Complex.ONE:Complex.ZERO})}testPositiveInfinity(){return this.cloneMatrixDoEachCalculation(function(t){return t.isPositiveInfinity()?Complex.ONE:Complex.ZERO})}testNegativeInfinity(){return this.cloneMatrixDoEachCalculation(function(t){return t.isNegativeInfinity()?Complex.ONE:Complex.ZERO})}testInfinite(){return this.cloneMatrixDoEachCalculation(function(t){return t.isInfinite()?Complex.ONE:Complex.ZERO})}testFinite(){return this.cloneMatrixDoEachCalculation(function(t){return t.isFinite()?Complex.ONE:Complex.ZERO})}isZero(t){return this.scalar.isZero(t)}isOne(t){return this.scalar.isOne(t)}isPositive(){return this.scalar.isPositive()}isNegative(){return this.scalar.isNegative()}isNotNegative(){return this.scalar.isNotNegative()}isNaN(){return this.scalar.isNaN()}isPositiveInfinity(){return this.scalar.isPositiveInfinity()}isNegativeInfinity(){return this.scalar.isNegativeInfinity()}isInfinite(){return this.scalar.isInfinite()}isFinite(){return this.scalar.isFinite()}isInteger(t){return this.scalar.isInteger(t)}isComplexInteger(t){return this.scalar.isComplexInteger(t)}_rot90(t){const n=Matrix._toInteger(t);let i=1;if(1===arguments.length&&(i=(n%4+4)%4),0===i)return this;const e=new Array(this.row_length);for(let t=0;t<this.row_length;t++){e[t]=new Array(this.column_length);for(let n=0;n<this.column_length;n++)e[t][n]=this.matrix_array[t][n]}const r=this.matrix_array;if(1===i){r.splice(this.column_length);for(let t=0;t<this.column_length;t++){t<this.row_length?r[t].splice(this.row_length):r[t]=new Array(this.row_length);for(let n=0;n<this.row_length;n++)r[t][n]=e[this.row_length-n-1][t]}}else if(2===i)for(let t=0;t<this.row_length;t++)for(let n=0;n<this.column_length;n++)r[t][n]=e[this.row_length-t-1][this.column_length-n-1];else if(3===i){r.splice(this.column_length);for(let t=0;t<this.column_length;t++){t<this.row_length?r[t].splice(this.row_length):r[t]=new Array(this.row_length);for(let n=0;n<this.row_length;n++)r[t][n]=e[n][this.column_length-t-1]}}return this.row_length=r.length,this.column_length=r[0].length,this._clearCash(),this}rot90(t){return this.clone()._rot90(t)}_resize(t,n){const i=Matrix._toInteger(t),e=Matrix._toInteger(n);if(i===this.row_length&&e===this.column_length)return this;if(i<=0||e<=0)throw"_resize";const r=Math.max(this.row_length,i),o=Math.max(this.column_length,e),a=this.matrix_array;for(let t=0;t<r;t++){t>=this.row_length&&(a[t]=new Array(o));for(let n=0;n<o;n++)(t>=this.row_length||n>=this.column_length)&&(a[t][n]=Complex.ZERO)}if(this.row_length>i&&a.splice(i),this.column_length>e)for(let t=0;t<a.length;t++)a[t].splice(e);return this.row_length=i,this.column_length=e,this._clearCash(),this}resize(t,n){return this.clone()._resize(t,n)}_deleteRow(t){const n=Matrix._toInteger(t);if(1===this.row_length||this.row_length<=n)throw"_deleteRow";return this.matrix_array.splice(n,1),this.row_length--,this._clearCash(),this}_deleteColumn(t){const n=Matrix._toInteger(t);if(1===this.column_length||this.column_length<=n)throw"_deleteColumn";for(let t=0;t<this.row_length;t++)this.matrix_array[t].splice(n,1);return this.column_length--,this._clearCash(),this}deleteRow(t){return this.clone()._deleteRow(t)}deleteColumn(t){return this.clone()._deleteColumn(t)}_exchangeRow(t,n){const i=Matrix._toInteger(t),e=Matrix._toInteger(n);if(1===this.row_length||this.row_length<=i||this.row_length<=e)throw"_exchangeRow";if(i===e)return this;const r=this.matrix_array[i];return this.matrix_array[i]=this.matrix_array[e],this.matrix_array[e]=r,this._clearCash(),this}_exchangeColumn(t,n){const i=Matrix._toInteger(t),e=Matrix._toInteger(n);if(1===this.column_length||this.column_length<=i||this.column_length<=e)throw"_exchangeColumn";if(i===e)return this;for(let t=0;t<this.row_length;t++){const n=this.matrix_array[t][i];this.matrix_array[t][i]=this.matrix_array[t][e],this.matrix_array[t][e]=n}return this._clearCash(),this}exchangeRow(t,n){return this.clone()._exchangeRow(t,n)}exchangeColumn(t,n){return this.clone()._exchangeColumn(t,n)}_concatRight(t){const n=Matrix._toMatrix(t);if(this.row_length!=n.row_length)throw"_concatRight";for(let t=0;t<this.row_length;t++)for(let i=0;i<n.column_length;i++)this.matrix_array[t].push(n.matrix_array[t][i]);return this.column_length+=n.column_length,this._clearCash(),this}_concatBottom(t){const n=Matrix._toMatrix(t);if(this.column_length!=n.column_length)throw"_concatBottom";for(let t=0;t<n.row_length;t++)this.matrix_array.push(n.matrix_array[t]);return this.row_length+=n.row_length,this._clearCash(),this}concatRight(t){return this.clone()._concatRight(t)}concatBottom(t){return this.clone()._concatBottom(t)}clip(t,n){const i=Matrix._toMatrix(t),e=Matrix._toMatrix(n),r=i.matrix_array,o=e.matrix_array;return this.cloneMatrixDoEachCalculation(function(t,n,a){const s=r[n%i.row_length][a%i.column_length],u=o[n%e.row_length][a%e.column_length];return t.clip(s,u)})}static arange(t,n,i){const e=void 0!==n?Matrix._toComplex(t):Complex.ZERO,r=void 0!==n?Matrix._toComplex(n):Matrix._toComplex(t),o=void 0!==i?Matrix._toComplex(i):Complex.ONE;return new Matrix(MatrixTool.InterpolationCalculation(e,o,r,!1))}circshift(t,n){const i=Matrix._toInteger(t),e=n&&n.dimension?n.dimension:"auto",r=function(t){const n=new Array(t.length);let e=(-i%t.length+t.length)%t.length;for(let i=0;i<t.length;i++)n[i]=t[e++],e===t.length&&(e=0);return n};return this.eachVector(r,e)}roll(t,n){return this.circshift(t,n)}reshape(t,n){const i=Matrix._toInteger(t),e=Matrix._toInteger(n),r=this.row_length*this.column_length,o=i*e;if(r!==o)throw"reshape error. (this_size !== new_size)->("+r+" !== "+o+")";const a=this.matrix_array;let s=0,u=0;const c=new Array(i);for(let t=0;t<i;t++){c[t]=new Array(e);for(let n=0;n<e;n++)c[t][n]=a[u][s],++s===this.column_length&&(s=0,u++)}return new Matrix(c)}fliplr(){return this.flip({dimension:"row"})}flipud(){return this.flip({dimension:"column"})}flip(t){const n=t&&t.dimension?t.dimension:"auto",i=function(t){const n=new Array(t.length);for(let i=0,e=t.length-1;i<t.length;i++,e--)n[i]=t[e];return n};return this.eachVector(i,n)}indexsort(t){const n=Matrix._toMatrix(t);if(n.isMatrix())throw"argsort error. argsort is not vector. ("+n.toOneLineString+")";let i=!1,e=null,r=null;if(n.isRow()){if(this.column_length!==n.column_length)throw"argsort error. (this_size !== new_size)->("+this.column_length+" !== "+n.column_length+")";i=!0,e=this.transpose().matrix_array,r=n.matrix_array[0]}if(n.isColumn()){if(this.row_length!==n.row_length)throw"argsort error. (this_size !== new_size)->("+this.row_length+" !== "+n.row_length+")";e=this.matrix_array,r=n.transpose().matrix_array[0]}const o=new Array(r.length);for(let t=0;t<r.length;t++)o[t]={index:r[t],data:e[t]};const a=function(t,n){return t.index.compareTo(n.index)};{const t=[],n=function(i,e,r,o){if(e<r){const a=Math.floor((e+r)/2);n(i,e,a,o),n(i,a+1,r,o);let s,u,c,l=0;for(s=e;s<=a;s++)t[l++]=i[s];for(s=a+1,u=0,c=e;s<=r&&u<l;)o(i[s],t[u])>=0?i[c++]=t[u++]:i[c++]=i[s++];for(;u<l;)i[c++]=t[u++]}return!0};n(o,0,o.length-1,a)}const s=new Array(r.length);for(let t=0;t<r.length;t++)s[t]=o[t].data;const u=new Matrix(s);return i?u.transpose():u}transpose(){const t=new Array(this.column_length);for(let n=0;n<this.column_length;n++){t[n]=new Array(this.row_length);for(let i=0;i<this.row_length;i++)t[n][i]=this.matrix_array[i][n]}return new Matrix(t)}ctranspose(){return this.transpose().conj()}T(){return this.ctranspose()}inner(t,n=1){return LinearAlgebra.inner(this,t,n)}lup(){return LinearAlgebra.lup(this)}lu(){return LinearAlgebra.lu(this)}linsolve(t){return LinearAlgebra.linsolve(this,t)}qr(){return LinearAlgebra.qr(this)}tridiagonalize(){return LinearAlgebra.tridiagonalize(this)}eig(){return LinearAlgebra.eig(this)}svd(){return LinearAlgebra.svd(this)}pinv(){return LinearAlgebra.pinv(this)}gammaln(){return this.cloneMatrixDoEachCalculation(function(t){return t.gammaln()})}gamma(){return this.cloneMatrixDoEachCalculation(function(t){return t.gamma()})}gammainc(t,n){const i=Matrix._toDouble(t);return this.cloneMatrixDoEachCalculation(function(t){return t.gammainc(i,n)})}gampdf(t,n){const i=Matrix._toDouble(t),e=Matrix._toDouble(n);return this.cloneMatrixDoEachCalculation(function(t){return t.gampdf(i,e)})}gamcdf(t,n){const i=Matrix._toDouble(t),e=Matrix._toDouble(n);return this.cloneMatrixDoEachCalculation(function(t){return t.gamcdf(i,e)})}gaminv(t,n){const i=Matrix._toDouble(t),e=Matrix._toDouble(n);return this.cloneMatrixDoEachCalculation(function(t){return t.gaminv(i,e)})}beta(t){const n=Matrix._toDouble(t);return this.cloneMatrixDoEachCalculation(function(t){return t.beta(n)})}betainc(t,n,i){const e=Matrix._toDouble(t),r=Matrix._toDouble(n);return this.cloneMatrixDoEachCalculation(function(t){return t.betainc(e,r,i)})}betacdf(t,n){const i=Matrix._toDouble(t),e=Matrix._toDouble(n);return this.cloneMatrixDoEachCalculation(function(t){return t.betacdf(i,e)})}betapdf(t,n){const i=Matrix._toDouble(t),e=Matrix._toDouble(n);return this.cloneMatrixDoEachCalculation(function(t){return t.betapdf(i,e)})}betainv(t,n){const i=Matrix._toDouble(t),e=Matrix._toDouble(n);return this.cloneMatrixDoEachCalculation(function(t){return t.betainv(i,e)})}factorial(){return this.cloneMatrixDoEachCalculation(function(t){return t.factorial()})}nchoosek(t){const n=Matrix._toDouble(t);return this.cloneMatrixDoEachCalculation(function(t){return t.nchoosek(n)})}erf(){return this.cloneMatrixDoEachCalculation(function(t){return t.erf()})}erfc(){return this.cloneMatrixDoEachCalculation(function(t){return t.erfc()})}erfinv(){return this.cloneMatrixDoEachCalculation(function(t){return t.erfinv()})}erfcinv(){return this.cloneMatrixDoEachCalculation(function(t){return t.erfcinv()})}normpdf(t,n){const i=void 0!==t?Matrix._toDouble(t):0,e=void 0!==n?Matrix._toDouble(n):1;return this.cloneMatrixDoEachCalculation(function(t){return t.normpdf(i,e)})}normcdf(t,n){const i=void 0!==t?Matrix._toDouble(t):0,e=void 0!==n?Matrix._toDouble(n):1;return this.cloneMatrixDoEachCalculation(function(t){return t.normcdf(i,e)})}norminv(t,n){const i=void 0!==t?Matrix._toDouble(t):0,e=void 0!==n?Matrix._toDouble(n):1;return this.cloneMatrixDoEachCalculation(function(t){return t.norminv(i,e)})}binopdf(t,n){const i=Matrix._toDouble(t),e=Matrix._toDouble(n);return this.cloneMatrixDoEachCalculation(function(t){return t.binopdf(i,e)})}binocdf(t,n,i){const e=Matrix._toDouble(t),r=Matrix._toDouble(n);return this.cloneMatrixDoEachCalculation(function(t){return t.binocdf(e,r,i)})}binoinv(t,n){const i=Matrix._toDouble(t),e=Matrix._toDouble(n);return this.cloneMatrixDoEachCalculation(function(t){return t.binoinv(i,e)})}poisspdf(t){const n=Matrix._toDouble(t);return this.cloneMatrixDoEachCalculation(function(t){return t.poisspdf(n)})}poisscdf(t){const n=Matrix._toDouble(t);return this.cloneMatrixDoEachCalculation(function(t){return t.poisscdf(n)})}poissinv(t){const n=Matrix._toDouble(t);return this.cloneMatrixDoEachCalculation(function(t){return t.poissinv(n)})}tpdf(t){const n=Matrix._toDouble(t);return this.cloneMatrixDoEachCalculation(function(t){return t.tpdf(n)})}tcdf(t){const n=Matrix._toDouble(t);return this.cloneMatrixDoEachCalculation(function(t){return t.tcdf(n)})}tinv(t){const n=Matrix._toDouble(t);return this.cloneMatrixDoEachCalculation(function(t){return t.tinv(n)})}tdist(t,n){const i=Matrix._toDouble(t),e=Matrix._toDouble(n);return this.cloneMatrixDoEachCalculation(function(t){return t.tdist(i,e)})}tinv2(t){const n=Matrix._toDouble(t);return this.cloneMatrixDoEachCalculation(function(t){return t.tinv2(n)})}chi2pdf(t){const n=Matrix._toDouble(t);return this.cloneMatrixDoEachCalculation(function(t){return t.chi2pdf(n)})}chi2cdf(t){const n=Matrix._toDouble(t);return this.cloneMatrixDoEachCalculation(function(t){return t.chi2cdf(n)})}chi2inv(t){const n=Matrix._toDouble(t);return this.cloneMatrixDoEachCalculation(function(t){return t.chi2inv(n)})}fpdf(t,n){const i=Matrix._toDouble(t),e=Matrix._toDouble(n);return this.cloneMatrixDoEachCalculation(function(t){return t.fpdf(i,e)})}fcdf(t,n){const i=Matrix._toDouble(t),e=Matrix._toDouble(n);return this.cloneMatrixDoEachCalculation(function(t){return t.fcdf(i,e)})}finv(t,n){const i=Matrix._toDouble(t),e=Matrix._toDouble(n);return this.cloneMatrixDoEachCalculation(function(t){return t.finv(i,e)})}and(t){return this.cloneMatrixDoEachCalculation(function(n){return n.and(Matrix._toDouble(t))})}or(t){return this.cloneMatrixDoEachCalculation(function(n){return n.or(Matrix._toDouble(t))})}xor(t){return this.cloneMatrixDoEachCalculation(function(n){return n.xor(Matrix._toDouble(t))})}not(){return this.cloneMatrixDoEachCalculation(function(t){return t.not()})}shift(t){return this.cloneMatrixDoEachCalculation(function(n){return n.shift(Matrix._toDouble(t))})}factor(){const t=this.scalar.factor(),n=[];for(let i=0;i<t.length;i++)n.push(new Matrix(t[i]));return n}gcd(t){return this.cloneMatrixDoEachCalculation(function(n){return n.gcd(Matrix._toDouble(t))})}extgcd(t){if(!this.isScalar())throw"IllegalArgumentException";const n=this.scalar,i=Matrix._toDouble(t),e=n.extgcd(i);return[new Matrix(e[0]),new Matrix(e[1]),new Matrix(e[2])]}lcm(t){return this.cloneMatrixDoEachCalculation(function(n){return n.lcm(Matrix._toDouble(t))})}modPow(t,n){return this.cloneMatrixDoEachCalculation(function(i){return i.modPow(Matrix._toDouble(t),Matrix._toDouble(n))})}modInverse(t){return this.cloneMatrixDoEachCalculation(function(n){return n.modInverse(Matrix._toDouble(t))})}scaleByPowerOfTen(t){return this.cloneMatrixDoEachCalculation(function(n){return n.scaleByPowerOfTen(Matrix._toComplex(t))})}testPrime(){return this.cloneMatrixDoEachCalculation(function(t){return t.isPrime()?Complex.ONE:Complex.ZERO})}testProbablePrime(t){const n=void 0!==t?Math.round(Matrix._toDouble(t)):void 0;return this.cloneMatrixDoEachCalculation(function(t){return t.isProbablePrime(n)?Complex.ONE:Complex.ZERO})}nextProbablePrime(t,n){const i=void 0!==t?Math.round(Matrix._toDouble(t)):void 0,e=void 0!==n?Math.round(Matrix._toDouble(n)):void 0;return this.cloneMatrixDoEachCalculation(function(t){return t.nextProbablePrime(i,e)})}isPrime(){return this.scalar.isPrime()}isProbablePrime(t){return this.scalar.isProbablePrime(t)}max(t){return Statistics.max(this,t)}min(t){return Statistics.min(this,t)}sum(t){return Statistics.sum(this,t)}mean(t){return Statistics.mean(this,t)}prod(t){return Statistics.prod(this,t)}geomean(t){return Statistics.geomean(this,t)}median(t){return Statistics.median(this,t)}mode(t){return Statistics.mode(this,t)}moment(t,n){return Statistics.moment(this,t,n)}var(t){return Statistics.var(this,t)}std(t){return Statistics.std(this,t)}mad(t,n){return Statistics.mad(this,t,n)}skewness(t){return Statistics.skewness(this,t)}cov(t,n){return Statistics.cov(this,t,n)}standardization(t){return Statistics.standardization(this,t)}corrcoef(t,n){return Statistics.corrcoef(this,t,n)}sort(t,n){return Statistics.sort(this,t,n)}fft(t){return Signal.fft(this,t)}ifft(t){return Signal.ifft(this,t)}powerfft(t){return Signal.powerfft(this,t)}dct(t){return Signal.dct(this,t)}idct(t){return Signal.idct(this,t)}fft2(){return Signal.fft2(this)}ifft2(){return Signal.ifft2(this)}dct2(){return Signal.dct2(this)}idct2(){return Signal.idct2(this)}conv(t){return Signal.conv(this,t)}xcorr(t){return Signal.xcorr(this,t)}static window(t,n,i){return Signal.window(t,n,i)}static hann(t,n){return Signal.hann(t,n)}static hamming(t,n){return Signal.hamming(t,n)}fftshift(t){return Signal.fftshift(this,t)}static get ONE(){return new Matrix(1)}static get TWO(){return new Matrix(2)}static get TEN(){return new Matrix(10)}static get ZERO(){return new Matrix(0)}static get MINUS_ONE(){return new Matrix(-1)}static get I(){return new Matrix(Complex.I)}static get PI(){return new Matrix(Math.PI)}static get QUARTER_PI(){return new Matrix(.25*Math.PI)}static get HALF_PI(){return new Matrix(.5*Math.PI)}static get TWO_PI(){return new Matrix(2*Math.PI)}static get E(){return new Matrix(Math.E)}static get LN2(){return new Matrix(Math.LN2)}static get LN10(){return new Matrix(Math.LN10)}static get LOG2E(){return new Matrix(Math.LOG2E)}static get LOG10E(){return new Matrix(Math.LOG10E)}static get SQRT2(){return new Matrix(Math.SQRT2)}static get SQRT1_2(){return new Matrix(Math.SQRT1_2)}static get HALF(){return new Matrix(.5)}static get POSITIVE_INFINITY(){return new Matrix(Number.POSITIVE_INFINITY)}static get NEGATIVE_INFINITY(){return new Matrix(Number.NEGATIVE_INFINITY)}static get NaN(){return new Matrix(Number.NaN)}signum(){return this.sign()}subtract(t){return this.sub(t)}multiply(t){return this.mul(t)}divide(t){return this.div(t)}remainder(t){return this.rem(t)}trunc(){return this.fix()}}const random_class=new Random;class ComplexTool{static ToComplexFromString(t){let n=t.replace(/\s/g,"").toLowerCase();if(n=n.replace(/infinity|inf/g,"1e100000"),!/[ij]/.test(n))return{real:parseFloat(n),imag:0};let i,e=0,r=0;return(i=n.match(/[+-]?(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan))($|[+-])/))&&(e=parseFloat(i[0])),(i=n.match(/[+-]?(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan))?[ij]/))&&(i=i[0].substring(0,i[0].length-1),r=/^[-+]$/.test(i)||0===i.length?"-"===i?-1:1:parseFloat(i)),{real:e,imag:r}}}class Complex extends KonpeitoFloat{constructor(t){if(super(),1!==arguments.length)throw"Complex Many arguments : "+arguments.length;{const n=t;if(n instanceof Complex)this._re=n._re,this._im=n._im;else if("number"==typeof n)this._re=n,this._im=0;else if("string"==typeof n){const t=ComplexTool.ToComplexFromString(n);this._re=t.real,this._im=t.imag}else if(n instanceof Array){if(2!==n.length)throw"Complex Unsupported argument "+arguments;this._re=n[0],this._im=n[1]}else if("boolean"==typeof n)this._re=n?1:0,this._im=0;else if("doubleValue"in n)this._re=n.doubleValue,this._im=0;else if("_re"in n&&"_im"in n)this._re=n._re,this._im=n._im;else{if(!(n instanceof Object))throw"Complex Unsupported argument "+arguments;{const t=ComplexTool.ToComplexFromString(n.toString());this._re=t.real,this._im=t.imag}}}}static create(t){return t instanceof Complex?t:new Complex(t)}static valueOf(t){return Complex.create(t)}static _toComplex(t){return t instanceof Complex?t:t instanceof Matrix?Matrix._toComplex(t):new Complex(t)}static _toDouble(t){if("number"==typeof t)return t;const n=Complex._toComplex(t);if(n.isReal())return n.real;throw"not support complex numbers.["+t+"]"}static _toInteger(t){return Math.trunc(Complex._toDouble(t))}clone(){return this}toString(){const t=function(t){let n=t.toPrecision(6);if(-1!==n.indexOf("."))n=(n=n.replace(/\.?0+$/,"")).replace(/\.?0+e/,"e");else{if(/inf/i.test(n))return t===Number.POSITIVE_INFINITY?"Inf":"-Inf";if(/nan/i.test(n))return"NaN"}return n};return this.isReal()?t(this._re):0===this._re?t(this._im)+"i":this._im>=0||Number.isNaN(this._im)?t(this._re)+" + "+t(this._im)+"i":t(this._re)+" - "+t(-this._im)+"i"}toJSON(){return this.isReal()?this._re.toString():0===this._re?this._im.toString()+"i":this._im>=0||Number.isNaN(this._im)?this._re.toString()+"+"+this._im.toString()+"i":this._re.toString()+this._im.toString()+"i"}get real(){return this._re}get imag(){return this._im}get norm(){return 0===this._im?Math.abs(this._re):0===this._re?Math.abs(this._im):Math.sqrt(this._re*this._re+this._im*this._im)}get arg(){return 0===this._im?this._re>=0?0:Math.PI:0===this._re?Math.PI*(this._im>=0?.5:-.5):Math.atan2(this._im,this._re)}getDecimalPosition(){const t=function(t){if(!Number.isFinite(t))return 0;let n=t,i=0;for(let t=0;t<20&&!(Math.abs(n-Math.round(n))<=Number.EPSILON);t++)n*=10,i++;return i};return Math.max(t(this.real),t(this.imag))}sign(){return this.isFinite()?0===this._im?0===this._re?Complex.ZERO:new Complex(this._re>0?1:-1):this.div(this.norm):this.isNaN()||this._im===1/0||this._im===-1/0?Complex.NaN:this._re===1/0?Complex.ONE:Complex.MINUS_ONE}add(t){const n=this,i=new Complex(t);return i._re=n._re+i._re,i._im=n._im+i._im,i}sub(t){const n=this,i=new Complex(t);return i._re=n._re-i._re,i._im=n._im-i._im,i}mul(t){const n=this,i=new Complex(t);if(0===n._im&&0===i._im)return i._re=n._re*i._re,i;if(0===n._re&&0===i._re)return i._re=-n._im*i._im,i._im=0,i;{const t=n._re*i._re-n._im*i._im,e=n._im*i._re+n._re*i._im;return i._re=t,i._im=e,i}}dot(t){const n=this,i=new Complex(t);if(0===n._im&&0===i._im)return i._re=n._re*i._re,i;if(0===n._re&&0===i._re)return i._re=n._im*i._im,i._im=0,i;{const t=n._re*i._re+n._im*i._im,e=-n._im*i._re+n._re*i._im;return i._re=t,i._im=e,i}}div(t){const n=this,i=new Complex(t);if(0===n._im&&0===i._im)return i._re=n._re/i._re,i;if(0===n._re&&0===i._re)return i._re=n._im/i._im,i._im=0,i;{const t=n._re*i._re+n._im*i._im,e=n._im*i._re-n._re*i._im,r=1/(i._re*i._re+i._im*i._im);return i._re=t*r,i._im=e*r,i}}rem(t){const n=this,i=new Complex(t);if(0!==n._im||0!==i._im)throw"calculation method is undefined.";return n.isFinite()&&i.isFinite()&&!i.isZero()?(i._re=n._re-i._re*Math.trunc(n._re/i._re),i):Complex.NaN}mod(t){const n=this,i=new Complex(t);if(0!==n._im||0!==i._im)throw"calculation method is undefined.";if(i.isZero())return n;const e=n.rem(i);return n.equalsState(i)?e:e.add(i)}inv(){return 0===this._im?new Complex(1/this._re):0===this._re?new Complex([0,-1/this._im]):Complex.ONE.div(this)}get booleanValue(){return!this.isZero()&&!this.isNaN()}get intValue(){if(!this.isFinite())return this.isNaN()?NaN:this.isPositiveInfinity()?1/0:-1/0;const t=this._re;return Math.abs(t-Math.trunc(t))<Number.EPSILON?Math.round(t):Math.trunc(t)}get doubleValue(){if(!this.isFinite())return this.isNaN()?NaN:this.isPositiveInfinity()?1/0:-1/0;const t=this._re;return Math.abs(t-Math.trunc(t))<Number.EPSILON?Math.round(t):t}toBigInteger(){return new BigInteger(this.intValue)}toBigDecimal(t){return new BigDecimal(t?[this.doubleValue,t]:this.doubleValue)}toFraction(){return new Fraction(this.doubleValue)}toComplex(){return this}toMatrix(){return new Matrix(this)}equals(t,n){const i=this,e=Complex._toComplex(t);if(i.isNaN()||e.isNaN())return!1;if(i._re===e._re&&i._im===e._im)return!0;const r=n?Complex._toDouble(n):Number.EPSILON;return Math.abs(i._re-e._re)<r&&Math.abs(i._im-e._im)<r}equalsState(t){const n=this,i=Complex._toComplex(t),e=function(t){return t.isZero()?0:t.isFinite()?t.isPositive()?1:2:t.isPositiveInfinity()?4:t.isNegativeInfinity()?5:3};return e(n)===e(i)}compareTo(t,n){const i=this,e=Complex._toComplex(t);if(!i.isFinite()||!e.isFinite())return i.equals(e)?0:i.isNaN()||e.isNaN()||i.real===1/0&&i.imag===-1/0||i.real===-1/0&&i.imag===1/0||e.real===1/0&&e.imag===-1/0||e.real===-1/0&&e.imag===1/0?NaN:i.isFinite()?e.real+e.imag<0?1:-1:e.isFinite()?i.real+i.imag>0?1:-1:NaN;const r=n?Complex._toDouble(n):Number.EPSILON,o=i.real+i.imag,a=e.real+e.imag;return Math.abs(o-a)<=r?0:o>a?1:-1}max(t){const n=Complex._toComplex(t);return this.compareTo(n)>=0?this:n}min(t){const n=Complex._toComplex(t);return this.compareTo(n)<=0?this:n}clip(t,n){const i=Complex._toComplex(t),e=Complex._toComplex(n),r=i.compareTo(e);if(1===r)throw"clip(min, max) error. (min > max)->("+i+" > "+e+")";return 0===r?i:1===this.compareTo(e)?e:-1===this.compareTo(i)?i:this}floor(){return new Complex([Math.floor(this._re),Math.floor(this._im)])}ceil(){return new Complex([Math.ceil(this._re),Math.ceil(this._im)])}round(){return new Complex([Math.round(this._re),Math.round(this._im)])}fix(){return new Complex([Math.trunc(this._re),Math.trunc(this._im)])}fract(){return new Complex([this._re-Math.floor(this._re),this._im-Math.floor(this._im)])}abs(){return new Complex(this.norm)}conj(){return 0===this._im?this:new Complex([this._re,-this._im])}negate(){return new Complex([-this._re,-this._im])}pow(t){const n=this,i=new Complex(t);if(i.isReal()){if(n.isReal()&&(n.isNotNegative()||i.isInteger()))return i._re=Math.pow(n._re,i._re),i;{const t=Math.pow(n.norm,i._re),e=n.arg*i._re;return i._re=t*Math.cos(e),i._im=t*Math.sin(e),i}}return i.mul(n.log()).exp()}square(){return 0===this._im?new Complex(this._re*this._re):this.mul(this)}sqrt(){if(this.isReal())return new Complex(this.isNotNegative()?Math.sqrt(this._re):[0,Math.sqrt(-this._re)]);const t=Math.sqrt(this.norm),n=.5*this.arg;return new Complex([t*Math.cos(n),t*Math.sin(n)])}cbrt(t){const n=Complex._toInteger(void 0!==t?t:0),i=this.log().div(3).exp();return 0===n?i:1===n?i.mul([-.5,.5*Math.sqrt(3)]):i.mul([-.5,.5*-Math.sqrt(3)])}rsqrt(){return this.isReal()?new Complex(this.isNotNegative()?1/Math.sqrt(this._re):[0,-1/Math.sqrt(-this._re)]):this.sqrt().inv()}log(){return new Complex(this.isReal()&&this.isNotNegative()?Math.log(this._re):[Math.log(this.norm),this.arg])}exp(){if(this.isReal())return new Complex(Math.exp(this._re));const t=Math.exp(this._re);return new Complex([t*Math.cos(this._im),t*Math.sin(this._im)])}expm1(){return this.exp().sub(1)}log1p(){return this.add(1).log()}log2(){return this.log().div(Complex.LN2)}log10(){return this.log().div(Complex.LN10)}sin(){if(this.isReal())return new Complex(Math.sin(this._re));const t=this.mul(Complex.I).exp(),n=this.mul(Complex.I.negate()).exp();return t.sub(n).div([0,2])}cos(){if(this.isReal())return new Complex(Math.cos(this._re));const t=this.mul(Complex.I).exp(),n=this.mul(Complex.I.negate()).exp();return t.add(n).div(2)}tan(){return this.isReal()?new Complex(Math.tan(this._re)):this.sin().div(this.cos())}atan(){return this.isReal()?new Complex(Math.atan(this._re)):Complex.I.div(Complex.TWO).mul(Complex.I.add(this).div(Complex.I.sub(this)).log())}atan2(t){if(0===arguments.length)return new Complex(this.arg);const n=this,i=Complex._toComplex(t);if(n.isReal()&&i.isReal())return new Complex(Math.atan2(n._re,i._re));throw"calculation method is undefined."}asin(){return this.mul(Complex.I).add(Complex.ONE.sub(this.square()).sqrt()).log().mul(Complex.MINUS_I)}acos(){return this.add(Complex.I.mul(Complex.ONE.sub(this.square()).sqrt())).log().mul(Complex.MINUS_I)}sinh(){const t=this.exp();return t.sub(t.inv()).mul(.5)}asinh(){return this.isInfinite()?this:this.add(this.mul(this).add(1).sqrt()).log()}cosh(){return this.exp().add(this.negate().exp()).mul(.5)}acosh(){return this.isZero()?new Complex([0,.5*Math.PI]):this.compareTo(Complex.ONE)>=1?this.add(this.square().sub(1).sqrt()).log():this.sub(this.square().sub(1).sqrt()).log()}tanh(){if(this.isNaN())return Complex.NaN;const t=this.mul(2).exp();return t.isZero()?Complex.MINUS_ONE:t.isPositiveInfinity()?Complex.ONE:t.sub(1).div(t.add(1))}atanh(){return this.isInfinite()&&this.isReal()?new Complex([0,.5*Math.PI]):this.add(1).div(this.negate().add(1)).log().mul(.5)}sec(){return this.cos().inv()}asec(){return this.inv().acos()}sech(){return this.exp().add(this.negate().exp()).inv().mul(2)}asech(){return this.isInfinite()&&this.isReal()?new Complex([0,.5*Math.PI]):this.isPositive()||-1==this.compareTo(Complex.MINUS_ONE)?this.inv().add(this.square().inv().sub(1).sqrt()).log():this.inv().sub(this.square().inv().sub(1).sqrt()).log()}cot(){return this.tan().inv()}acot(){return this.inv().atan()}coth(){return this.isZero()?Complex.POSITIVE_INFINITY:this.tanh().inv()}acoth(){return this.isInfinite()?Complex.ZERO:this.add(1).div(this.sub(1)).log().mul(.5)}csc(){return this.sin().inv()}acsc(){return this.inv().asin()}csch(){return this.exp().sub(this.negate().exp()).inv().mul(2)}acsch(){return this.inv().add(this.square().inv().add(1).sqrt()).log()}logit(){return this.log().sub(Complex.ONE.sub(this).log())}sinc(){if(this.isReal()){if(0===this._re)return Complex.ONE;const t=Math.PI*this._re;return new Complex(Math.sin(t)/t)}const t=this.mul(Complex.PI);return new Complex(t.sin().div(t))}static rand(t){return new Complex((void 0!==t&&t instanceof Random?t:random_class).nextDouble())}static randn(t){return new Complex((void 0!==t&&t instanceof Random?t:random_class).nextGaussian())}isInteger(t){const n=t?Complex._toDouble(t):Number.EPSILON;return this.isReal()&&Math.abs(this._re-Math.trunc(this._re))<n}isComplexInteger(t){const n=t?Complex._toDouble(t):Number.EPSILON;return Math.abs(this._re-Math.trunc(this._re))<n&&Math.abs(this._im-Math.trunc(this._im))<n}isZero(t){const n=t?Complex._toDouble(t):Number.EPSILON;return Math.abs(this._re)<n&&Math.abs(this._im)<n}isOne(t){const n=t?Complex._toDouble(t):Number.EPSILON;return Math.abs(this._re-1)<n&&Math.abs(this._im)<n}isComplex(t){const n=t?Complex._toDouble(t):Number.EPSILON;return Math.abs(this._im)>=n}isReal(t){const n=t?Complex._toDouble(t):Number.EPSILON;return Math.abs(this._im)<n}isNaN(){return isNaN(this._re)||isNaN(this._im)}isPositive(){return 0<this._re}isNegative(){return 0>this._re}isNotNegative(){return 0<=this._re}isPositiveInfinity(){return this._re===Number.POSITIVE_INFINITY||this._im===Number.POSITIVE_INFINITY}isNegativeInfinity(){return this._re===Number.NEGATIVE_INFINITY||this._im===Number.NEGATIVE_INFINITY}isInfinite(){return this.isPositiveInfinity()||this.isNegativeInfinity()}isFinite(){return!this.isNaN()&&!this.isInfinite()}gammaln(){return new Complex(Probability.gammaln(this._re))}gamma(){return new Complex(Probability.gamma(this._re))}gammainc(t,n){const i=Complex._toDouble(t);return new Complex(Probability.gammainc(this._re,i,n))}gampdf(t,n){const i=Complex._toDouble(t),e=Complex._toDouble(n);return new Complex(Probability.gampdf(this._re,i,e))}gamcdf(t,n){const i=Complex._toDouble(t),e=Complex._toDouble(n);return new Complex(Probability.gamcdf(this._re,i,e))}gaminv(t,n){const i=Complex._toDouble(t),e=Complex._toDouble(n);return new Complex(Probability.gaminv(this._re,i,e))}beta(t){const n=Complex._toDouble(t);return new Complex(Probability.beta(this._re,n))}betainc(t,n,i){const e=Complex._toDouble(t),r=Complex._toDouble(n);return new Complex(Probability.betainc(this._re,e,r,i))}betapdf(t,n){const i=Complex._toDouble(t),e=Complex._toDouble(n);return new Complex(Probability.betapdf(this._re,i,e))}betacdf(t,n){const i=Complex._toDouble(t),e=Complex._toDouble(n);return new Complex(Probability.betacdf(this._re,i,e))}betainv(t,n){const i=Complex._toDouble(t),e=Complex._toDouble(n);return new Complex(Probability.betainv(this._re,i,e))}factorial(){return new Complex(Probability.factorial(this._re))}nchoosek(t){const n=Complex._toDouble(t);return new Complex(Probability.nchoosek(this._re,n))}erf(){return new Complex(Probability.erf(this._re))}erfc(){return new Complex(Probability.erfc(this._re))}erfinv(){return new Complex(Probability.erfinv(this._re))}erfcinv(){return new Complex(Probability.erfcinv(this._re))}normpdf(t,n){const i=void 0!==t?Complex._toDouble(t):0,e=void 0!==n?Complex._toDouble(n):1;return new Complex(Probability.normpdf(this._re,i,e))}normcdf(t,n){const i=void 0!==t?Complex._toDouble(t):0,e=void 0!==n?Complex._toDouble(n):1;return new Complex(Probability.normcdf(this._re,i,e))}norminv(t,n){const i=void 0!==t?Complex._toDouble(t):0,e=void 0!==n?Complex._toDouble(n):1;return new Complex(Probability.norminv(this._re,i,e))}binopdf(t,n){const i=Complex._toDouble(t),e=Complex._toDouble(n);return new Complex(Probability.binopdf(this._re,i,e))}binocdf(t,n,i){const e=Complex._toDouble(t),r=Complex._toDouble(n);return new Complex(Probability.binocdf(this._re,e,r,i))}binoinv(t,n){const i=Complex._toDouble(t),e=Complex._toDouble(n);return new Complex(Probability.binoinv(this._re,i,e))}poisspdf(t){const n=Complex._toDouble(t);return new Complex(Probability.poisspdf(this._re,n))}poisscdf(t){const n=Complex._toDouble(t);return new Complex(Probability.poisscdf(this._re,n))}poissinv(t){const n=Complex._toDouble(t);return new Complex(Probability.poissinv(this._re,n))}tpdf(t){const n=Complex._toDouble(t);return new Complex(Probability.tpdf(this._re,n))}tcdf(t){const n=Complex._toDouble(t);return new Complex(Probability.tcdf(this._re,n))}tinv(t){const n=Complex._toDouble(t);return new Complex(Probability.tinv(this._re,n))}tdist(t,n){const i=Complex._toDouble(t),e=Complex._toInteger(n);return new Complex(Probability.tdist(this._re,i,e))}tinv2(t){const n=Complex._toDouble(t);return new Complex(Probability.tinv2(this._re,n))}chi2pdf(t){const n=Complex._toDouble(t);return new Complex(Probability.chi2pdf(this._re,n))}chi2cdf(t){const n=Complex._toDouble(t);return new Complex(Probability.chi2cdf(this._re,n))}chi2inv(t){const n=Complex._toDouble(t);return new Complex(Probability.chi2inv(this._re,n))}fpdf(t,n){const i=Complex._toDouble(t),e=Complex._toDouble(n);return new Complex(Probability.fpdf(this._re,i,e))}fcdf(t,n){const i=Complex._toDouble(t),e=Complex._toDouble(n);return new Complex(Probability.fcdf(this._re,i,e))}finv(t,n){const i=Complex._toDouble(t),e=Complex._toDouble(n);return new Complex(Probability.finv(this._re,i,e))}and(t){const n=Math.round(this.real),i=Math.round(Complex._toDouble(t));return new Complex(n&i)}or(t){const n=Math.round(this.real),i=Math.round(Complex._toDouble(t));return new Complex(n|i)}xor(t){const n=Math.round(this.real),i=Math.round(Complex._toDouble(t));return new Complex(n^i)}not(){const t=Math.round(this.real);return new Complex(!t)}shift(t){const n=Math.round(this.real),i=Math.round(Complex._toDouble(t));return new Complex(n<<i)}factor(){const t=this.round().toBigInteger().factor(),n=[];for(let i=0;i<t.length;i++)n.push(new Complex(t[i]));return n}gcd(t){const n=Math.round(this.real),i=Math.round(Complex._toDouble(t)),e=new BigInteger(n).gcd(i);return new Complex(e)}extgcd(t){const n=Math.round(this.real),i=Math.round(Complex._toDouble(t)),e=new BigInteger(n).extgcd(i);return[new Complex(e[0]),new Complex(e[1]),new Complex(e[2])]}lcm(t){const n=Math.round(this.real),i=Math.round(Complex._toDouble(t)),e=new BigInteger(n).lcm(i);return new Complex(e)}modPow(t,n){const i=Math.round(this.real),e=Math.round(Complex._toDouble(t)),r=Math.round(Complex._toDouble(n)),o=new BigInteger(i).modPow(e,r);return new Complex(o)}modInverse(t){const n=Math.round(this.real),i=Math.round(Complex._toDouble(t)),e=new BigInteger(n).modInverse(i);return new Complex(e)}scaleByPowerOfTen(t){return this.mul(Complex.TEN.pow(t))}isPrime(){return new BigInteger(Math.round(this.real)).isPrime()}isProbablePrime(t){return new BigInteger(Math.round(this.real)).isProbablePrime(void 0!==t?Math.round(Complex._toDouble(t)):void 0)}nextProbablePrime(t,n){const i=new BigInteger(Math.round(this.real)),e=void 0!==t?Math.round(Complex._toDouble(t)):void 0,r=void 0!==n?Math.round(Complex._toDouble(n)):void 0;return new Complex(i.nextProbablePrime(e,r))}static get ONE(){return DEFINE$1.ONE}static get TWO(){return DEFINE$1.TWO}static get TEN(){return DEFINE$1.TEN}static get ZERO(){return DEFINE$1.ZERO}static get MINUS_ONE(){return DEFINE$1.MINUS_ONE}static get I(){return DEFINE$1.I}static get MINUS_I(){return DEFINE$1.MINUS_I}static get PI(){return DEFINE$1.PI}static get QUARTER_PI(){return DEFINE$1.QUARTER_PI}static get HALF_PI(){return DEFINE$1.HALF_PI}static get TWO_PI(){return DEFINE$1.TWO_PI}static get E(){return DEFINE$1.E}static get LN2(){return DEFINE$1.LN2}static get LN10(){return DEFINE$1.LN10}static get LOG2E(){return DEFINE$1.LOG2E}static get LOG10E(){return DEFINE$1.LOG10E}static get SQRT2(){return DEFINE$1.SQRT2}static get SQRT1_2(){return DEFINE$1.SQRT1_2}static get HALF(){return DEFINE$1.HALF}static get POSITIVE_INFINITY(){return DEFINE$1.POSITIVE_INFINITY}static get NEGATIVE_INFINITY(){return DEFINE$1.NEGATIVE_INFINITY}static get NaN(){return DEFINE$1.NaN}signum(){return this.sign()}subtract(t){return this.sub(t)}multiply(t){return this.mul(t)}divide(t){return this.div(t)}remainder(t){return this.rem(t)}trunc(){return this.fix()}}const DEFINE$1={ZERO:new Complex(0),ONE:new Complex(1),TWO:new Complex(2),TEN:new Complex(10),MINUS_ONE:new Complex(-1),I:new Complex([0,1]),MINUS_I:new Complex([0,-1]),PI:new Complex(Math.PI),QUARTER_PI:new Complex(.25*Math.PI),HALF_PI:new Complex(.5*Math.PI),TWO_PI:new Complex(2*Math.PI),E:new Complex(Math.E),LN2:new Complex(Math.LN2),LN10:new Complex(Math.LN10),LOG2E:new Complex(Math.LOG2E),LOG10E:new Complex(Math.LOG10E),SQRT2:new Complex(Math.SQRT2),SQRT1_2:new Complex(Math.SQRT1_2),HALF:new Complex(.5),POSITIVE_INFINITY:new Complex(Number.POSITIVE_INFINITY),NEGATIVE_INFINITY:new Complex(Number.NEGATIVE_INFINITY),NaN:new Complex(Number.NaN)};class FractionTool{static to_fraction_data_from_number_string(t){let n,i=0,e=!1,r=t.replace(/\s/g,"").toLowerCase();const o=[];if(null!==(n=r.match(/^[+-]+/))&&(n=n[0],r=r.substr(n.length),-1!==n.indexOf("-")&&(e=!0,o.push("-"))),null!==(n=r.match(/^[0-9]+/))&&(n=n[0],r=r.substr(n.length),o.push(n)),0===r.length)return new Fraction([new BigInteger([o.join(""),10]),BigInteger.ONE]);let a=null;if(/[()'"[\]]/.test(r)){const t=r.match(/([^.]*)\.(\d*)[(['"](\d+)[)\]'"](.*)/);if(null===t)throw"Fraction Unsupported argument "+r;const n=t[2].length,i=t[3];r=0===n?t[1]+t[4]:t[1]+"."+t[2]+t[4];const e=new BigInteger([i,10]),o=[];for(let t=0;t<i.length;t++)o.push("9");const s=new BigInteger([o.join(""),10]);a=(a=new Fraction([e,s])).scaleByPowerOfTen(-n)}null!==(n=r.match(/^\.[0-9]+/))&&(n=n[0],r=r.substr(n.length),i+=(n=n.substr(1)).length,o.push(n)),null!==(n=r.match(/^e[+-]?[0-9]+/))&&(n=n[0].substr(1),i-=parseInt(n,10));let s=null;{let t=null,n=null;if(0===i&&(t=new BigInteger([o.join(""),10]),n=BigInteger.ONE),i<0){for(let t=0;t<-i;t++)o.push("0");t=new BigInteger([o.join(""),10]),n=BigInteger.ONE}else if(i>0){t=new BigInteger([o.join(""),10]);const e=["1"];for(let t=0;t<i;t++)e.push("0");n=new BigInteger([e.join(""),10])}s=new Fraction([t,n])}return a&&(s=e?s.sub(a):s.add(a)),s}static to_fraction_data_from_fraction_string(t){if(/nan|inf/i.test(t)){const n=new Fraction;return n.denominator=BigInteger.ONE,/nan/i.test(t)?n.numerator=BigInteger.NaN:/-/.test(t)?n.numerator=BigInteger.NEGATIVE_INFINITY:n.numerator=BigInteger.POSITIVE_INFINITY,n}if(-1===t.indexOf("/"))return FractionTool.to_fraction_data_from_number_string(t);{const n=t.split("/"),i=FractionTool.to_fraction_data_from_number_string(n[0]),e=FractionTool.to_fraction_data_from_number_string(n[1]);return i.div(e)}}static to_fraction_data_from_number(t){const n="boolean"!=typeof t?t:t?1:0;let i=null,e=null;if(!isFinite(n)){const t=new Fraction;return t.denominator=BigInteger.ONE,t.numerator=n===1/0?BigInteger.POSITIVE_INFINITY:n===-1/0?BigInteger.NEGATIVE_INFINITY:BigInteger.NaN,t}if(0===n){const t=new Fraction;return t.denominator=BigInteger.ONE,t.numerator=BigInteger.ZERO,t}if(Math.abs(n-Math.round(n))<=Number.EPSILON)i=new BigInteger(Math.round(n)),e=BigInteger.ONE;else{let t=Math.trunc(Math.log(Math.abs(n))/Math.log(10)),r=n/Math.pow(10,t);t=-t;for(let n=0;n<14&&(r*=10,t+=1,!(Math.abs(r-Math.round(r))<=Number.EPSILON));n++);if(r=Math.round(1e14*r)/1e14,t<=0)i=new BigInteger(n),e=BigInteger.ONE;else{i=new BigInteger(r);const n=["1"];for(let i=0;i<t;i++)n.push("0");e=new BigInteger([n.join(""),10])}}return new Fraction([i,e])}static normalization(t){if(!t.denominator.equals(BigInteger.ONE)){if(t.denominator.equals(BigInteger.MINUS_ONE))return t.numerator=t.numerator.negate(),void(t.denominator=BigInteger.ONE);if(t.numerator.equals(BigInteger.ZERO))return void(t.denominator=BigInteger.ONE);const n=t.numerator.gcd(t.denominator);let i=t.numerator.div(n),e=t.denominator.div(n);e.sign()<0&&(i=i.negate(),e=e.negate()),t.numerator=i,t.denominator=e}}}class Fraction extends KonpeitoInteger{constructor(t){if(super(),this.numerator=null,this.denominator=null,0===arguments.length)this.numerator=BigInteger.ZERO,this.denominator=BigInteger.ONE;else{if(1!==arguments.length)throw"Fraction Unsupported argument "+t;{let n=!1;if("number"==typeof t||"boolean"==typeof t){const n=FractionTool.to_fraction_data_from_number(t);this.numerator=n.numerator,this.denominator=n.denominator}else if("string"==typeof t){const n=FractionTool.to_fraction_data_from_fraction_string(t);this.numerator=n.numerator,this.denominator=n.denominator}else if(t instanceof BigInteger)this.numerator=t,this.denominator=BigInteger.ONE;else if(t instanceof Fraction)this.numerator=t.numerator,this.denominator=t.denominator;else if(t instanceof Array&&2===t.length)this.numerator=t[0]instanceof BigInteger?t[0]:new BigInteger(t[0]),this.denominator=t[1]instanceof BigInteger?t[1]:new BigInteger(t[1]),n=!0;else if(t instanceof BigDecimal){const n=t.unscaledValue();if(n.isFinite()){const n=new Fraction(t.unscaledValue()),i=n.scaleByPowerOfTen(-t.scale());this.numerator=i.numerator,this.denominator=i.denominator}else this.numerator=n,this.denominator=BigInteger.ONE}else{if("object"!=typeof t)throw"Fraction Unsupported argument "+t;if("doubleValue"in t){const n=FractionTool.to_fraction_data_from_number(t.doubleValue);this.numerator=n.numerator,this.denominator=n.denominator}else if("numerator"in t&&"denominator"in t)this.numerator=t.numerator instanceof BigInteger?t.numerator:new BigInteger(t.numerator),this.denominator=t.denominator instanceof BigInteger?t.denominator:new BigInteger(t.denominator),n=!0;else{const n=FractionTool.to_fraction_data_from_fraction_string(t.toString());this.numerator=n.numerator,this.denominator=n.denominator}}n&&FractionTool.normalization(this)}}}static create(t){return t instanceof Fraction?t:new Fraction(t)}static valueOf(t){return Fraction.create(t)}static _toFraction(t){return t instanceof Fraction?t:new Fraction(t)}static _toFloat(t){return"number"==typeof t?t:t instanceof Fraction?t.doubleValue:new Fraction(t).doubleValue}static _toInteger(t){return"number"==typeof t?Math.trunc(t):t instanceof Fraction?t.intValue:new Fraction(t).intValue}clone(){return new Fraction(this)}abs(){return this.isFinite()?this.sign()>=0?this:this.negate():this.isNegativeInfinity()?Fraction.POSITIVE_INFINITY:this}negate(){return this.isFinite()?new Fraction([this.numerator.negate(),this.denominator]):this.isPositiveInfinity()?Fraction.NEGATIVE_INFINITY:this.isNegativeInfinity()?Fraction.POSITIVE_INFINITY:this}sign(){return this.isFinite()?this.numerator.sign():this.isNaN()?NaN:this.isPositiveInfinity()?1:-1}toString(){return this.isFinite()?this.isInteger()?this.numerator.toString():this.toFractionString():this.isNaN()?"NaN":this.isPositiveInfinity()?"Infinity":"-Infinity"}toJSON(){return this.toString()}toFractionString(){return this.isFinite()?this.numerator.toString()+"/"+this.denominator.toString():this.isNaN()?"NaN":this.isPositiveInfinity()?"Infinity":"-Infinity"}toPlainString(t){if(!this.isFinite())return this.isNaN()?"NaN":this.isPositiveInfinity()?"Infinity":"-Infinity";if(this.isInteger())return this.numerator.toString();const n=this.numerator.sign();let i=this.numerator.abs();const e=this.denominator;let r=null;const o=[],a={};let s;s=void 0!==t?Fraction._toInteger(t):10*(i.toString().length+e.toString().length);for(let t=0;t<s;t++){const n=i.divideAndRemainder(e),s=n[0],u=n[1],c=u.toString();if(o.push(s.toString()),void 0!==a[c]){const t=(r=o.join("")).indexOf(".")+a[c]+1;r=r.substr(0,t)+"("+r.substr(t,r.length-t)+")";break}if(a[c]=t,u.isZero())break;0===t&&o.push("."),i=u.scaleByPowerOfTen(1)}return null===r&&(r=r=o.join("")),(n<0?"-":"")+r}add(t){const n=this,i=Fraction._toFraction(t);if(!n.isFinite()||!i.isFinite())return n.isNaN()||i.isNaN()||n.isInfinite()&&i.isInfinite()&&!n.equalsState(i)?Fraction.NaN:n.isPositiveInfinity()||i.isPositiveInfinity()?Fraction.POSITIVE_INFINITY:Fraction.NEGATIVE_INFINITY;return new Fraction(n.isInteger()&&i.isInteger()?[n.numerator.add(i.numerator),BigInteger.ONE]:[n.numerator.mul(i.denominator).add(i.numerator.mul(n.denominator)),n.denominator.mul(i.denominator)])}sub(t){const n=this,i=Fraction._toFraction(t);if(!n.isFinite()||!i.isFinite())return n.isNaN()||i.isNaN()||n.equalsState(i)?Fraction.NaN:n.isNegativeInfinity()||i.isPositiveInfinity()?Fraction.NEGATIVE_INFINITY:Fraction.POSITIVE_INFINITY;return new Fraction(n.isInteger()&&i.isInteger()?[n.numerator.sub(i.numerator),BigInteger.ONE]:[n.numerator.mul(i.denominator).sub(i.numerator.mul(n.denominator)),n.denominator.mul(i.denominator)])}mul(t){const n=this,i=Fraction._toFraction(t);if(!n.isFinite()||!i.isFinite())return n.isNaN()||i.isNaN()||n.isZero()||i.isZero()?Fraction.NaN:n.sign()*i.sign()>0?Fraction.POSITIVE_INFINITY:Fraction.NEGATIVE_INFINITY;return new Fraction(n.isInteger()&&i.isInteger()?[n.numerator.mul(i.numerator),BigInteger.ONE]:[n.numerator.mul(i.numerator),n.denominator.mul(i.denominator)])}div(t){const n=this,i=Fraction._toFraction(t);if(!n.isFinite()||!i.isFinite())return n.isNaN()||i.isNaN()||n.isInfinite()&&i.isInfinite()?Fraction.NaN:n.isInfinite()?n.sign()*i.sign()>=0?Fraction.POSITIVE_INFINITY:Fraction.NEGATIVE_INFINITY:Fraction.ZERO;if(i.isZero())return n.isZero()?Fraction.NaN:n.sign()>=0?Fraction.POSITIVE_INFINITY:Fraction.NEGATIVE_INFINITY;return new Fraction(n.isInteger()&&i.isInteger()?[n.numerator,i.numerator]:[n.numerator.mul(i.denominator),i.numerator.mul(n.denominator)])}inv(){return this.isFinite()?this.isZero()?Fraction.NaN:new Fraction([this.denominator,this.numerator]):this.isNaN()?Fraction.NaN:Fraction.ZERO}rem(t){const n=this,i=Fraction._toFraction(t);return n.isFinite()&&i.isFinite()&&!i.isZero()?n.sub(i.mul(n.div(i).fix())):Fraction.NaN}mod(t){const n=this,i=Fraction._toFraction(t);if(i.isZero())return n;const e=n.rem(i);return n.equalsState(i)?e:e.add(i)}pow(t){const n=this,i=Fraction._toFraction(t);if(n.isNaN()||i.isNaN())return Fraction.NaN;if(i.isZero())return Fraction.ONE;if(n.isZero())return Fraction.ZERO;if(n.isOne())return Fraction.ONE;if(n.isInfinite())return n.isPositiveInfinity()?Fraction.POSITIVE_INFINITY:i.isPositiveInfinity()?Fraction.NaN:new Fraction(1/0*Math.pow(-1,Math.round(i.doubleValue)));if(i.isInfinite()){if(n.isNegative())return Fraction.NaN;if(n.compareTo(Fraction.ONE)<0){if(i.isPositiveInfinity())return Fraction.ZERO;if(i.isNegativeInfinity())return Fraction.POSITIVE_INFINITY}else{if(i.isPositiveInfinity())return Fraction.POSITIVE_INFINITY;if(i.isNegativeInfinity())return Fraction.ZERO}}const e=n.numerator.pow(i.intValue),r=n.denominator.pow(i.intValue);return new Fraction([e,r])}square(){return this.mul(this)}factorial(){return this.isFinite()?new Fraction([this.toBigInteger().factorial(),Fraction.ONE]):this}scaleByPowerOfTen(t){if(!this.isFinite())return this;const n=Fraction._toInteger(t);if(0===n)return this;let i;return n>0?i=new Fraction([this.numerator.scaleByPowerOfTen(n),this.denominator]):n<0&&(i=new Fraction([this.numerator,this.denominator.scaleByPowerOfTen(-n)])),i}get booleanValue(){return this.numerator.booleanValue}get intValue(){return this.isFinite()?this.isInteger()?Math.trunc(this.numerator.doubleValue):Math.trunc(this.doubleValue):this.isNaN()?NaN:this.isPositiveInfinity()?1/0:-1/0}get doubleValue(){if(!this.isFinite())return this.isNaN()?NaN:this.isPositiveInfinity()?1/0:-1/0;if(this.isInteger())return this.numerator.doubleValue;const t=new BigDecimal([this.numerator,MathContext.UNLIMITED]),n=new BigDecimal([this.denominator,MathContext.UNLIMITED]);return t.div(n,{context:MathContext.DECIMAL64}).doubleValue}toBigInteger(){return new BigInteger(this.fix().numerator)}toBigDecimal(t){if(!this.isFinite())return new BigDecimal(this.doubleValue);if(this.isInteger())return new BigDecimal(this.numerator);const n=new BigDecimal([this.numerator,MathContext.UNLIMITED]),i=new BigDecimal([this.denominator,MathContext.UNLIMITED]);return t?n.div(i,{context:t}):n.div(i,{context:BigDecimal.getDefaultContext()})}toFraction(){return this}toComplex(){return new Complex(this)}toMatrix(){return new Matrix(this)}equals(t){const n=this,i=Fraction._toFraction(t);return n.isFinite()&&i.isFinite()?n.numerator.equals(i.numerator)&&n.denominator.equals(i.denominator):!n.isNaN()&&!i.isNaN()&&!!n.equalsState(i)}equalsState(t){const n=this,i=Fraction._toFraction(t);return n.numerator.equalsState(i.numerator)}compareTo(t){const n=this,i=Fraction._toFraction(t);return n.isFinite()&&i.isFinite()?n.sub(i).sign():n.numerator.compareTo(i.numerator)}max(t){const n=Fraction._toFraction(t);return this.isNaN()||n.isNaN()?Fraction.NaN:this.compareTo(n)>=0?this:n}min(t){const n=Fraction._toFraction(t);return this.isNaN()||n.isNaN()?Fraction.NaN:this.compareTo(n)>=0?n:this}clip(t,n){const i=Fraction._toFraction(t),e=Fraction._toFraction(n);if(this.isNaN()||i.isNaN()||e.isNaN())return Fraction.NaN;const r=i.compareTo(e);if(1===r)throw"clip(min, max) error. (min > max)->("+i+" > "+e+")";return 0===r?i:1===this.compareTo(e)?e:-1===this.compareTo(i)?i:this}floor(){if(this.isInteger()||!this.isFinite())return this;const t=this.fix();return this.sign()>0?t:new Fraction([t.numerator.sub(BigInteger.ONE),Fraction.ONE])}ceil(){if(this.isInteger()||!this.isFinite())return this;const t=this.fix();return this.sign()>0?new Fraction([t.numerator.add(BigInteger.ONE),Fraction.ONE]):t}round(){if(this.isInteger()||!this.isFinite())return this;const t=this.floor();return this.sub(t).compareTo(Fraction.HALF)>=0?new Fraction([t.numerator.add(BigInteger.ONE),Fraction.ONE]):t}fix(){return this.isInteger()||!this.isFinite()?this:new Fraction([this.numerator.div(this.denominator),Fraction.ONE])}fract(){return this.isFinite()?this.isInteger()?Fraction.ZERO:this.sub(this.floor()):Fraction.NaN}isInteger(){return!!this.isFinite()&&this.denominator.equals(BigInteger.ONE)}isZero(){return!!this.isFinite()&&this.numerator.isZero()}isOne(){return!!this.isFinite()&&(this.numerator.equals(BigInteger.ONE)&&this.denominator.equals(BigInteger.ONE))}isPositive(){return this.numerator.isPositive()}isNegative(){return this.numerator.isNegative()}isNotNegative(){return this.numerator.isNotNegative()}isNaN(){return this.numerator.isNaN()}isPositiveInfinity(){return this.numerator.isPositiveInfinity()}isNegativeInfinity(){return this.numerator.isNegativeInfinity()}isInfinite(){return this.numerator.isInfinite()}isFinite(){return this.numerator.isFinite()}isRepeatingDecimal(){return!!this.isFinite()&&(!this.isInteger()&&!(this.denominator.rem(2).isZero()||this.denominator.rem(5).isZero()))}and(t){const n=this,i=Fraction._toFraction(t),e=n.round().toBigInteger(),r=i.round().toBigInteger();return new Fraction(e.and(r))}or(t){const n=this,i=Fraction._toFraction(t),e=n.round().toBigInteger(),r=i.round().toBigInteger();return new Fraction(e.or(r))}xor(t){const n=this,i=Fraction._toFraction(t),e=n.round().toBigInteger(),r=i.round().toBigInteger();return new Fraction(e.xor(r))}not(){const t=this.round().toBigInteger();return new Fraction(t.not())}shift(t){const n=this.round().toBigInteger(),i=Fraction._toInteger(t);return new Fraction(n.shift(i))}factor(){const t=this.round().toBigInteger().factor(),n=[];for(let i=0;i<t.length;i++)n.push(new Fraction(t[i]));return n}gcd(t){const n=this.round().toBigInteger(),i=Fraction._toFraction(t).toBigInteger(),e=n.gcd(i);return new Fraction(e)}extgcd(t){const n=this.round().toBigInteger(),i=Fraction._toFraction(t).toBigInteger(),e=n.extgcd(i);return[new Fraction(e[0]),new Fraction(e[1]),new Fraction(e[2])]}lcm(t){const n=this.round().toBigInteger(),i=Fraction._toFraction(t).toBigInteger(),e=n.lcm(i);return new Fraction(e)}modPow(t,n){const i=this.round().toBigInteger(),e=Fraction._toFraction(t).toBigInteger(),r=Fraction._toFraction(n).toBigInteger(),o=i.modPow(e,r);return new Fraction(o)}modInverse(t){const n=this.round().toBigInteger(),i=Fraction._toFraction(t).toBigInteger(),e=n.modInverse(i);return new Fraction(e)}isPrime(){return this.round().toBigInteger().isPrime()}isProbablePrime(t){return this.round().toBigInteger().isProbablePrime(void 0!==t?Fraction._toInteger(t):void 0)}nextProbablePrime(t,n){const i=this.round().toBigInteger(),e=void 0!==t?Fraction._toInteger(t):void 0,r=void 0!==n?Fraction._toInteger(n):void 0;return new Fraction(i.nextProbablePrime(e,r))}static get MINUS_ONE(){return null===DEFINE$2.MINUS_ONE&&(DEFINE$2.MINUS_ONE=new Fraction([BigInteger.MINUS_ONE,BigInteger.ONE])),DEFINE$2.MINUS_ONE}static get ZERO(){return null===DEFINE$2.ZERO&&(DEFINE$2.ZERO=new Fraction([BigInteger.ZERO,BigInteger.ONE])),DEFINE$2.ZERO}static get HALF(){return null===DEFINE$2.HALF&&(DEFINE$2.HALF=new Fraction([BigInteger.ONE,BigInteger.TWO])),DEFINE$2.HALF}static get ONE(){return null===DEFINE$2.ONE&&(DEFINE$2.ONE=new Fraction([BigInteger.ONE,BigInteger.ONE])),DEFINE$2.ONE}static get TWO(){return null===DEFINE$2.TWO&&(DEFINE$2.TWO=new Fraction([BigInteger.TWO,BigInteger.ONE])),DEFINE$2.TWO}static get TEN(){return null===DEFINE$2.TEN&&(DEFINE$2.TEN=new Fraction([BigInteger.TEN,BigInteger.ONE])),DEFINE$2.TEN}static get POSITIVE_INFINITY(){return null===DEFINE$2.POSITIVE_INFINITY&&(DEFINE$2.POSITIVE_INFINITY=new Fraction(Number.POSITIVE_INFINITY)),DEFINE$2.POSITIVE_INFINITY}static get NEGATIVE_INFINITY(){return null===DEFINE$2.NEGATIVE_INFINITY&&(DEFINE$2.NEGATIVE_INFINITY=new Fraction(Number.NEGATIVE_INFINITY)),DEFINE$2.NEGATIVE_INFINITY}static get NaN(){return null===DEFINE$2.NaN&&(DEFINE$2.NaN=new Fraction(Number.NaN)),DEFINE$2.NaN}signum(){return this.sign()}subtract(t){return this.sub(t)}multiply(t){return this.mul(t)}divide(t){return this.div(t)}remainder(t){return this.rem(t)}}const DEFINE$2={MINUS_ONE:null,ZERO:null,ONE:null,HALF:null,TWO:null,TEN:null,POSITIVE_INFINITY:null,NEGATIVE_INFINITY:null,NaN:null};let DEFAULT_RANDOM=new Random;class BigIntegerTool{static toHexadecimalArrayFromPlainString(t,n){const i=Math.floor(Math.log(1073741823)/Math.log(n));let e=[];const r=[],o=Math.ceil(t.length/i);let a=t.length;for(let r=0;r<o;r++)a-=i,e[r]=a>=0?parseInt(t.substring(a,a+i),n):parseInt(t.substring(0,a+i),n);const s=Math.round(Math.pow(n,i));for(;0!==e.length;){let t=0;for(let n=e.length-1;n>=0;n--){const i=e[n]+t*s;e[n]=i>>>1,t=1&i}r[r.length]=t,0===e[e.length-1]&&e.pop()}e=[];for(let t=0;t<r.length;t++)e[t>>>4]|=r[t]<<(15&t);return e}static toPlainStringFromString(t){let n,i=0,e=t.replace(/\s/g,"").toLowerCase();const r=[];null!==(n=e.match(/^[0-9]+/))&&(n=n[0],e=e.substr(n.length),r.push(n)),null!==(n=e.match(/^\.[0-9]+/))&&(n=n[0],e=e.substr(n.length),i+=(n=n.substr(1)).length,r.push(n)),null!==(n=e.match(/^e[+-]?[0-9]+/))&&(n=n[0].substr(1),i-=parseInt(n,10));let o;if(0===i&&(o=r.join("")),i<0){for(let t=0;t<-i;t++)r.push("0");o=r.join("")}else i>0&&(o=0!==(o=(o=r.join("")).substring(0,o.length-i)).length?o:"0");return o}static toBigIntegerFromNumber(t){const n="boolean"!=typeof t?t:t?1:0;if(!isFinite(n))return n===Number.POSITIVE_INFINITY?{state:BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY,element:[]}:n===Number.NEGATIVE_INFINITY?{state:BIGINTEGER_NUMBER_STATE.NEGATIVE_INFINITY,element:[]}:{state:BIGINTEGER_NUMBER_STATE.NOT_A_NUMBER,element:[]};let i,e;if(Math.abs(n)<1-Number.EPSILON)return{element:[],state:BIGINTEGER_NUMBER_STATE.ZERO};if(n>0?(e=BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER,i=n):(e=BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER,i=-n),i>4294967295)return{element:BigIntegerTool.toHexadecimalArrayFromPlainString(BigIntegerTool.toPlainStringFromString(i.toFixed()),10),state:e};{i=Math.abs(n-Math.round(n))<=Number.EPSILON?Math.round(i):Math.trunc(i);const t=[];for(;0!==i;)t[t.length]=1&i,i>>>=1;const r=[];for(let n=0;n<t.length;n++)r[n>>>4]|=t[n]<<(15&n);return{element:r,state:e}}}static toPlainStringFromHexadecimalArray(t,n){const i=function(t,i,e){const r=t.length;let o=0;for(let a=0;a<r;a++)e[a]=t[a]+(i.length>=a+1?i[a]:0)+o,e[a]>=n?(o=1,e[a]-=n):o=0;1===o&&(e[r]=1)},e=[0],r=[1];for(let n=0;n<t.length;n++)for(let o=0;o<16;o++)t[n]>>>o&1&&i(r,e,e),i(r,r,r);return e}static isZeroElement(t){return 0===t.length||1===t.length&&0===t[0]}static toBigIntegerFromString(t,n){let i=t.replace(/\s/g,"").toLowerCase();if(/nan/.test(t))return{state:BIGINTEGER_NUMBER_STATE.NOT_A_NUMBER,element:[]};if(/inf/.test(t))return/-/.test(t)?{state:BIGINTEGER_NUMBER_STATE.NEGATIVE_INFINITY,element:[]}:{state:BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY,element:[]};const e=i.match(/^[-+]+/);let r=[],o=BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER;if(null!==e){const t=e[0];i=i.substring(t.length,i.length),-1!==t.indexOf("-")&&(o=BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER)}return n?r=BigIntegerTool.toHexadecimalArrayFromPlainString(i,n):/^0x/.test(i)?r=BigIntegerTool.toHexadecimalArrayFromPlainString(i.substring(2,i.length),16):/^0b/.test(i)?r=BigIntegerTool.toHexadecimalArrayFromPlainString(i.substring(2,i.length),2):/^0o/.test(i)?r=BigIntegerTool.toHexadecimalArrayFromPlainString(i.substring(2,i.length),8):(i=BigIntegerTool.toPlainStringFromString(i),r=BigIntegerTool.toHexadecimalArrayFromPlainString(i,10)),BigIntegerTool.isZeroElement(r)&&(r=[],o=BIGINTEGER_NUMBER_STATE.ZERO),{element:r,state:o}}}const BIGINTEGER_NUMBER_STATE={ZERO:0,POSITIVE_NUMBER:1,NEGATIVE_NUMBER:2,NOT_A_NUMBER:3,POSITIVE_INFINITY:4,NEGATIVE_INFINITY:5};class BigInteger extends KonpeitoInteger{constructor(t){if(super(),this.state=BIGINTEGER_NUMBER_STATE.ZERO,0===arguments.length)this.element=[];else{if(1!==arguments.length)throw"BigInteger Unsupported argument "+t;if(t instanceof BigInteger)this.element=t.element.slice(0),this.state=t.state;else if("number"==typeof t){const n=BigIntegerTool.toBigIntegerFromNumber(t);this.element=n.element,this.state=n.state}else if("string"==typeof t){const n=BigIntegerTool.toBigIntegerFromString(t);this.element=n.element,this.state=n.state}else if(t instanceof Array){if(2!==t.length||"string"!=typeof t[0]||"number"!=typeof t[1])throw"BigInteger Unsupported argument "+arguments;{const n=BigIntegerTool.toBigIntegerFromString(t[0],t[1]);this.element=n.element,this.state=n.state}}else if("object"==typeof t)if("toBigInteger"in t){const n=t.toBigInteger();this.element=n.element,this.state=n.state}else if("intValue"in t){const n=BigIntegerTool.toBigIntegerFromNumber(t.intValue);this.element=n.element,this.state=n.state}else{const n=BigIntegerTool.toBigIntegerFromString(t.toString());this.element=n.element,this.state=n.state}else{if("boolean"!=typeof t)throw"BigInteger Unsupported argument "+t;{const n=BigIntegerTool.toBigIntegerFromNumber(t);this.element=n.element,this.state=n.state}}}}static create(t){return t instanceof BigInteger?t:new BigInteger(t)}static valueOf(t){return BigInteger.create(t)}static _toBigInteger(t){return t instanceof BigInteger?t:new BigInteger(t)}static _toFloat(t){return"number"==typeof t?t:t instanceof BigInteger?t.doubleValue:new BigInteger(t).doubleValue}static _toInteger(t){return"number"==typeof t?Math.trunc(t):t instanceof BigInteger?t.intValue:new BigInteger(t).intValue}static createRandomBigInteger(t,n){const i=void 0!==n&&n instanceof Random?n:DEFAULT_RANDOM,e=new BigInteger,r=BigInteger._toInteger(t),o=1+(r-1>>4);if(0===r)return BigInteger.ZERO;let a;for(let t=0,n=0;t<o;t++)0===n?(a=i.nextInt(),e.element[t]=65535&a,n=1):(e.element[t]=a>>>16&65535,n=0);return r%16!=0&&(e.element[e.element.length-1]&=(1<<r%16)-1),e.state=BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER,e._memory_reduction(),e}toString(t){if(!this.isFinite())return this.isNaN()?"NaN":this.isPositiveInfinity()?"Infinity":"-Infinity";const n=t?BigInteger._toInteger(t):10,i=Math.floor(Math.log(1073741823)/Math.log(n)),e=Math.round(Math.pow(n,i)),r=[];for(let t=0;t<i;t++)r[t]="0";const o=r.join(""),a=BigIntegerTool.toPlainStringFromHexadecimalArray(this.element,e),s=[];let u="";this.sign()<0&&(s[s.length]="-");for(let t=a.length-1;t>=0;t--)u=a[t].toString(n),t<a.length-1&&(s[s.length]=o.substring(0,i-u.length)),s[s.length]=u;return s.join("")}toJSON(){return this.toString(10)}clone(){return new BigInteger(this)}getTwosComplement(t){const n=this.clone();if(!this.isFinite())return n;if(n.isNotNegative())return n;{n.state=BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER;const i=void 0!==t?t:n.bitLength(),e=n.element;for(let t=0;t<e.length;t++)e[t]^=65535;return i%16!=0&&(e[e.length-1]&=(1<<i%16)-1),n._add(new BigInteger(1)),n}}_memory_allocation(t){if(this.isFinite()){const n=BigInteger._toInteger(t),i=this.element.length<<4;if(i<n){const t=1+((n-i-1&4294967280)>>>4);for(let n=0;n<t;n++)this.element[this.element.length]=0}}}_memory_reduction(){if(this.isFinite()){for(let t=this.element.length-1;t>=0;t--)if(0!==this.element[t])return void(t<this.element.length-1&&this.element.splice(t+1,this.element.length-t-1));this.state=BIGINTEGER_NUMBER_STATE.ZERO,this.element=[]}}_abs(){return this.state===BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER?this.state=BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER:this.state===BIGINTEGER_NUMBER_STATE.NEGATIVE_INFINITY&&(this.state=BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY),this}abs(){return this.clone()._abs()}_negate(){return this.state===BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER?this.state=BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER:this.state===BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER?this.state=BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER:this.state===BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY?this.state=BIGINTEGER_NUMBER_STATE.NEGATIVE_INFINITY:this.state===BIGINTEGER_NUMBER_STATE.NEGATIVE_INFINITY&&(this.state=BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY),this}negate(){return this.clone()._negate()}sign(){return this.isNaN()?NaN:this.isZero()?0:this.isPositive()?1:-1}_add(t){const n=this,i=BigInteger._toBigInteger(t);if(!n.isFinite()||!i.isFinite()){let t;return t=n.isNaN()||i.isNaN()||n.isInfinite()&&i.isInfinite()&&!n.equalsState(i)?BigInteger.NaN.clone():n.isPositiveInfinity()||i.isPositiveInfinity()?BigInteger.POSITIVE_INFINITY.clone():BigInteger.NEGATIVE_INFINITY.clone(),this.element=t.element,this.state=t.state,this}let e=n.element,r=i.element;if(n.sign()===i.sign()){this._memory_allocation(r.length<<4);let t=0;for(let n=0;n<e.length;n++)e[n]+=(r.length>=n+1?r[n]:0)+t,e[n]>65535?(t=1,e[n]&=65535):t=0;0!==t&&(e[e.length]=t)}else{const t=n.compareToAbs(i);if(0===t)return this.element=[],this.state=BIGINTEGER_NUMBER_STATE.ZERO,this;if(-1===t){this.state=i.state;const t=e;e=r.slice(0),r=t}let o=0;for(let t=0;t<e.length;t++)e[t]-=(r.length>=t+1?r[t]:0)+o,e[t]<0?(e[t]+=65536,o=1):o=0;this.element=e,this._memory_reduction()}return this}add(t){return this.clone()._add(t)}_sub(t){const n=BigInteger._toBigInteger(t),i=n.state,e=this._add(n._negate());return n.state=i,e}sub(t){return this.clone()._sub(t)}_mul(t){const n=this.mul(t);return this.element=n.element,this.state=n.state,this}mul(t){const n=BigInteger._toBigInteger(t),i=this,e=n;if(!i.isFinite()||!e.isFinite())return i.isNaN()||e.isNaN()||i.isZero()||e.isZero()?BigInteger.NaN.clone():i.sign()*e.sign()>0?BigInteger.POSITIVE_INFINITY.clone():BigInteger.NEGATIVE_INFINITY.clone();const r=i.element,o=e.element,a=new BigInteger,s=new BigInteger,u=a.element;for(let t=0;t<r.length;t++){s.element=[];const n=s.element;let i=0;for(let e=0;e<o.length;e++)n[e]=r[t]*o[e]+i,n[e]>65535?(i=n[e]>>>16,n[e]&=65535):i=0;0!==i&&(n[n.length]=i);for(let i=n.length-1;i>=0;i--)n[i+t]=n[i];for(let i=t-1;i>=0;i--)n[i]=0;i=0,a._memory_allocation(n.length<<4);for(let e=t;e<u.length;e++)u[e]+=(n.length>=e+1?n[e]:0)+i,u[e]>65535?(i=1,u[e]&=65535):i=0;0!==i&&(u[u.length]=i)}const c=this.sign()*n.sign();return a.state=0===c?BIGINTEGER_NUMBER_STATE.ZERO:1===c?BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER:BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER,a}_divideAndRemainder(t){const n=this,i=BigInteger._toBigInteger(t);if(!n.isFinite()||!i.isFinite())return n.isNaN()||i.isNaN()||n.isInfinite()&&i.isInfinite()?[BigInteger.NaN,BigInteger.NaN]:n.isInfinite()?n.sign()*i.sign()>=0?[BigInteger.POSITIVE_INFINITY,BigInteger.NaN]:[BigInteger.NEGATIVE_INFINITY,BigInteger.NaN]:[BigInteger.ZERO,BigInteger.NaN];if(i.isZero())return n.isZero()?[BigInteger.NaN,BigInteger.NaN]:[n.sign()>=0?BigInteger.POSITIVE_INFINITY:BigInteger.NEGATIVE_INFINITY,BigInteger.NaN];const e=[],r=n.compareToAbs(i),o=n.sign()*i.sign();if(r<0)return e[0]=new BigInteger(0),e[1]=n.clone(),e;if(0===r)return e[0]=new BigInteger(1),e[0].state=1===o?BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER:BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER,e[1]=new BigInteger(0),e;const a=new BigInteger(1),s=n.bitLength()-i.bitLength(),u=n.clone()._abs(),c=i.shift(s)._abs(),l=new BigInteger;for(let t=0;t<=s&&(u.compareToAbs(c)>=0&&(u._sub(c),l._add(a)),t!==s);t++)c._shift(-1),l._shift(1);return e[0]=l,e[0].state=1===o?BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER:BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER,e[1]=u,e[1].state=u.state!==BIGINTEGER_NUMBER_STATE.ZERO?n.state:u.state,e}divideAndRemainder(t){return this.clone()._divideAndRemainder(t)}_div(t){return this._divideAndRemainder(t)[0]}div(t){return this.clone()._div(t)}inv(){return this.isFinite()?this.isZero()?BigInteger.NaN:BigInteger.ZERO:this.isNaN()?BigInteger.NaN:BigInteger.ZERO}_rem(t){const n=this._divideAndRemainder(t)[1];return this.element=n.element,this.state=n.state,this}rem(t){return this.clone()._rem(t)}_mod(t){const n=this,i=BigInteger._toBigInteger(t);if(i.isZero())return n;const e=n._divideAndRemainder(i)[1];return n.state!==i.state&&e._add(i),this.element=e.element,this.state=e.state,this}mod(t){return this.clone()._mod(t)}modPow(t,n){const i=BigInteger._toBigInteger(n);let e=new BigInteger(this),r=new BigInteger(1);const o=new BigInteger(t);if(!e.isFinite()||!o.isFinite())return BigInteger.NaN;for(;0!==o.element.length;)0!=(1&o.element[0])&&(r=r.multiply(e).mod(i)),e=e.multiply(e).mod(i),o._shift(-1);return r}modInverse(t){const n=BigInteger._toBigInteger(t);if(!this.isFinite()||!n.isFinite())return BigInteger.NaN;const i=this.extgcd(t),e=new BigInteger(1);return 0!==i[2].compareTo(e)?BigInteger.NaN:i[0]._add(n).rem(n)}factorial(){if(!this.isFinite())return this;if(this.isNegative())return BigInteger.NaN;const t=BigInteger._toInteger(this);let n=BigInteger.ONE;for(let i=2;i<=t;i++)n=n.multiply(i);return n}scaleByPowerOfTen(t){const n=BigInteger._toInteger(t);return 0===n?this:n>0?this.mul(BigInteger.TEN.pow(n)):this.div(BigInteger.TEN.pow(n))}pow(t){const n=new BigInteger(t);if(this.isNaN()||n.isNaN())return BigInteger.NaN;if(n.isZero())return BigInteger.ONE;if(this.isZero())return n.isNegativeInfinity()?BigInteger.POSITIVE_INFINITY:BigInteger.ZERO;if(this.isOne())return this;if(this.isInfinite())return this.isPositiveInfinity()?BigInteger.POSITIVE_INFINITY:n.isPositiveInfinity()?BigInteger.NaN:BigInteger.create(1/0*Math.pow(-1,Math.round(n.doubleValue)));if(n.isInfinite()){if(this.isNegative())return BigInteger.NaN;if(this.compareTo(BigInteger.ONE)<0){if(n.isPositiveInfinity())return BigInteger.ZERO;if(n.isNegativeInfinity())return BigInteger.POSITIVE_INFINITY}else{if(n.isPositiveInfinity())return BigInteger.POSITIVE_INFINITY;if(n.isNegativeInfinity())return BigInteger.ZERO}}let i=BigInteger._toBigInteger(this),e=BigInteger._toBigInteger(1);for(;0!==n.element.length;)0!=(1&n.element[0])&&(e=e.multiply(i)),i=i.multiply(i),n._shift(-1);return e}square(){return this.mul(this)}sqrt(){if(this.isZero())return BigInteger.ZERO;if(this.isNaN())return BigInteger.NaN;if(this.isNegative())return BigInteger.NaN;if(this.isInfinite())return BigInteger.POSITIVE_INFINITY;let t=BigInteger.ONE,n=this;for(;-1===t.compareToAbs(n);)t=t.shiftLeft(1),n=n.shiftRight(1);let i=n;for(let t=0;t<300;t++){const t=i.add(this.div(i)).shiftRight(1),n=t.sub(i);if(n.isZero())break;i=t}return i}cbrt(){if(this.isZero())return BigInteger.ZERO;if(this.isNaN())return BigInteger.NaN;if(this.isInfinite())return this;let t=BigInteger.ONE,n=this;for(;-1===t.compareToAbs(n);)t=t.shiftLeft(1),n=n.shiftRight(2);let i=n;for(let t=0;t<300;t++){const t=i.mul(i),n=i.shiftLeft(1).add(this.div(t)).div(3),e=n.sub(i);if(e.isZero())break;i=n}return i}log2(){return this.isZero()?BigInteger.ZERO:this.isNaN()?BigInteger.NaN:this.isNegative()?BigInteger.NaN:this.isInfinite()?BigInteger.POSITIVE_INFINITY:BigInteger.create(this.bitLength()-1)}log10(){return this.isZero()?BigInteger.ZERO:this.isNaN()?BigInteger.NaN:this.isNegative()?BigInteger.NaN:this.isInfinite()?BigInteger.POSITIVE_INFINITY:BigInteger.create(this.toString(10).length-1)}static setDefaultRandom(t){DEFAULT_RANDOM=t}static getDefaultRandom(){return DEFAULT_RANDOM}getShort(t){if(this.isZero())return 0;const n=BigInteger._toInteger(t);return 0<=n&&n<=this.element.length?this.element[n]:NaN}get booleanValue(){return!this.isZero()&&!this.isNaN()}get intValue(){if(!this.isFinite())return this.isNaN()?NaN:this.isPositiveInfinity()?1/0:-1/0;let t=0;for(let n=Math.min(3,this.element.length-1);n>=0;n--)t*=65536,t+=this.element[n];return this.isNegative()&&(t=-t),t}get doubleValue(){return this.isFinite()?parseFloat(this.toString()):this.isNaN()?NaN:this.isPositiveInfinity()?1/0:-1/0}toBigInteger(){return this}toBigDecimal(t){return new BigDecimal(t?[this,t]:this)}toFraction(){return new Fraction(this)}toComplex(){return new Complex(this)}toMatrix(){return new Matrix(this)}equals(t){const n=this,i=BigInteger._toBigInteger(t);if(!n.isFinite()||!i.isFinite())return!n.isNaN()&&!i.isNaN()&&n.state===i.state;if(n.state!==i.state)return!1;if(n.element.length!==i.element.length)return!1;for(let t=0;t<i.element.length;t++)if(n.element[t]!==i.element[t])return!1;return!0}compareToAbs(t){const n=this,i=BigInteger._toBigInteger(t);if(!n.isFinite()||!i.isFinite())return n.isNaN()||i.isNaN()?NaN:n.isInfinite()||i.isInfinite()?0:i.isInfinite()?-1:1;if(n.element.length<i.element.length)return-1;if(n.element.length>i.element.length)return 1;for(let t=n.element.length-1;t>=0;t--)if(n.element[t]!==i.element[t]){const e=n.element[t]-i.element[t];return 0===e?0:e>0?1:-1}return 0}compareTo(t){const n=this,i=BigInteger._toBigInteger(t);if(!n.isFinite()||!i.isFinite())return n.isNaN()||i.isNaN()?NaN:n.state===i.state?0:n.isPositiveInfinity()||i.isNegativeInfinity()?1:-1;const e=n.sign(),r=i.sign();return e!==r?e>r?1:-1:0===e?0:n.compareToAbs(i)*e}equalsState(t){const n=this,i=BigInteger._toBigInteger(t);return n.state===i.state}max(t){const n=BigInteger._toBigInteger(t);return this.compareTo(n)>=0?this.clone():n.clone()}min(t){const n=BigInteger._toBigInteger(t);return this.compareTo(n)>=0?n.clone():this.clone()}clip(t,n){const i=BigInteger._toBigInteger(t),e=BigInteger._toBigInteger(n);if(this.isNaN()||i.isNaN()||e.isNaN())return BigInteger.NaN;const r=i.compareTo(e);if(1===r)throw"clip(min, max) error. (min > max)->("+i+" > "+e+")";return 0===r?i:1===this.compareTo(e)?e:-1===this.compareTo(i)?i:this}floor(){return this}ceil(){return this}round(){return this}fix(){return this}fract(){return BigInteger.ZERO}factor(){if(!this.isFinite())return[BigInteger.NaN];if(this.isZero())return[BigInteger.ZERO];if(this.isNegative())return[this];const t=[];let n=this.intValue;if(n>Number.MAX_SAFE_INTEGER)return[];for(;n>=4&&n%2==0;)t.push(BigInteger.TWO),n=Math.floor(n/2);let i=3,e=Math.floor(n/i);for(;e>=i;)n%i==0?(t.push(BigInteger.create(i)),n=e):i+=2,e=Math.floor(n/i);return t.push(BigInteger.create(n)),t}gcd(t){const n=BigInteger._toBigInteger(t);if(!this.isFinite()||!n.isFinite())return BigInteger.NaN;let i,e=this,r=n;for(;0!==r.sign();)i=e.rem(r),e=r,r=i;return e}extgcd(t){const n=BigInteger._toBigInteger(t);if(!this.isFinite()||!n.isFinite())return[BigInteger.NaN,BigInteger.NaN,BigInteger.NaN];const i=new BigInteger(1),e=new BigInteger(0);let r,o,a,s,u=this,c=n,l=i,h=e,g=e,f=i;for(;0!==c.sign();){const t=u.divideAndRemainder(c);o=t[0],r=t[1],a=l.subtract(o.multiply(h)),s=g.subtract(o.multiply(f)),l=h,h=a,g=f,f=s,u=c,c=r}return[l,g,u]}lcm(t){const n=BigInteger._toBigInteger(t);return this.isFinite()&&n.isFinite()?this.mul(n).div(this.gcd(n)):BigInteger.NaN}static probablePrime(t,n,i,e){const r=i?BigInteger._toInteger(i):100,o=e?BigInteger._toInteger(e):500;for(let i=0;i<o;i++){const i=BigInteger.createRandomBigInteger(t,n);if(i.isProbablePrime(r))return i}return console.log("probablePrime "+e),BigInteger.NaN}isPrime(){if(!this.isFinite())return!1;if(this.sign()<=0)return!1;const t=Math.sqrt(Number.MAX_SAFE_INTEGER),n=this.doubleValue,i=Math.ceil(Math.sqrt(n));if(n<=2)return!0;if(i>=t)return null;for(let t=2;t<=i;t++)if(n%t==0)return!1;return!0}isProbablePrime(t){if(!this.isFinite())return!1;const n=this.element;if(this.sign()<=0)return!1;if(1===n.length&&n[0]<=2)return!0;if(0==(1&n[0]))return!1;const i=void 0!==t?BigInteger._toInteger(t):100,e=BigInteger.ZERO,r=BigInteger.ONE,o=this,a=o.bitLength(),s=o.subtract(r),u=s.getLowestSetBit(),c=s.shift(-u);if(i<=0)return!1;for(let t=0;t<i;t++){let t;do{t=BigInteger.createRandomBigInteger(a)}while(0===t.compareTo(e)||-1!==t.compareTo(o));let n=c,i=t.modPow(n,o);for(;;){if(n.equals(s)||i.equals(r)||i.equals(s))break;i=i.mul(i)._mod(o),n=n.shiftLeft(1)}if(!i.equals(s)&&0==(1&n.element[0]))return!1}return!0}nextProbablePrime(t,n){if(!this.isFinite())return BigInteger.NaN;const i=void 0!==t?BigInteger._toInteger(t)>>1:50,e=void 0!==n?BigInteger._toInteger(n):1e5,r=this.clone();for(let t=0;t<e;t++)if(r._add(BigInteger.ONE),r.isProbablePrime(i))return r;throw"nextProbablePrime ["+e+"]"}_shift(t){if(!this.isFinite())return this;let n=BigInteger._toInteger(t);if(0===n)return this;const i=this.element;if(1===n){let t=i.length-1;for(0!=(32768&i[t])&&(i[i.length]=1);t>=0;t--)i[t]<<=1,i[t]&=65535,t>0&&0!=(32768&i[t-1])&&(i[t]+=1)}else if(-1===n){for(let t=0;t<i.length;t++)i[t]>>>=1,t<i.length-1&&0!=(1&i[t+1])&&(i[t]|=32768);0===i[i.length-1]&&i.pop()}else{if(n>=16){const t=n>>>4;for(let n=i.length-1;n>=0;n--)i[n+t]=i[n];for(let n=t-1;n>=0;n--)i[n]=0;n&=15}else if(n<=-16){const t=-n>>>4;i.splice(0,t),n+=t<<4}if(0!==n)if(0<n){let t=0;for(let e=0;e<i.length;e++)i[e]=(i[e]<<n)+t,i[e]>65535?(t=i[e]>>>16,i[e]&=65535):t=0;0!==t&&(i[i.length]=t)}else{n=-n;for(let t=0;t<i.length;t++)t!==i.length-1?(i[t]+=i[t+1]<<16,i[t]>>>=n,i[t]&=65535):i[t]>>>=n;0===i[i.length-1]&&i.pop()}}return 0===i.length&&(this.state=BIGINTEGER_NUMBER_STATE.ZERO),this}shift(t){return this.clone()._shift(t)}shiftLeft(t){return this.shift(t)}shiftRight(t){return this.shift(-t)}getLowestSetBit(){if(!this.isFinite())return NaN;for(let t=0;t<this.element.length;t++)if(0!==this.element[t]){const n=this.element[t];for(let i=0;i<16;i++)if(0!=(n>>>i&1))return 16*t+i}return-1}bitLength(){if(!this.isFinite())return NaN;for(let t=this.element.length-1;t>=0;t--)if(0!==this.element[t]){const n=this.element[t];for(let i=15;i>=0;i--)if(0!=(n>>>i&1))return 16*t+i+1}return 0}bitCount(){if(!this.isFinite())return NaN;let t;const n=(t=this.sign()>=0?this:this.add(new BigInteger(1))).bitLength();let i=0,e=0;for(let r=0;i<n;r++){const o=t.element[r];for(let t=0;t<16&&i<n;t++,i++)0!=(o>>>t&1)&&(e+=1)}return e}_and(t){const n=this,i=BigInteger._toBigInteger(t);if(!n.isFinite()||!i.isFinite()){let t;return t=n.isNaN()||i.isNaN()?BigInteger.NaN:BigInteger.ZERO,t=t.clone(),this.element=t.element,this.state=t.state,this}const e=n.sign(),r=i.sign(),o=Math.max(n.bitLength(),i.bitLength()),a=n.getTwosComplement(o).element,s=i.getTwosComplement(o).element,u=Math.max(a.length,s.length);this.element=[];for(let t=0;t<u;t++){const n=t>=a.length?0:a[t],i=t>=s.length?0:s[t];this.element[t]=n&i}return this._memory_reduction(),this.state===BIGINTEGER_NUMBER_STATE.ZERO||1!==e&&1!==r?this.state===BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER&&(this.element=this.getTwosComplement(o).element,this._memory_reduction()):this.state=BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER,this}and(t){return this.clone()._and(t)}_or(t){const n=this,i=BigInteger._toBigInteger(t);if(!n.isFinite()||!i.isFinite()){let t;return t=n.isNaN()||i.isNaN()?BigInteger.NaN.clone():n.isInfinite()||i.isInfinite()?BigInteger.ZERO:n.isInfinite()?i:n,t=t.clone(),this.element=t.element,this.state=t.state,this}const e=n.sign(),r=i.sign(),o=Math.max(n.bitLength(),i.bitLength()),a=n.getTwosComplement(o).element,s=i.getTwosComplement(o).element,u=Math.max(a.length,s.length);this.element=[];for(let t=0;t<u;t++){const n=t>=a.length?0:a[t],i=t>=s.length?0:s[t];this.element[t]=n|i}return this.state=-1===e||-1===r?BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER:0===Math.max(e,r)?BIGINTEGER_NUMBER_STATE.ZERO:BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER,this.state===BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER&&(this.element=this.getTwosComplement(o).element,this._memory_reduction()),this}or(t){return this.clone()._or(t)}_xor(t){const n=this,i=BigInteger._toBigInteger(t);if(!n.isFinite()||!i.isFinite()){let t;return t=n.isNaN()||i.isNaN()?BigInteger.NaN:n.isInfinite()||i.isInfinite()?BigInteger.ZERO:n.isInfinite()?i:n,t=t.clone(),this.element=t.element,this.state=t.state,this}const e=n.sign(),r=i.sign(),o=Math.max(n.bitLength(),i.bitLength()),a=n.getTwosComplement(o).element,s=i.getTwosComplement(o).element,u=Math.max(a.length,s.length);this.element=[];for(let t=0;t<u;t++){const n=t>=a.length?0:a[t],i=t>=s.length?0:s[t];this.element[t]=n^i}return this._memory_reduction(),this.state=0!==e&&e!==r?BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER:BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER,this.state===BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER&&(this.element=this.getTwosComplement(o).element,this._memory_reduction()),this}xor(t){return this.clone()._xor(t)}_not(){return this._add(new BigInteger(1))._negate()}not(){return this.clone()._not()}_setBit(t){const n=BigInteger._toInteger(t);return this._memory_allocation(n+1),this.element[n>>>4]|=1<<(15&n),this.state=BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER,this}setBit(t){const n=BigInteger._toInteger(t);return this.clone()._setBit(n)}_flipBit(t){const n=BigInteger._toInteger(t);return this._memory_allocation(n+1),this.element[n>>>4]^=1<<(15&n),this._memory_reduction(),this}flipBit(t){const n=BigInteger._toInteger(t);return this.clone()._flipBit(n)}clearBit(t){const n=BigInteger._toInteger(t),i=this.clone();return i.element[n>>>4]&=~(1<<(15&n)),i._memory_reduction(),i}testBit(t){const n=BigInteger._toInteger(t);return 0!=(this.element[n>>>4]>>>(15&n)&1)}isZero(){return this.state===BIGINTEGER_NUMBER_STATE.ZERO}isOne(){return this.state===BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER&&1===this.element.length&&1===this.element[0]}isPositive(){return this.state===BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER||this.state===BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY}isNegative(){return this.state===BIGINTEGER_NUMBER_STATE.NEGATIVE_NUMBER||this.state===BIGINTEGER_NUMBER_STATE.NEGATIVE_INFINITY}isNotNegative(){return this.state===BIGINTEGER_NUMBER_STATE.ZERO||this.state===BIGINTEGER_NUMBER_STATE.POSITIVE_NUMBER||this.state===BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY}isNaN(){return this.state===BIGINTEGER_NUMBER_STATE.NOT_A_NUMBER}isPositiveInfinity(){return this.state===BIGINTEGER_NUMBER_STATE.POSITIVE_INFINITY}isNegativeInfinity(){return this.state===BIGINTEGER_NUMBER_STATE.NEGATIVE_INFINITY}isInfinite(){return this.isPositiveInfinity()||this.isNegativeInfinity()}isFinite(){return!this.isNaN()&&!this.isInfinite()}static get MINUS_ONE(){return DEFINE$3.MINUS_ONE}static get ZERO(){return DEFINE$3.ZERO}static get ONE(){return DEFINE$3.ONE}static get TWO(){return DEFINE$3.TWO}static get TEN(){return DEFINE$3.TEN}static get POSITIVE_INFINITY(){return DEFINE$3.POSITIVE_INFINITY}static get NEGATIVE_INFINITY(){return DEFINE$3.NEGATIVE_INFINITY}static get NaN(){return DEFINE$3.NaN}signum(){return this.sign()}subtract(t){return this.sub(t)}multiply(t){return this.mul(t)}divide(t){return this.div(t)}remainder(t){return this.rem(t)}}const DEFINE$3={MINUS_ONE:new BigInteger(-1),ZERO:new BigInteger(0),ONE:new BigInteger(1),TWO:new BigInteger(2),TEN:new BigInteger(10),POSITIVE_INFINITY:new BigInteger(Number.POSITIVE_INFINITY),NEGATIVE_INFINITY:new BigInteger(Number.NEGATIVE_INFINITY),NaN:new BigInteger(Number.NaN)},DEFAULT_CONTEXT_=[];DEFAULT_CONTEXT_[0]=MathContext.DECIMAL128;class BigDecimalTool{static ToBigDecimalFromString(t){let n,i=0,e=t.replace(/\s/g,"").toLowerCase();if(/nan/.test(e))return{scale:0,integer:BigInteger.NaN};if(/inf/.test(e))return/-/.test(e)?{scale:0,integer:BigInteger.NEGATIVE_INFINITY}:{scale:0,integer:BigInteger.POSITIVE_INFINITY};let r="";return null!==(n=e.match(/^[+-]+/))&&(n=n[0],e=e.substr(n.length),-1!==n.indexOf("-")&&(r+="-")),null!==(n=e.match(/^[0-9]+/))&&(n=n[0],e=e.substr(n.length),r+=n),null!==(n=e.match(/^\.[0-9]+/))&&(n=n[0],e=e.substr(n.length),i+=(n=n.substr(1)).length,r+=n),null!==(n=e.match(/^e[+-]?[0-9]+/))&&(n=n[0].substr(1),i-=parseInt(n,10)),{scale:i,integer:new BigInteger([r,10])}}static ToBigDecimalFromNumber(t){const n="boolean"!=typeof t?t:t?1:0;if(isFinite(n)){if(0===n)return{scale:0,integer:BigInteger.ZERO};if(Math.abs(n)>=1-Number.EPSILON&&Math.abs(n-Math.round(n))<=Number.EPSILON)return{scale:0,integer:new BigInteger(Math.round(n))};{let t=Math.trunc(Math.log(Math.abs(n))/Math.log(10)),i=n/Math.pow(10,t);t=-t;for(let n=0;n<14&&(i*=10,t+=1,!(Math.abs(i-Math.round(i))<=Number.EPSILON));n++);return i=Math.round(1e14*i)/1e14,{scale:t,integer:new BigInteger(i)}}}return n===1/0?{scale:0,integer:BigInteger.POSITIVE_INFINITY}:n===-1/0?{scale:0,integer:BigInteger.NEGATIVE_INFINITY}:{scale:0,integer:BigInteger.NaN}}}class BigDecimal extends KonpeitoFloat{constructor(t){super(),this._scale=0,this.context=BigDecimal.getDefaultContext();let n=!1;if(arguments.length>1)throw"BigDecimal Unsupported argument["+arguments.length+"]";if(t instanceof BigDecimal)this.integer=t.integer.clone(),this.int_string=t.int_string,this._scale=t._scale,this.context=t.context;else if("number"==typeof t||"boolean"==typeof t){const n=BigDecimalTool.ToBigDecimalFromNumber(t);this.integer=n.integer,this._scale=n.scale}else if("string"==typeof t){const n=BigDecimalTool.ToBigDecimalFromString(t);this.integer=n.integer,this._scale=n.scale}else if(t instanceof Array){if(t.length>=1){const n=t[0];if("number"==typeof n||"boolean"==typeof n){const t=BigDecimalTool.ToBigDecimalFromNumber(n);this.integer=t.integer,this._scale=t.scale}else if("string"==typeof n){const t=BigDecimalTool.ToBigDecimalFromString(n);this.integer=t.integer,this._scale=t.scale}else if(n instanceof BigDecimal)this.integer=n.integer.clone(),this._scale=n._scale;else if(n instanceof BigInteger)this.integer=n.clone();else{if("object"!=typeof n)throw"BigDecimal Unsupported argument "+n+"("+typeof n+")";if("toBigDecimal"in n){const t=n.toBigDecimal();this.integer=t.integer,this._scale=t._scale}else if("doubleValue"in n){const t=BigDecimalTool.ToBigDecimalFromNumber(n.doubleValue);this.integer=t.integer,this._scale=t.scale}else{const t=BigDecimalTool.ToBigDecimalFromString(n.toString());this.integer=t.integer,this._scale=t.scale}}}t.length>=2&&("number"==typeof t[1]?(this._scale=t[1],t.length>=3&&(this.context=void 0!==t[2]&&t[2]instanceof MathContext?t[2]:BigDecimal.getDefaultContext(),n=!0)):t.length>=2&&(this.context=void 0!==t[1]&&t[1]instanceof MathContext?t[1]:BigDecimal.getDefaultContext(),n=!0))}else if(t instanceof BigInteger)this.integer=t.clone();else{if("object"!=typeof t)throw"BigDecimal Unsupported argument "+arguments;if("toBigDecimal"in t){const n=t.toBigDecimal();this.integer=n.integer,this._scale=n._scale,this.context=n.context}else if("doubleValue"in t){const n=BigDecimalTool.ToBigDecimalFromNumber(t.doubleValue);this.integer=n.integer,this._scale=n.scale}else if("integer"in t&&"scale"in t&&"context"in t)this.integer=new BigInteger(t.integer),t.scale&&(this._scale=t.scale),t.context&&(this.context=t.context,n=!0);else if(t instanceof Object){const n=BigDecimalTool.ToBigDecimalFromString(t.toString());this.integer=n.integer,this._scale=n.scale}}if(n){const t=this.round(this.context);this.integer=t.integer,this._scale=t._scale,delete this.int_string}if(!(this.integer instanceof BigInteger&&this.context instanceof MathContext))throw"BigDecimal Unsupported argument "+arguments}static create(t){return t instanceof BigDecimal?t:new BigDecimal(t)}static valueOf(t,n){return new BigDecimal(1===arguments.length?t:[t,n])}static _toBigDecimal(t){return t instanceof BigDecimal?t:new BigDecimal(t)}static _toBigInteger(t){return t instanceof BigInteger?t:t instanceof BigDecimal?t.toBigInteger():new BigInteger(t)}static _toFloat(t){return"number"==typeof t?t:t instanceof BigDecimal?t.doubleValue:new BigDecimal(t).doubleValue}static _toInteger(t){return"number"==typeof t?Math.trunc(t):t instanceof BigInteger?t.intValue:new BigInteger(t).intValue}_getUnsignedIntegerString(){return void 0===this.int_string&&(this.int_string=this.integer.toString(10).replace(/^-/,"")),this.int_string}clone(){return new BigDecimal(this)}scale(){return this._scale}sign(){return this.isFinite()?this.integer.sign():this.isNaN()?NaN:this.isPositiveInfinity()?1:-1}precision(){return this._getUnsignedIntegerString().length}unscaledValue(){return new BigInteger(this.integer)}ulp(){return new BigDecimal([BigInteger.ONE,this.scale()])}abs(){const t=this.clone();return t.integer=t.integer.abs(),t}plus(){return this}negate(){const t=this.clone();return t.integer=t.integer.negate(),t}movePointLeft(t){if(!this.isFinite())return this;const n=BigDecimal._toInteger(t);let i=this.scaleByPowerOfTen(-n);return i=i.setScale(Math.max(this.scale()+n,0))}movePointRight(t){return this.movePointLeft(-t)}stripTrailingZeros(){if(!this.isFinite())return this;const t=this.sign()>=0?"":"-",n=this.integer.toString(10).replace(/^-/,""),i=n.match(/0+$/);let e=null!==i?i[0].length:0;e===n.length&&(e=n.length-1);const r=this.scale()-e;return new BigDecimal([new BigInteger(t+n.substring(0,n.length-e)),r])}static setDefaultContext(t){DEFAULT_CONTEXT_[DEFAULT_CONTEXT_.length-1]=t||MathContext.DECIMAL128}static getDefaultContext(){return DEFAULT_CONTEXT_[DEFAULT_CONTEXT_.length-1]}static pushDefaultContext(t){DEFAULT_CONTEXT_.push(t)}static popDefaultContext(){DEFAULT_CONTEXT_.pop()}get booleanValue(){return this.integer.booleanValue}get intValue(){return this.isFinite()?4294967295&this.toBigInteger().intValue:this.isNaN()?NaN:this.isPositiveInfinity()?1/0:-1/0}get intValueExact(){if(!this.isFinite())throw"ArithmeticException";const t=this.toBigInteger().intValue;if(t<-2147483648||2147483647<t)throw"ArithmeticException";return t}get floatValue(){if(!this.isFinite())return this.isNaN()?NaN:this.isPositiveInfinity()?1/0:-1/0;const t=this.precision();return MathContext.DECIMAL32.getPrecision()<t?this.sign()>=0?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY:parseFloat(this.toEngineeringString())}get doubleValue(){return this.isFinite()?parseFloat(this.toEngineeringString()):this.isNaN()?NaN:this.isPositiveInfinity()?1/0:-1/0}toBigInteger(){return this.integer.scaleByPowerOfTen(-this.scale())}toBigDecimal(t){return t?this.round(t):this}toFraction(){return new Fraction(this)}toComplex(){return new Complex(this)}toMatrix(){return new Matrix(this)}toString(){if(!this.isFinite())return this.isNaN()?"NaN":this.isPositiveInfinity()?"Infinity":"-Infinity";const t=-this.scale()+(this.precision()-1);return this.scale()>=0&&t>=-6?this.toPlainString():this.toScientificNotation(t)}toJSON(){return this.toString()}toScientificNotation(t){if(!this.isFinite())return this.isNaN()?"NaN":this.isPositiveInfinity()?"Infinity":"-Infinity";const n=BigDecimal._toInteger(t),i=this._getUnsignedIntegerString();let e=this.scale();const r=[];let o,a;if(-1===this.sign()&&(r[r.length]="-"),(e=-n-e)>=0)for(r[r.length]=i,o=0;o<e;o++)r[r.length]="0";else if(0<(a=this.precision()+e))r[r.length]=i.substring(0,a),r[r.length]=".",r[r.length]=i.substring(a,i.length);else{for(a=-a,r[r.length]="0.",o=0;o<a;o++)r[r.length]="0";r[r.length]=i}return r[r.length]="E",n>=0&&(r[r.length]="+"),r[r.length]=n,r.join("")}toEngineeringString(){if(!this.isFinite())return this.isNaN()?"NaN":this.isPositiveInfinity()?"Infinity":"-Infinity";const t=-this.scale()+(this.precision()-1);return this.scale()>=0&&t>=-6?this.toPlainString():this.toScientificNotation(3*Math.floor(t/3))}toPlainString(){return this.isFinite()?0===this.scale()?this.sign()<0?"-"+this._getUnsignedIntegerString():this._getUnsignedIntegerString():this.toScientificNotation(0).match(/^[^E]*/)[0]:this.isNaN()?"NaN":this.isPositiveInfinity()?"Infinity":"-Infinity"}equals(t,n){if(n)return 0===this.compareTo(t,n);if(t instanceof BigDecimal||"string"==typeof t){const n=t instanceof BigDecimal?t:BigDecimal._toBigDecimal(t);return!this.isNaN()&&!n.isNaN()&&(this.equalsState(n)&&this._scale===n._scale&&this.integer.equals(n.integer))}return 0===this.compareTo(t)}equalsState(t){const n=this,i=BigDecimal._toBigDecimal(t);return n.integer.equalsState(i.integer)}compareTo(t,n){const i=this,e=BigDecimal._toBigDecimal(t);if(!i.isFinite()||!e.isFinite())return i.integer.compareTo(e.integer);if(n){const t=BigDecimal._toBigDecimal(n);BigDecimal.pushDefaultContext(MathContext.UNLIMITED);const r=i.sub(e);BigDecimal.popDefaultContext();const o=r.abs();return o.compareTo(t)<=0?0:r.sign()}{const t=i.sign(),n=e.sign();if(0===t&&t===n)return 0;if(0===t)return-n;if(0===n)return t}if(i._scale===e._scale)return i.integer.compareTo(e.integer);if(i._scale>e._scale){const t=e.setScale(i._scale);return i.integer.compareTo(t.integer)}{const t=i.setScale(e._scale);return t.integer.compareTo(e.integer)}}max(t){const n=BigDecimal._toBigDecimal(t);return this.isNaN()||n.isNaN()?BigDecimal.NaN:this.compareTo(n)>=0?this.clone():n.clone()}min(t){const n=BigDecimal._toBigDecimal(t);return this.isNaN()||n.isNaN()?BigDecimal.NaN:this.compareTo(n)<=0?this.clone():n.clone()}clip(t,n){const i=BigDecimal._toBigDecimal(t),e=BigDecimal._toBigDecimal(n);if(this.isNaN()||i.isNaN()||e.isNaN())return BigDecimal.NaN;const r=i.compareTo(e);if(1===r)throw"clip(min, max) error. (min > max)->("+i+" > "+e+")";return 0===r?i:1===this.compareTo(e)?e:-1===this.compareTo(i)?i:this}setScale(t,n){if(!this.isFinite())return this;const i=BigDecimal._toInteger(t);if(this.scale()===i)return this.clone();const e=void 0!==n?RoundingMode.valueOf(n):RoundingMode.UNNECESSARY;let r=this._getUnsignedIntegerString();const o=this.sign(),a=o>=0?"":"-",s=i-this.scale();if(0<=s){let t;for(t=0;t<s;t++)r+="0";return new BigDecimal([new BigInteger(a+r),i])}const u=r.length+s,c=u+1;if(u<=0){const t=(o+e.getAddNumber(o))/10;return new BigDecimal([new BigInteger(t),i])}{const t=r.match(/0+$/),n=null!==t?t[0].length:0;if(n+s>=0||e===RoundingMode.DOWN)return new BigDecimal([new BigInteger(a+r.substring(0,u)),i])}{const t=(r=r.substring(0,c)).length>1?2:1,n=parseInt(r.substring(r.length-t,r.length))*o,s=new BigInteger(a+r),u=new BigInteger(e.getAddNumber(n));return r=s.add(u).toString(),new BigDecimal([new BigInteger(r.substring(0,r.length-1)),i])}}round(t){if(!this.isFinite())return this;if(1===arguments.length){if(void 0!==t){if(!(t instanceof MathContext))throw"not MathContext";const n=t.getPrecision(),i=n-this.precision();if(0===i||0===n)return this.clone();const e=this.setScale(this.scale()+i,t.getRoundingMode());if(i>0)return e;if(e.precision()===t.getPrecision())return e;const r=e.integer.sign()>=0?"":"-",o=e._getUnsignedIntegerString(),a=r+o.substring(0,o.length-1);return new BigDecimal([new BigInteger(a),e.scale()-1])}return this}return this.setScale(0,RoundingMode.HALF_UP)}floor(){return this.isFinite()?this.setScale(0,RoundingMode.FLOOR):this}ceil(){return this.isFinite()?this.setScale(0,RoundingMode.CEILING):this}fix(){return this.isFinite()?this.setScale(0,RoundingMode.DOWN):this}fract(){return this.isFinite()?this.sub(this.floor()):BigDecimal.NaN}add(t){const n=this,i=BigDecimal._toBigDecimal(t);if(!n.isFinite()||!i.isFinite())return n.isNaN()||i.isNaN()||n.isInfinite()&&i.isInfinite()&&!n.equalsState(i)?BigDecimal.NaN:n.isPositiveInfinity()||i.isPositiveInfinity()?BigDecimal.POSITIVE_INFINITY:BigDecimal.NEGATIVE_INFINITY;const e=BigDecimal.getDefaultContext(),r=Math.max(n._scale,i._scale);if(n._scale===i._scale)return new BigDecimal([n.integer.add(i.integer),r,e]);if(n._scale>i._scale){const t=i.setScale(n._scale);return new BigDecimal([n.integer.add(t.integer),r,e])}{const t=n.setScale(i._scale);return new BigDecimal([t.integer.add(i.integer),r,e])}}sub(t){const n=BigDecimal._toBigDecimal(t);return this.add(n.negate())}mul(t){const n=this,i=BigDecimal._toBigDecimal(t);if(!n.isFinite()||!i.isFinite())return n.isNaN()||i.isNaN()||n.isZero()||i.isZero()?BigDecimal.NaN:n.sign()*i.sign()>0?BigDecimal.POSITIVE_INFINITY:BigDecimal.NEGATIVE_INFINITY;const e=BigDecimal.getDefaultContext(),r=n.integer.mul(i.integer),o=n._scale+i._scale;return new BigDecimal([r,o,e])}divideToIntegralValue(t){const n=this,i=BigDecimal._toBigDecimal(t);if(!n.isFinite()||!i.isFinite())return n.isNaN()||i.isNaN()||n.isInfinite()&&i.isInfinite()?BigDecimal.NaN:n.isInfinite()?n.sign()*i.sign()>=0?BigDecimal.POSITIVE_INFINITY:BigDecimal.NEGATIVE_INFINITY:BigDecimal.ZERO;if(i.isZero())return n.isZero()?BigDecimal.NaN:n.sign()>=0?BigDecimal.POSITIVE_INFINITY:BigDecimal.NEGATIVE_INFINITY;const e=BigDecimal.getDefaultContext(),r=function(t){let n,i="1";for(n=0;n<t;n++)i+="0";return new BigInteger(i)};if(0===i.compareTo(BigDecimal.ZERO))throw"ArithmeticException";let o=n.integer,a=i.integer;const s=n._scale-i._scale;n._scale>i._scale?a=a.mul(r(s)):n._scale<i._scale&&(o=o.mul(r(-s)));const u=o.div(a),c=u.sign();if(0!==c){const t=u.toString(10).replace(/^-/,"");if(0!==e.getPrecision()&&t.length>e.getPrecision())throw"ArithmeticException";if(t.length<=-s){const n=t.match(/0+$/),i=null!==n?n[0].length:0,r=c>=0?"":"-";return new BigDecimal([new BigInteger(r+t.substring(0,t.length-i)),-i,e])}}let l=new BigDecimal(u);return l=l.setScale(s,RoundingMode.UP),l=l.round(e),l.context=e,l}divideAndRemainder(t){const n=BigDecimal._toBigDecimal(t);if(!this.isFinite()||!n.isFinite())return this.isNaN()||n.isNaN()||this.isInfinite()&&n.isInfinite()?[BigDecimal.NaN,BigDecimal.NaN]:this.isInfinite()?this.sign()*n.sign()>=0?[BigDecimal.POSITIVE_INFINITY,BigDecimal.NaN]:[BigDecimal.NEGATIVE_INFINITY,BigDecimal.NaN]:[BigDecimal.ZERO,BigDecimal.NaN];if(n.isZero())return this.isZero()?[BigDecimal.NaN,BigDecimal.NaN]:[this.sign()>=0?BigDecimal.POSITIVE_INFINITY:BigDecimal.NEGATIVE_INFINITY,BigDecimal.NaN];const i=this.divideToIntegralValue(n);return[i,this.sub(i.mul(n))]}rem(t){return this.divideAndRemainder(t)[1]}mod(t){const n=this,i=BigDecimal._toBigDecimal(t);if(i.isZero())return n;const e=n.rem(i);return n.equalsState(i)?e:e.add(i)}div(t,n){const i=this,e=BigDecimal._toBigDecimal(t);if(!i.isFinite()||!e.isFinite())return i.isNaN()||e.isNaN()||i.isInfinite()&&e.isInfinite()?BigDecimal.NaN:i.isInfinite()?i.sign()*e.sign()>=0?BigDecimal.POSITIVE_INFINITY:BigDecimal.NEGATIVE_INFINITY:BigDecimal.ZERO;if(e.isZero())return i.isZero()?BigDecimal.NaN:i.sign()>=0?BigDecimal.POSITIVE_INFINITY:BigDecimal.NEGATIVE_INFINITY;let r=null,o=null,a=0,s=!1;if(n?n instanceof MathContext?(r=(o=n).getRoundingMode(),a=o.getPrecision()):(n&&n.scale?a=n.scale:(s=!0,a=n&&(n.roundingMode||n.context)?i.scale():i.scale()-e.scale()),n&&n.context?(r=(o=n.context).getRoundingMode(),a=o.getPrecision()):o=this.context,r=n&&n.roundingMode?n.roundingMode:o.getRoundingMode()):(r=(o=BigDecimal.getDefaultContext()).getRoundingMode(),a=o.getPrecision()),0===e.compareTo(BigDecimal.ZERO))throw"ArithmeticException";const u=o.getPrecision();let c;if(0===u||u<=100){let t;const n={};let r,o,a;c=BigDecimal.ZERO;const s=0!==u?u+8:262143;t=i,BigDecimal.pushDefaultContext(MathContext.UNLIMITED);let l,h=!1;for(let i=0;i<s&&(r=t.divideAndRemainder(e),o=r[0],a=r[1],c=c.add(o.scaleByPowerOfTen(-i)),!a.isZero());i++){if(0===u){if(n[a._getUnsignedIntegerString()]){h=!0,l="ArithmeticException "+c+"["+a._getUnsignedIntegerString()+"]";break}n[a._getUnsignedIntegerString()]=!0}t=a.scaleByPowerOfTen(1)}if(BigDecimal.popDefaultContext(),h)throw l}else BigDecimal.pushDefaultContext(new MathContext(u+4,RoundingMode.HALF_UP)),c=this.mul(e.inv()),BigDecimal.popDefaultContext();if(c.context=o,s)try{c=c.setScale(a,r)}catch(t){}else c=c.setScale(a,r);return c=c.round(BigDecimal.getDefaultContext())}inv(){if(BigDecimal.getDefaultContext().equals(MathContext.UNLIMITED))return BigDecimal.ONE.div(this);if(!this.isFinite())return this.isNaN()?BigDecimal.NaN:BigDecimal.ZERO;if(this.isZero())return BigDecimal.NaN;const t=this.isNegative(),n=t?this.negate():this,i=BigDecimal.create(1),e=-n.scale()+(n.precision()-1),r=new BigDecimal([1,e+1]);if(r.isZero())return null;let o=r;for(let t=0;t<20;t++){const t=i.sub(n.mul(o));if(t.isZero())break;o=o.mul(i.add(t).add(t.square()))}return t?o.negate():o}factorial(){return this.isFinite()?new BigDecimal(new BigInteger(this).factorial()):this}scaleByPowerOfTen(t){if(!this.isFinite())return this;const n=BigDecimal._toInteger(t),i=this.clone();return i._scale=this.scale()-n,i}pow(t){const n=this,i=BigDecimal._toBigDecimal(t);if(n.isNaN()||i.isNaN())return BigDecimal.NaN;if(i.isZero())return BigDecimal.ONE;if(n.isZero())return BigDecimal.ZERO;if(n.isOne())return n;if(n.isInfinite())return n.isPositiveInfinity()?BigDecimal.POSITIVE_INFINITY:i.isPositiveInfinity()?BigDecimal.NaN:BigDecimal.create(1/0*Math.pow(-1,Math.round(i.doubleValue)));if(i.isInfinite()){if(n.isNegative())return BigDecimal.NaN;if(n.compareTo(BigDecimal.ONE)<0){if(i.isPositiveInfinity())return BigDecimal.ZERO;if(i.isNegativeInfinity())return BigDecimal.POSITIVE_INFINITY}else{if(i.isPositiveInfinity())return BigDecimal.POSITIVE_INFINITY;if(i.isNegativeInfinity())return BigDecimal.ZERO}}const e=BigDecimal.getDefaultContext(),r=i.intValue;if(Math.abs(r)>1e3)throw BigDecimal.POSITIVE_INFINITY;if(0===e.getPrecision()&&i.isNegative())return BigDecimal.NaN;if(i.isInteger()){const t=i.isNegative();let n,o,a=Math.round(Math.abs(r));for(n=this.clone(),o=BigDecimal.ONE,BigDecimal.pushDefaultContext(MathContext.UNLIMITED);0!==a;)0!=(1&a)&&(o=o.mul(n)),n=n.square(),a>>>=1;return BigDecimal.popDefaultContext(),o.context=e,t&&(o=o.inv()),o=o.round(e)}{const n=BigDecimal.getDefaultContext();BigDecimal.pushDefaultContext(BigDecimal.getDefaultContext().increasePrecision());const i=this.log().mul(t).exp().round(n);return BigDecimal.popDefaultContext(),i}}square(){return this.mul(this)}sqrt(){if(this.isZero())return BigDecimal.ZERO;if(this.isNaN())return BigDecimal.NaN;if(this.isNegative())return BigDecimal.NaN;if(this.isInfinite())return BigDecimal.POSITIVE_INFINITY;if(this.isZero())return BigDecimal.ZERO;{const t=BigDecimal.getDefaultContext();BigDecimal.pushDefaultContext(BigDecimal.getDefaultContext().increasePrecision());const n=this.rsqrt().inv().round(t);return BigDecimal.popDefaultContext(),n}}cbrt(){if(this.isZero())return BigDecimal.ZERO;if(this.isNaN())return BigDecimal.NaN;if(this.isInfinite())return this;const t=-this.scale()+(this.precision()-1)+1,n=this.sign(),i=this.abs();let e;if(t<30){const t=BigDecimal.getDefaultContext();BigDecimal.pushDefaultContext(BigDecimal.getDefaultContext().increasePrecision()),e=i.log().div(3).exp().round(t),BigDecimal.popDefaultContext()}else{const t=1===i.compareTo(BigDecimal.ONE)?i:BigDecimal.ONE;let n=t;for(let t=0;t<1e3;t++){const t=n.mul(n),e=n.mul(2).add(i.div(t)).div(3),r=e.sub(n);if(r.isZero())break;n=e}e=n}return 1===n?e:e.negate()}rsqrt(){if(this.isZero())return BigDecimal.POSITIVE_INFINITY;if(this.isNaN())return BigDecimal.NaN;if(this.isInfinite())return BigDecimal.ZERO;if(this.isNegative())return BigDecimal.NaN;const t=this,n=BigDecimal.create(1),i=BigDecimal.create(5),e=BigDecimal.create(6),r=BigDecimal.create(8),o=BigDecimal.create(16).inv(),a=t.inv();if(a.isZero())throw"ArithmeticException";let s=a;for(let a=0;a<50;a++){const a=n.sub(t.mul(s.square()));if(a.isZero())break;s=s.mul(n.add(a.mul(r.add(a.mul(e.add(i.mul(a))))).mul(o)))}return s}log(){if(this.isZero())return BigDecimal.NEGATIVE_INFINITY;if(this.isNaN())return BigDecimal.NaN;if(this.isNegative())return BigDecimal.NaN;if(this.isInfinite())return BigDecimal.POSITIVE_INFINITY;if(this.isOne())return BigDecimal.ZERO;const t=BigDecimal.getDefaultContext(),n=-this.scale()+(this.precision()-1)+1;BigDecimal.pushDefaultContext(new MathContext(t.getPrecision()+n,RoundingMode.HALF_UP));let i=this,e=0;{const t=BigDecimal.E,n=i.compareTo(t);if(0===n)return BigDecimal.popDefaultContext(),BigDecimal.ONE;if(n>0)for(;e<300&&!(i.compareTo(t)<=0);e++)i=i.div(t);else{const n=new BigDecimal(1);if(i.compareTo(n)<0)for(;e>-300&&!(i.compareTo(n)>0);e--)i=i.mul(t)}}BigDecimal.popDefaultContext();const r=(i=i.round(BigDecimal.getDefaultContext())).sub(BigDecimal.ONE).div(i.add(BigDecimal.ONE)),o=r.mul(r);{let t=r,n=r,e=BigDecimal.ONE;for(let i=0;i<300;i++){e=e.add(BigDecimal.TWO),t=t.mul(o);const i=n.add(t.div(e)),r=i.sub(n);if(n=i,r.isZero())break}i=n.mul(BigDecimal.TWO)}return i.add(e)}exp(){if(this.isZero())return BigDecimal.ONE;if(this.isNaN())return BigDecimal.NaN;if(this.isNegativeInfinity())return BigDecimal.ZERO;if(this.isPositiveInfinity())return BigDecimal.POSITIVE_INFINITY;const t=this.isNegative();let n=this;t&&(n=n.negate());const i=-n.scale()+(n.precision()-1)+1,e=BigDecimal.getDefaultContext();BigDecimal.pushDefaultContext(new MathContext(e.getPrecision()+i,RoundingMode.HALF_UP));let r=0,o=1;{const t=n.doubleValue;t>=10&&(r=Math.floor(Math.log(Math.floor(t))/Math.log(10)),o=Math.pow(10,r))}const a=n.div(o,e);let s;{let t=a,n=BigDecimal.ONE.add(a),i=BigDecimal.ONE;for(let e=2;e<300;e++){i=i.mul(e),t=t.mul(a);const r=n.add(t.div(i)),o=r.sub(n);if(n=r,o.isZero())break}s=n}return s=s.pow(o),BigDecimal.popDefaultContext(),s=s.round(BigDecimal.getDefaultContext()),t?s.inv():s}expm1(){return this.exp().sub(1)}log1p(){return this.add(1).log()}log2(){return this.log().div(BigDecimal.LN2)}log10(){return this.log().div(BigDecimal.LN10)}sin(){if(!this.isFinite())return BigDecimal.NaN;const t=-this.scale()+(this.precision()-1)+1,n=new MathContext(BigDecimal.getDefaultContext().getPrecision()+t,RoundingMode.HALF_UP);BigDecimal.pushDefaultContext(n);const i=this.mod(BigDecimal.TWO_PI);BigDecimal.popDefaultContext();let e=i;{const t=i.mul(i);let n=i,r=BigDecimal.ONE,o=-1;for(let i=2;i<300;i++)if(r=r.mul(i),i%2==1){n=n.mul(t);let i;o<0?(i=e.sub(n.div(r)),o=1):(i=e.add(n.div(r)),o=-1);const a=i.sub(e);if(e=i,a.isZero())break}}return e}cos(){if(!this.isFinite())return BigDecimal.NaN;const t=-this.scale()+(this.precision()-1)+1,n=new MathContext(BigDecimal.getDefaultContext().getPrecision()+t,RoundingMode.HALF_UP);BigDecimal.pushDefaultContext(n);const i=this.mod(BigDecimal.TWO_PI);BigDecimal.popDefaultContext();let e=BigDecimal.ONE;{let t=BigDecimal.ONE;const n=i.mul(i);let r=BigDecimal.ONE,o=-1;for(let i=2;i<300;i++)if(r=r.mul(i),i%2==0){t=t.mul(n);let i;o<0?(i=e.sub(t.div(r)),o=1):(i=e.add(t.div(r)),o=-1);const a=i.sub(e);if(e=i,a.isZero())break}}return e}tan(){return this.isFinite()?this.sin().div(this.cos()):BigDecimal.NaN}atan(){if(!this.isFinite())return this.isNaN()?BigDecimal.NaN:this.isPositiveInfinity()?BigDecimal.HALF_PI:BigDecimal.HALF_PI.negate();if(this.isZero()){const t=BigDecimal.ZERO;return t}if(0===this.compareTo(BigDecimal.ONE)){const t=BigDecimal.QUARTER_PI;return t}if(0===this.compareTo(BigDecimal.MINUS_ONE)){const t=BigDecimal.QUARTER_PI.negate();return t}const t=this.sign();let n,i=this.abs();1===i.compareTo(BigDecimal.TWO)?(n=1,i=i.inv()):1===i.compareTo(BigDecimal.HALF)?(n=2,i=BigDecimal.ONE.sub(i).div(BigDecimal.ONE.add(i))):n=3;let e=i;{const t=i.mul(i);let n=i,r=BigDecimal.ONE,o=-1;for(let i=0;i<300;i++){n=n.mul(t),r=r.add(BigDecimal.TWO);let i;o<0?(i=e.sub(n.div(r)),o=1):(i=e.add(n.div(r)),o=-1);const a=i.sub(e);if(e=i,a.isZero())break}}return 1===n?e=BigDecimal.HALF_PI.sub(e):2===n&&(e=BigDecimal.QUARTER_PI.sub(e)),t<0&&(e=e.negate()),e}atan2(t,n){const i=BigDecimal.getDefaultContext(),e=this.round(n),r=new BigDecimal([t,n]);if(r.isNaN()||e.isNaN())return BigDecimal.NaN;let o;if(r.isPositive())o=e.div(r).atan();else if(e.isNotNegative()&&r.isNegative())o=e.div(r).atan().add(BigDecimal.PI);else if(e.isNegative()&&r.isNegative())o=e.div(r).atan().sub(BigDecimal.PI);else if(e.isPositive())o=BigDecimal.HALF_PI;else{if(!e.isNegative())throw"ArithmeticException";o=BigDecimal.HALF_PI.negate()}return BigDecimal.setDefaultContext(i),o}asin(){const t=this.square().negate().add(1).sqrt(),n=this,i=t.square().add(n.square()).sqrt(),e=n.atan2(t);return i.log().add(e)}acos(){const t=this,n=this.square().negate().add(1).sqrt(),i=t.square().add(n.square()).sqrt(),e=n.atan2(t);return i.log().add(e)}sinh(){if(this.isInfinite())return this;const t=this.exp();return t.sub(t.inv()).mul(.5)}asinh(){return this.isInfinite()?this:this.add(this.mul(this).add(1).sqrt()).log()}cosh(){return this.isInfinite()?BigDecimal.POSITIVE_INFINITY:this.exp().add(this.negate().exp()).mul(.5)}acosh(){return this.isInfinite()?BigDecimal.NaN:this.add(this.mul(this).sub(1).sqrt()).log()}tanh(){if(this.isInfinite())return BigDecimal.create(this.sign());const t=this.mul(2).exp();return t.sub(1).div(t.add(1))}atanh(){return this.add(1).div(this.negate().add(1)).log().mul(.5)}sec(){return this.cos().inv()}asec(){return this.inv().acos()}sech(){return this.isNegativeInfinity()?BigDecimal.ZERO:this.exp().add(this.negate().exp()).inv().mul(2)}asech(){return this.inv().add(this.square().inv().sub(1).sqrt()).log()}cot(){return this.isZero()?BigDecimal.POSITIVE_INFINITY:this.tan().inv()}acot(){return this.isZero()?BigDecimal.HALF_PI:this.inv().atan()}coth(){if(this.isInfinite())return BigDecimal.create(this.sign());const t=this.mul(2).exp();return t.add(1).div(t.sub(1))}acoth(){return this.isInfinite()?BigDecimal.ZERO:this.add(1).div(this.sub(1)).log().mul(.5)}csc(){return this.isZero()?BigDecimal.POSITIVE_INFINITY:this.sin().inv()}acsc(){return this.inv().asin()}csch(){return this.isInfinite()?BigDecimal.ZERO:this.isZero()?BigDecimal.POSITIVE_INFINITY:this.exp().sub(this.negate().exp()).inv().mul(2)}acsch(){return this.isZero()?BigDecimal.POSITIVE_INFINITY:this.inv().add(this.square().inv().add(1).sqrt()).log()}logit(){return this.log().sub(BigDecimal.ONE.sub(this).log())}sinc(){if(this.isZero())return BigDecimal.ONE;const t=BigDecimal.PI.mul(this);return t.sin().div(t)}static rand(t){let n=BigDecimal.getDefaultContext().getPrecision();n<=0&&(n=100);const i=Math.ceil(n*Math.log(10)/Math.log(2)),e=BigInteger.ONE.shiftLeft(i),r=BigInteger.createRandomBigInteger(i,t);return new BigDecimal(r).div(e)}static randn(t){const n=BigDecimal.rand(t).log().mul(-2).sqrt(),i=BigDecimal.rand(t).mul(2).mul(BigDecimal.PI);return n.mul(i.sin())}isInteger(t){return!!this.isFinite()&&this.sub(this.fix()).isZero(t)}isZero(t){return!!this.isFinite()&&(t?this.equals(BigDecimal.ZERO,t):this.integer.isZero())}isOne(t){return!!this.isFinite()&&0===this.compareTo(BigDecimal.ONE,t)}isPositive(){return this.integer.isPositive()}isNegative(){return this.integer.isNegative()}isNotNegative(){return this.integer.isNotNegative()}isNaN(){return this.integer.isNaN()}isPositiveInfinity(){return this.integer.isPositiveInfinity()}isNegativeInfinity(){return this.integer.isNegativeInfinity()}isInfinite(){return this.integer.isInfinite()}isFinite(){return this.integer.isFinite()}and(t){const n=this,i=BigDecimal._toBigDecimal(t),e=n.round().toBigInteger(),r=i.round().toBigInteger();return new BigDecimal(e.and(r))}or(t){const n=this,i=BigDecimal._toBigDecimal(t),e=n.round().toBigInteger(),r=i.round().toBigInteger();return new BigDecimal(e.or(r))}xor(t){const n=this,i=BigDecimal._toBigDecimal(t),e=n.round().toBigInteger(),r=i.round().toBigInteger();return new BigDecimal(e.xor(r))}not(){const t=this.round().toBigInteger();return new BigDecimal(t.not())}shift(t){const n=this.round().toBigInteger(),i=BigDecimal._toInteger(t);return new BigDecimal(n.shift(i))}factor(){const t=this.round().toBigInteger().factor(),n=[];for(let i=0;i<t.length;i++)n.push(new BigDecimal(t[i]));return n}gcd(t){const n=this.round().toBigInteger(),i=BigDecimal._toBigDecimal(t).toBigInteger(),e=n.gcd(i);return new BigDecimal(e)}extgcd(t){const n=this.round().toBigInteger(),i=BigDecimal._toBigDecimal(t).toBigInteger(),e=n.extgcd(i);return[new BigDecimal(e[0]),new BigDecimal(e[1]),new BigDecimal(e[2])]}lcm(t){const n=this.round().toBigInteger(),i=BigDecimal._toBigDecimal(t).toBigInteger(),e=n.lcm(i);return new BigDecimal(e)}modPow(t,n){const i=this.round().toBigInteger(),e=BigDecimal._toBigDecimal(t).toBigInteger(),r=BigDecimal._toBigDecimal(n).toBigInteger(),o=i.modPow(e,r);return new BigDecimal(o)}modInverse(t){const n=this.round().toBigInteger(),i=BigDecimal._toBigDecimal(t).toBigInteger(),e=n.modInverse(i);return new BigDecimal(e)}isPrime(){return this.round().toBigInteger().isPrime()}isProbablePrime(t){return this.round().toBigInteger().isProbablePrime(void 0!==t?BigDecimal._toInteger(t):void 0)}nextProbablePrime(t,n){const i=this.round().toBigInteger(),e=void 0!==t?BigDecimal._toInteger(t):void 0,r=void 0!==n?BigDecimal._toInteger(n):void 0;return BigDecimal.create(i.nextProbablePrime(e,r))}static get MINUS_ONE(){return CACHED_DATA.MINUS_ONE.get()}static get ZERO(){return CACHED_DATA.ZERO.get()}static get HALF(){return CACHED_DATA.HALF.get()}static get ONE(){return CACHED_DATA.ONE.get()}static get TWO(){return CACHED_DATA.TWO.get()}static get TEN(){return CACHED_DATA.TEN.get()}static get PI(){return CACHED_DATA.PI.get()}static get QUARTER_PI(){return CACHED_DATA.QUARTER_PI.get()}static get HALF_PI(){return CACHED_DATA.HALF_PI.get()}static get TWO_PI(){return CACHED_DATA.TWO_PI.get()}static get E(){return CACHED_DATA.E.get()}static get LN2(){return CACHED_DATA.LN2.get()}static get LN10(){return CACHED_DATA.LN10.get()}static get LOG2E(){return CACHED_DATA.LOG2E.get()}static get LOG10E(){return CACHED_DATA.LOG10E.get()}static get SQRT2(){return CACHED_DATA.SQRT2.get()}static get SQRT1_2(){return CACHED_DATA.SQRT1_2.get()}static get POSITIVE_INFINITY(){return null===DEFINE$4.POSITIVE_INFINITY&&(DEFINE$4.POSITIVE_INFINITY=new BigDecimal(Number.POSITIVE_INFINITY)),DEFINE$4.POSITIVE_INFINITY}static get NEGATIVE_INFINITY(){return null===DEFINE$4.NEGATIVE_INFINITY&&(DEFINE$4.NEGATIVE_INFINITY=new BigDecimal(Number.NEGATIVE_INFINITY)),DEFINE$4.NEGATIVE_INFINITY}static get NaN(){return null===DEFINE$4.NaN&&(DEFINE$4.NaN=new BigDecimal(Number.NaN)),DEFINE$4.NaN}signum(){return this.sign()}subtract(t){return this.sub(t)}multiply(t){return this.mul(t)}divide(t,n){return this.div(t,n)}remainder(t){return this.rem(t)}trunc(){return this.fix()}}BigDecimal.RoundingMode=RoundingMode,BigDecimal.MathContext=MathContext;const DEFINE$4={MINUS_ONE:function(){return new BigDecimal(-1)},ZERO:function(){return new BigDecimal(0)},HALF:function(){return new BigDecimal(.5)},ONE:function(){return new BigDecimal(1)},TWO:function(){return new BigDecimal(2)},TEN:function(){return new BigDecimal(10)},PI:function(){const t=BigDecimal.getDefaultContext();if(t.getPrecision()<=78)return new BigDecimal("3.1415926535897932384626433832795028841971693993751058209749445923078164062862").round(t);{const t=BigDecimal.create(1),n=BigDecimal.create(2),i=BigDecimal.create(4);let e=t,r=n.sqrt().inv(),o=i.inv(),a=t,s=t;for(let t=0;t<10;t++){const t=e.add(r).div(n),u=e.mul(r).sqrt(),c=o.sub(a.mul(e.sub(t).square())),l=a.mul(n),h=t.add(u).square().div(c.mul(i)),g=h.sub(s);if(s=h,g.isZero())break;e=t,r=u,o=c,a=l}return s}},QUARTER_PI:function(){return DEFINE$4.PI().div(4)},HALF_PI:function(){return DEFINE$4.PI().div(2)},TWO_PI:function(){return DEFINE$4.PI().mul(2)},E:function(){const t=BigDecimal.getDefaultContext();if(t.getPrecision()<=83)return new BigDecimal("2.71828182845904523536028747135266249775724709369995957496696762772407663035354759").round(t);{let t=BigDecimal.create(2),n=BigDecimal.create(1);for(let i=2;i<300;i++){n=n.mul(i);const e=t.add(n.inv()),r=e.sub(t);if(t=e,r.isZero())break}return t}},LN2:function(){return new BigDecimal(2).log()},LN10:function(){return new BigDecimal(10).log()},LOG2E:function(){return new BigDecimal(2).log().inv()},LOG10E:function(){return new BigDecimal(10).log().inv()},SQRT2:function(){return new BigDecimal(2).sqrt()},SQRT1_2:function(){return new BigDecimal(.5).sqrt()},POSITIVE_INFINITY:null,NEGATIVE_INFINITY:null,NaN:null};class BigDecimalCache{constructor(t,n){this.method_name=t,this.table=[],this.table_max=n}get(){const t=BigDecimal.getDefaultContext().toString();for(let n=0;n<this.table.length;n++)if(this.table[n].name===t){const t=this.table.splice(n,1)[0];return this.table.unshift(t),t.number}const n=DEFINE$4[this.method_name]();return this.table.length===this.table_max&&this.table.pop(),this.table.unshift({name:t,number:n}),n}}class BigDecimalConst{constructor(){this.MINUS_ONE=new BigDecimalCache("MINUS_ONE",10),this.ZERO=new BigDecimalCache("ZERO",10),this.HALF=new BigDecimalCache("HALF",10),this.ONE=new BigDecimalCache("ONE",10),this.TWO=new BigDecimalCache("TWO",10),this.TEN=new BigDecimalCache("TEN",10),this.PI=new BigDecimalCache("PI",10),this.QUARTER_PI=new BigDecimalCache("QUARTER_PI",10),this.HALF_PI=new BigDecimalCache("HALF_PI",10),this.TWO_PI=new BigDecimalCache("TWO_PI",10),this.E=new BigDecimalCache("E",10),this.LN2=new BigDecimalCache("LN2",10),this.LN10=new BigDecimalCache("LN10",10),this.LOG2E=new BigDecimalCache("LOG2E",10),this.LOG10E=new BigDecimalCache("LOG10E",10),this.SQRT2=new BigDecimalCache("SQRT2",10),this.SQRT1_2=new BigDecimalCache("SQRT1_2",10)}}const CACHED_DATA=new BigDecimalConst;class PrincipalComponentAnalysis{static runPrincipalComponentAnalysis(t){let n=Matrix.create(t.samples);const i={correction:void 0!==t.is_unbiased&&t.is_unbiased?1:0};t.is_standardised&&(n=n.standardization(i));const e=n.cov(i).svd(),r=e.S.diag(),o=e.U.T().negate(),a=o.dotpow(2),s=r.sum(),u=r.dotdiv(s);let c=Complex.ZERO;const l=Matrix.createMatrixDoEachCalculation(function(t,n){return c=c.add(u.getComplex(t+n))},u.column_length,u.row_length);n=n.sub(n.mean({dimension:"column"}));const h=Matrix.createMatrixDoEachCalculation(function(t,i){return n.getMatrix(i,":").dotmul(o.getMatrix(t,":")).sum()},r.length,n.size(1));{const t=r.T().getNumberMatrixArray()[0],n=o.getNumberMatrixArray(),i=a.getNumberMatrixArray(),e=l.getNumberMatrixArray()[0],s=u.T().getNumberMatrixArray()[0],c=h.getNumberMatrixArray(),g=[];for(let o=0;o<r.length;o++)g.push({eigen_value:t[o],factor_loading:n[o],factor_loading_contribution_rate:i[o],cumulative_contribution_ratio:e[o],contribution_ratio:s[o],score:c[o]});return{principal_component:g}}}}class MultipleRegressionAnalysis{static runMultipleRegressionAnalysis(t){let n=Matrix.create(t.samples),i=Matrix.create(t.target);const e={correction:1};t.is_standardised&&(n=n.standardization(),i=i.standardization());const r=Matrix.create(n.width),o=Matrix.create(n.height),a=n.cov(e),s=a.rcond();if(s<=1e-10)return console.log("Analysis failed due to highly correlated explanatory variables.(rcond : "+s+")"),null;const u=[],c=r.intValue;for(let t=0;t<c;t++)u[t]=[n.getMatrix(":",t).cov(i,e)];const l=Matrix.create(u),h=a.inv().mul(l),g=i.mean().sub(n.mean().mul(h)),f=n.mul(h).add(g),m=f.var(e),_=i.var(e),I=f.corrcoef(i,e),N=m.div(_),x=r,E=f.sub(i.mean()).dotpow(2).sum(),d=E.div(x),M=o.sub(r).sub(1),w=f.sub(i).dotpow(2).sum(),b=w.div(M),p=o.sub(1),B=i.sub(i.mean()).dotpow(2).sum(),D=B.div(p),T=b,C=T.sqrt(),F=d.div(b),y=Matrix.ONE.sub(F.fcdf(x,M)),A=Matrix.ONE.sub(b.div(D)),O=o.mul(w.div(o).mul(2*Math.PI).log().add(1)).add(r.add(2).mul(2)),S=a.dotmul(o).inv(),R={coefficient:Matrix.ZERO,standard_error:Matrix.ZERO,t_stat:Matrix.ZERO,p_value:Matrix.ZERO,lower_95:Matrix.ZERO,upper_95:Matrix.ZERO},v=[];for(let t=0;t<c;t++)v[t]={coefficient:Matrix.ZERO,standard_error:Matrix.ZERO,t_stat:Matrix.ZERO,p_value:Matrix.ZERO,lower_95:Matrix.ZERO,upper_95:Matrix.ZERO};R.coefficient=g;for(let t=0;t<c;t++)v[t].coefficient=new Matrix(h.getComplex(t));{const t=r.intValue;let i=o.inv();for(let e=0;e<t;e++)for(let r=0;r<t;r++)i=i.add(n.getMatrix(":",e).mean().mul(n.getMatrix(":",r).mean()).mul(S.getMatrix(e,r)));R.standard_error=i.mul(T).sqrt();for(let t=0;t<c;t++)v[t].standard_error=S.getMatrix(t,t).mul(T).sqrt()}{const t=function(t){t.t_stat=t.coefficient.div(t.standard_error),t.p_value=t.t_stat.tdist(M,2);const n=new Matrix(1-.95);t.lower_95=t.coefficient.sub(n.tinv2(M).mul(t.standard_error)),t.upper_95=t.coefficient.add(n.tinv2(M).mul(t.standard_error))};t(R);for(let n=0;n<c;n++)t(v[n])}let P=null;{const t={coefficient:R.coefficient.doubleValue,standard_error:R.standard_error.doubleValue,t_stat:R.t_stat.doubleValue,p_value:R.p_value.doubleValue,lower_95:R.lower_95.doubleValue,upper_95:R.upper_95.doubleValue},n=[];for(let t=0;t<c;t++)n.push({coefficient:v[t].coefficient.doubleValue,standard_error:v[t].standard_error.doubleValue,t_stat:v[t].t_stat.doubleValue,p_value:v[t].p_value.doubleValue,lower_95:v[t].lower_95.doubleValue,upper_95:v[t].upper_95.doubleValue});P={intercept:t,parameters:n}}return{q:r.doubleValue,n:o.doubleValue,predicted_values:f.getNumberMatrixArray(),sY:m.doubleValue,sy:_.doubleValue,multiple_R:I.doubleValue,R_square:N.doubleValue,adjusted_R_square:A.doubleValue,ANOVA:{regression:{df:x.doubleValue,SS:E.doubleValue,MS:d.doubleValue},residual:{df:M.doubleValue,SS:w.doubleValue,MS:b.doubleValue},total:{df:p.doubleValue,SS:B.doubleValue,MS:D.doubleValue},F:F.doubleValue,significance_F:y.doubleValue},Ve:T.doubleValue,standard_error:C.doubleValue,AIC:O.doubleValue,regression_table:P}}}class DataAnalysis{static runPrincipalComponentAnalysis(t){return PrincipalComponentAnalysis.runPrincipalComponentAnalysis(t)}static runMultipleRegressionAnalysis(t){return MultipleRegressionAnalysis.runMultipleRegressionAnalysis(t)}}class konpeito{static get BigInteger(){return BigInteger}static get BigDecimal(){return BigDecimal}static get RoundingMode(){return RoundingMode}static get MathContext(){return MathContext}static get Fraction(){return Fraction}static get Complex(){return Complex}static get Matrix(){return Matrix}static get Random(){return Random}static get DataAnalysis(){return DataAnalysis}static get Probability(){return Probability}}export default konpeito;
