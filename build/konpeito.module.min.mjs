class RandomTool{static unsigned32(t){return t<0?2147483648+(2147483647&t):t}static multiplication32(t,n){let e=(65535&t)*(65535&n),r=RandomTool.unsigned32(e);return e=(65535&t)*(n>>>16),r=RandomTool.unsigned32(r+((65535&e)<<16)),e=(t>>>16)*(65535&n),4294967295&(r=RandomTool.unsigned32(r+((65535&e)<<16)))}}class Random{constructor(t){this.x=[];for(let t=0;t<521;t++)this.x[t]=0;if(arguments.length>=1)this.setSeed(t);else{const t=(new Date).getTime()+Random.seedUniquifier&4294967295;Random.seedUniquifier=Random.seedUniquifier+1&4294967295,this.setSeed(t)}}_rnd521(){const t=this.x;for(let n=0;n<32;n++)t[n]^=t[n+489];for(let n=32;n<521;n++)t[n]^=t[n-32]}setSeed(t){let n=0;const e=this.x;let r=t;for(let t=0;t<=16;t++){for(let t=0;t<32;t++)n=(n>>>1)+((r=RandomTool.multiplication32(r,1566083941)+1)<0?2147483648:0);e[t]=n}for(let t=16;t<521;t++)n=16===t?t:t-17,e[t]=e[n]<<23&4294967295^e[t-16]>>>9^e[t-1];for(let t=0;t<4;t++)this._rnd521();this.xi=0,this.haveNextNextGaussian=!1,this.nextNextGaussian=0}genrand_int32(){521===this.xi&&(this._rnd521(),this.xi=0);const t=RandomTool.unsigned32(this.x[this.xi]);return this.xi=this.xi+1,t}next(t){return 0===t?0:32===t?this.genrand_int32():t<32?this.genrand_int32()>>>32-t:63===t?2147483648*this.next(32)+this.next(32):64===t?4294967296*this.next(32)+this.next(32):t<64?this.genrand_int32()*(1<<t-32)+(this.genrand_int32()>>>64-t):void 0}nextBytes(t){const n=new Array(t);for(let t=0;t<n.length;t++)n[t]=this.next(8);return n}nextShort(){return this.next(16)}nextInt(t){if(void 0!==t&&"number"==typeof t){let n,e;do{e=(n=RandomTool.unsigned32(this.genrand_int32()))%t}while(n-e+t>4294967296);return e}return 4294967295&this.next(32)}nextLong(){return this.next(64)}nextBoolean(){return 0!==this.next(1)}nextFloat(){return this.next(24)/16777216}nextDouble(){return(134217728*this.next(26)+this.next(27))/9007199254740992}nextGaussian(){if(this.haveNextNextGaussian)return this.haveNextNextGaussian=!1,this.nextNextGaussian;const t=Math.sqrt(-2*Math.log(this.nextDouble())),n=2*Math.PI*this.nextDouble(),e=t*Math.sin(n);return this.nextNextGaussian=t*Math.cos(n),this.haveNextNextGaussian=!0,e}}Random.seedUniquifier=2271560481;class RoundingModeEntity{static toString(){return"NONE"}static getAddNumber(t){return 0}}class RoundingMode_UP extends RoundingModeEntity{static toString(){return"UP"}static getAddNumber(t){const n=t%10;return 0===n?0:n>0?10-n:-(10+n)}}class RoundingMode_DOWN extends RoundingModeEntity{static toString(){return"DOWN"}static getAddNumber(t){return-t%10}}class RoundingMode_CEILING extends RoundingModeEntity{static toString(){return"CEILING"}static getAddNumber(t){const n=t%10;return 0===n?0:n>0?10-n:-n}}class RoundingMode_FLOOR extends RoundingModeEntity{static toString(){return"FLOOR"}static getAddNumber(t){const n=t%10;return 0===n?0:n>0?-n:-(10+n)}}class RoundingMode_HALF_UP extends RoundingModeEntity{static toString(){return"HALF_UP"}static getAddNumber(t){const n=t%10,e=n>=0?1:-1;return Math.abs(n)<5?-1*n:e*(10-Math.abs(n))}}class RoundingMode_HALF_DOWN extends RoundingModeEntity{static toString(){return"HALF_DOWN"}static getAddNumber(t){const n=t%10,e=n>=0?1:-1;return Math.abs(n)<6?-1*n:e*(10-Math.abs(n))}}class RoundingMode_HALF_EVEN extends RoundingModeEntity{static toString(){return"HALF_EVEN"}static getAddNumber(t){let n,e,r=t%100;r<0?(n=-1,e=1&Math.ceil(r/10)):(n=1,e=1&Math.floor(r/10));let i;return i=1===e?5:6,r%=10,Math.abs(r)<i?-1*r:n*(10-Math.abs(r))}}class RoundingMode_UNNECESSARY extends RoundingModeEntity{static toString(){return"UNNECESSARY"}static getAddNumber(t){if(0===t%10)return 0;throw"ArithmeticException"}}class RoundingMode{static valueOf(t){let n;if("string"==typeof t)n=t;else{if(!(t instanceof Object))throw"Unsupported argument "+t;n=t.toString()}const e=[RoundingMode_UP,RoundingMode_DOWN,RoundingMode_FLOOR,RoundingMode_CEILING,RoundingMode_HALF_UP,RoundingMode_HALF_DOWN,RoundingMode_HALF_EVEN,RoundingMode_UNNECESSARY],r=n.toUpperCase();for(let t=0;t<e.length;t++)if(e[t].toString()===r)return e[t];throw"IllegalArgumentException : "+n}static get UP(){return RoundingMode_UP}static get DOWN(){return RoundingMode_DOWN}static get CEILING(){return RoundingMode_CEILING}static get FLOOR(){return RoundingMode_FLOOR}static get HALF_UP(){return RoundingMode_HALF_UP}static get HALF_DOWN(){return RoundingMode_HALF_DOWN}static get HALF_EVEN(){return RoundingMode_HALF_EVEN}static get UNNECESSARY(){return RoundingMode_UNNECESSARY}}class MathContext{constructor(t,n){if(this.precision=0,this.roundingMode=void 0===n?RoundingMode.HALF_UP:n,"number"==typeof t&&(this.precision=t),"string"==typeof t){let n;null!==(n=t.match(/precision=\d+/))&&(n=n[0].substring("precision=".length,n[0].length),this.precision=parseInt(n,10)),null!==(n=t.match(/roundingMode=\w+/))&&(n=n[0].substring("roundingMode=".length,n[0].length),this.roundingMode=RoundingMode.valueOf(n))}if(this.precision<0)throw"IllegalArgumentException"}getPrecision(){return this.precision}getRoundingMode(){return this.roundingMode}equals(t){return t instanceof MathContext&&t.toString()===this.toString()}toString(){return"precision="+this.precision+" roundingMode="+this.roundingMode.toString()}static get UNLIMITED(){return DEFINE.UNLIMITED}static get DECIMAL32(){return DEFINE.DECIMAL32}static get DECIMAL64(){return DEFINE.DECIMAL64}static get DECIMAL128(){return DEFINE.DECIMAL128}}const DEFINE={UNLIMITED:new MathContext(0,RoundingMode.HALF_UP),DECIMAL32:new MathContext(7,RoundingMode.HALF_EVEN),DECIMAL64:new MathContext(16,RoundingMode.HALF_EVEN),DECIMAL128:new MathContext(34,RoundingMode.HALF_EVEN)};let DEFAULT_RANDOM=new Random;class IntegerTool{static string_to_binary_number(t,n){const e=Math.floor(Math.log(1073741823)/Math.log(n));let r=[];const i=[],o=Math.ceil(t.length/e);let a=t.length;for(let i=0;i<o;i++)a-=e,r[i]=a>=0?parseInt(t.substring(a,a+e),n):parseInt(t.substring(0,a+e),n);const s=Math.round(Math.pow(n,e));for(;0!==r.length;){let t=0;for(let n=r.length-1;n>=0;n--){const e=r[n]+t*s;r[n]=e>>>1,t=1&e}i[i.length]=t,0===r[r.length-1]&&r.pop()}r=[];for(let t=0;t<i.length;t++)r[t>>>4]|=i[t]<<(15&t);return r}static string_to_string(t){let n,e=0,r=t.replace(/\s/g,"").toLowerCase();const i=[];null!==(n=r.match(/^[0-9]+/))&&(n=n[0],r=r.substr(n.length),i.push(n)),null!==(n=r.match(/^\.[0-9]+/))&&(n=n[0],r=r.substr(n.length),e+=(n=n.substr(1)).length,i.push(n)),null!==(n=r.match(/^e[+-]?[0-9]+/))&&(n=n[0].substr(1),e-=parseInt(n,10));let o;if(0===e&&(o=i.join("")),e<0){for(let t=0;t<-e;t++)i.push("0");o=i.join("")}else e>0&&(o=0!==(o=(o=i.join("")).substring(0,o.length-e)).length?o:"0");return o}static number_to_binary_number(t){if(t>4294967295)return IntegerTool.string_to_binary_number(IntegerTool.string_to_string(t.toFixed()),10);let n=t;const e=[];for(;0!==n;)e[e.length]=1&n,n>>>=1;const r=[];for(let t=0;t<e.length;t++)r[t>>>4]|=e[t]<<(15&t);return r}static binary_number_to_string(t,n){const e=function(t,e,r){const i=t.length;let o=0;for(let a=0;a<i;a++)r[a]=t[a]+(e.length>=a+1?e[a]:0)+o,r[a]>=n?(o=1,r[a]-=n):o=0;1===o&&(r[i]=1)},r=[0],i=[1];for(let n=0;n<t.length;n++)for(let o=0;o<16;o++)t[n]>>>o&1&&e(i,r,r),e(i,i,i);return r}static ToBigIntegerFromString(t,n){let e=t.replace(/\s/g,"").toLowerCase();const r=e.match(/^[-+]+/);let i=[],o=1;if(null!==r){const t=r[0];e=e.substring(t.length,e.length),-1!==t.indexOf("-")&&(o=-1)}return n?i=IntegerTool.string_to_binary_number(e,n):/^0x/.test(e)?i=IntegerTool.string_to_binary_number(e.substring(2,e.length),16):/^0b/.test(e)?i=IntegerTool.string_to_binary_number(e.substring(2,e.length),2):/^0o/.test(e)?i=IntegerTool.string_to_binary_number(e.substring(2,e.length),8):(e=IntegerTool.string_to_string(e),i=IntegerTool.string_to_binary_number(e,10)),1===i.length&&0===i[0]&&(i=[],o=0),{element:i,_sign:o}}}class BigInteger{constructor(t){if(0===arguments.length)this.element=[],this._sign=0;else{if(1!==arguments.length)throw"BigInteger Unsupported argument "+t;if(this._sign=1,t instanceof BigInteger)this.element=t.element.slice(0),this._sign=t._sign;else if("number"==typeof t){let n=t;n<0&&(this._sign=-1,n=-n),this.element=IntegerTool.number_to_binary_number(n)}else if("string"==typeof t){const n=IntegerTool.ToBigIntegerFromString(t);this.element=n.element,this._sign=n._sign}else if(t instanceof Array){if(2!==t.length||"string"!=typeof t[0])throw"BigInteger Unsupported argument "+arguments;{const n=IntegerTool.ToBigIntegerFromString(t[0],t[1]);this.element=n.element,this._sign=n._sign}}else if(t instanceof Object&&t.unscaledValue&&t.scale){const n=t.unscaledValue(),e=n.scaleByPowerOfTen(-t.scale());this.element=e.element,this._sign=e._sign}else{if(!(t instanceof Object))throw"BigInteger Unsupported argument "+t;{const n=IntegerTool.ToBigIntegerFromString(t.toString());this.element=n.element,this._sign=n._sign}}}}static create(t){return t instanceof BigInteger?t:new BigInteger(t)}static valueOf(t){return BigInteger.create(t)}static _toBigInteger(t){return t instanceof BigInteger?t:new BigInteger(t)}static _toFloat(t){return"number"==typeof t?t:t instanceof BigInteger?t.doubleValue:new BigInteger(t).doubleValue}static _toInteger(t){return"number"==typeof t?Math.trunc(t):t instanceof BigInteger?t.intValue:new BigInteger(t).intValue}static createRandomBigInteger(t,n){const e=n&&n instanceof Random?n:DEFAULT_RANDOM,r=new BigInteger;r._sign=1;const i=BigInteger._toInteger(t),o=1+(i-1>>4);if(0===i)return BigInteger.ZERO;let a;for(let t=0,n=0;t<o;t++)0===n?(a=e.nextInt(),r.element[t]=65535&a,n=1):(r.element[t]=a>>>16&65535,n=0);return i%16!=0&&(r.element[r.element.length-1]&=(1<<i%16)-1),r._memory_reduction(),r}static probablePrime(t,n,e,r){const i=e?BigInteger._toInteger(e):100,o=r?BigInteger._toInteger(r):500;for(let e=0;e<o;e++){const e=BigInteger.createRandomBigInteger(t,n);if(e.isProbablePrime(i))return e}throw"probablePrime "+r}equals(t){const n=BigInteger._toBigInteger(t);if(this.signum()!==n.signum())return!1;if(this.element.length!==n.element.length)return!1;for(let t=0;t<n.element.length;t++)if(this.element[t]!==n.element[t])return!1;return!0}toString(t){const n=t?BigInteger._toInteger(t):10,e=Math.floor(Math.log(1073741823)/Math.log(n)),r=Math.round(Math.pow(n,e)),i=[];for(let t=0;t<e;t++)i[t]="0";const o=i.join(""),a=IntegerTool.binary_number_to_string(this.element,r),s=[];let c="";this.signum()<0&&(s[s.length]="-");for(let t=a.length-1;t>=0;t--)c=a[t].toString(n),t<a.length-1&&(s[s.length]=o.substring(0,e-c.length)),s[s.length]=c;return s.join("")}getShort(t){const n=BigInteger._toInteger(t);return n<0||this.element.length<=n?0:this.element[n]}get intValue(){let t=this.getShort(0)+(this.getShort(1)<<16);return(t&=4294967295)>0&&this._sign<0&&(t=-t),t}get longValue(){let t=0;for(let n=3;n>=0;n--)t*=65536,t+=this.getShort(n);return this._sign<0&&(t=-t),t}get doubleValue(){return parseFloat(this.toString())}clone(){return new BigInteger(this)}isZero(){return this._memory_reduction(),0===this._sign}isOne(){return 1===this._sign&&1===this.element.length&&1===this.element[0]}isPositive(){return this._memory_reduction(),this._sign>0}isNegative(){return this._sign<0}isNotNegative(){return this._sign>=0}getLowestSetBit(){for(let t=0;t<this.element.length;t++)if(0!==this.element[t]){const n=this.element[t];for(let e=0;e<16;e++)if(0!=(n>>>e&1))return 16*t+e}return-1}bitLength(){for(let t=this.element.length-1;t>=0;t--)if(0!==this.element[t]){const n=this.element[t];for(let e=15;e>=0;e--)if(0!=(n>>>e&1))return 16*t+e+1}return 0}bitCount(){let t;const n=(t=this._sign>=0?this:this.add(new BigInteger(1))).bitLength();let e=0,r=0;for(let i=0;e<n;i++){const o=t.element[i];for(let t=0;t<16&&e<n;t++,e++)0!=(o>>>t&1)&&(r+=1)}return r}getTwosComplement(t){const n=this.clone();if(n._sign>=0)return n;{n._sign=1;const e=void 0!==t?t:n.bitLength(),r=n.element;for(let t=0;t<r.length;t++)r[t]^=65535;return e%16!=0&&(r[r.length-1]&=(1<<e%16)-1),n._add(new BigInteger(1)),n}}_and(t){const n=this,e=BigInteger._toBigInteger(t),r=n.signum(),i=e.signum(),o=Math.max(n.bitLength(),e.bitLength()),a=n.getTwosComplement(o).element,s=e.getTwosComplement(o).element,c=Math.max(a.length,s.length);this.element=[];for(let t=0;t<c;t++){const n=t>=a.length?0:a[t],e=t>=s.length?0:s[t];this.element[t]=n&e}return this._memory_reduction(),1===r||1===i?this._sign=1:-1===this._sign&&(this.element=this.getTwosComplement(o).element,this._memory_reduction()),this}and(t){return this.clone()._and(t)}_or(t){const n=this,e=BigInteger._toBigInteger(t),r=n.signum(),i=e.signum(),o=Math.max(n.bitLength(),e.bitLength()),a=n.getTwosComplement(o).element,s=e.getTwosComplement(o).element,c=Math.max(a.length,s.length);this.element=[];for(let t=0;t<c;t++){const n=t>=a.length?0:a[t],e=t>=s.length?0:s[t];this.element[t]=n|e}return this._sign=-1===r||-1===i?-1:Math.max(r,i),-1===this._sign&&(this.element=this.getTwosComplement(o).element,this._memory_reduction()),this}or(t){return this.clone()._or(t)}_xor(t){const n=this,e=BigInteger._toBigInteger(t),r=n.signum(),i=e.signum(),o=Math.max(n.bitLength(),e.bitLength()),a=n.getTwosComplement(o).element,s=e.getTwosComplement(o).element,c=Math.max(a.length,s.length);this.element=[];for(let t=0;t<c;t++){const n=t>=a.length?0:a[t],e=t>=s.length?0:s[t];this.element[t]=n^e}return this._memory_reduction(),this._sign=0!==r&&r!==i?-1:1,-1===this._sign&&(this.element=this.getTwosComplement(o).element,this._memory_reduction()),this}xor(t){return this.clone()._xor(t)}_not(){return this._add(new BigInteger(1))._negate()}not(){return this.clone()._not()}_andNot(t){const n=BigInteger._toBigInteger(t);return this._and(n.not())}andNot(t){return this.clone()._andNot(t)}_nand(t){return this._andNot(t)}nand(t){return this.andNot(t)}_orNot(t){const n=BigInteger._toBigInteger(t);return this._or(n)._not()}orNot(t){return this.clone()._orNot(t)}_nor(t){return this._orNot(t)}nor(t){return this.orNot(t)}_memory_allocation(t){const n=BigInteger._toInteger(t),e=this.element.length<<4;if(e<n){const t=1+((n-e-1&4294967280)>>>4);for(let n=0;n<t;n++)this.element[this.element.length]=0}}_memory_reduction(){for(let t=this.element.length-1;t>=0;t--)if(0!==this.element[t])return void(t<this.element.length-1&&this.element.splice(t+1,this.element.length-t-1));this._sign=0,this.element=[]}gcd(t){let n,e=this,r=BigInteger._toBigInteger(t);for(;0!==r.signum();)n=e.remainder(r),e=r,r=n;return e}extgcd(t){const n=BigInteger._toBigInteger(t),e=new BigInteger(1),r=new BigInteger(0);let i,o,a,s,c=this,u=n,l=e,h=r,g=r,f=e;for(;0!==u.signum();){const t=c.divideAndRemainder(u);o=t[0],i=t[1],a=l.subtract(o.multiply(h)),s=g.subtract(o.multiply(f)),l=h,h=a,g=f,f=s,c=u,u=i}return[l,g,c]}lcm(t){const n=BigInteger._toBigInteger(t);return this.mul(n).div(this.gcd(n))}_abs(){return this._sign*=this._sign,this}abs(){return this.clone()._abs()}_negate(){return this._sign*=-1,this}negate(){return this.clone()._negate()}signum(){return 0===this.element.length?0:this._sign}sign(){return this.signum()}compareToAbs(t){const n=BigInteger._toBigInteger(t);if(this.element.length<n.element.length)return-1;if(this.element.length>n.element.length)return 1;for(let t=this.element.length-1;t>=0;t--)if(this.element[t]!==n.element[t]){const e=this.element[t]-n.element[t];return 0===e?0:e>0?1:-1}return 0}compareTo(t){const n=BigInteger._toBigInteger(t);return this.signum()!==n.signum()?this._sign>n._sign?1:-1:0===this.signum()?0:this.compareToAbs(n)*this._sign}max(t){const n=BigInteger._toBigInteger(t);return this.compareTo(n)>=0?this.clone():n.clone()}min(t){const n=BigInteger._toBigInteger(t);return this.compareTo(n)>=0?n.clone():this.clone()}clip(t,n){const e=BigInteger._toBigInteger(t),r=BigInteger._toBigInteger(n),i=e.compareTo(r);if(1===i)throw"clip(min, max) error. (min > max)->("+e+" > "+r+")";return 0===i?e:1===this.compareTo(r)?r:-1===this.compareTo(e)?e:this}_shift(t){let n=BigInteger._toInteger(t);if(0===n)return this;const e=this.element;if(1===n){let t=e.length-1;for(0!=(32768&e[t])&&(e[e.length]=1);t>=0;t--)e[t]<<=1,e[t]&=65535,t>0&&0!=(32768&e[t-1])&&(e[t]+=1)}else if(-1===n){for(let t=0;t<e.length;t++)e[t]>>>=1,t<e.length-1&&0!=(1&e[t+1])&&(e[t]|=32768);0===e[e.length-1]&&e.pop()}else{if(n>=16){const t=n>>>4;for(let n=e.length-1;n>=0;n--)e[n+t]=e[n];for(let n=t-1;n>=0;n--)e[n]=0;n&=15}else if(n<=-16){const t=-n>>>4;e.splice(0,t),n+=t<<4}if(0!==n)if(0<n){let t=0;for(let r=0;r<e.length;r++)e[r]=(e[r]<<n)+t,e[r]>65535?(t=e[r]>>>16,e[r]&=65535):t=0;0!==t&&(e[e.length]=t)}else{n=-n;for(let t=0;t<e.length;t++)t!==e.length-1?(e[t]+=e[t+1]<<16,e[t]>>>=n,e[t]&=65535):e[t]>>>=n;0===e[e.length-1]&&e.pop()}}return this}shift(t){return this.clone()._shift(t)}shiftLeft(t){return this.shift(t)}shiftRight(t){return this.shift(-t)}_add(t){const n=this,e=BigInteger._toBigInteger(t);let r=n.element,i=e.element;if(n._sign===e._sign){this._memory_allocation(i.length<<4);let t=0;for(let n=0;n<r.length;n++)r[n]+=(i.length>=n+1?i[n]:0)+t,r[n]>65535?(t=1,r[n]&=65535):t=0;0!==t&&(r[r.length]=t)}else{const t=n.compareToAbs(e);if(0===t)return this.element=[],this._sign=1,this;if(-1===t){this._sign=e._sign;const t=r;r=i.slice(0),i=t}let o=0;for(let t=0;t<r.length;t++)r[t]-=(i.length>=t+1?i[t]:0)+o,r[t]<0?(r[t]+=65536,o=1):o=0;this.element=r,this._memory_reduction()}return this}add(t){return this.clone()._add(t)}_subtract(t){const n=BigInteger._toBigInteger(t),e=n._sign,r=this._add(n._negate());return n._sign=e,r}subtract(t){return this.clone()._subtract(t)}sub(t){return this.subtract(t)}_multiply(t){const n=this.multiply(t);return this.element=n.element,this._sign=n._sign,this}multiply(t){const n=BigInteger._toBigInteger(t),e=new BigInteger,r=new BigInteger,i=n,o=this.element,a=i.element,s=e.element;for(let t=0;t<o.length;t++){r.element=[];const n=r.element;let i=0;for(let e=0;e<a.length;e++)n[e]=o[t]*a[e]+i,n[e]>65535?(i=n[e]>>>16,n[e]&=65535):i=0;0!==i&&(n[n.length]=i);for(let e=n.length-1;e>=0;e--)n[e+t]=n[e];for(let e=t-1;e>=0;e--)n[e]=0;i=0,e._memory_allocation(n.length<<4);for(let e=t;e<s.length;e++)s[e]+=(n.length>=e+1?n[e]:0)+i,s[e]>65535?(i=1,s[e]&=65535):i=0;0!==i&&(s[s.length]=i)}return e._sign=this._sign*n._sign,e}mul(t){return this.multiply(t)}_divideAndRemainder(t){const n=BigInteger._toBigInteger(t),e=[];if(0===n.signum())throw"BigInteger divideAndRemainder ["+n.toString()+"]";const r=this.compareToAbs(n);if(r<0)return e[0]=new BigInteger(0),e[1]=this.clone(),e;if(0===r)return e[0]=new BigInteger(1),e[0]._sign=this._sign*n._sign,e[1]=new BigInteger(0),e;const i=new BigInteger(1),o=this.bitLength()-n.bitLength(),a=this.clone()._abs(),s=n.shift(o)._abs(),c=new BigInteger;for(let t=0;t<=o&&(a.compareToAbs(s)>=0&&(a._subtract(s),c._add(i)),t!==o);t++)s._shift(-1),c._shift(1);return e[0]=c,e[0]._sign=this._sign*n._sign,e[1]=a,e[1]._sign=this._sign,e}divideAndRemainder(t){return this.clone()._divideAndRemainder(t)}_divide(t){return this._divideAndRemainder(t)[0]}divide(t){return this.clone()._divide(t)}div(t){return this.divide(t)}_remainder(t){return this._divideAndRemainder(t)[1]}remainder(t){return this.clone()._remainder(t)}rem(t){return this.remainder(t)}_mod(t){const n=BigInteger._toBigInteger(t);if(n.signum()<0)return null;const e=this._divideAndRemainder(n);return e[1]instanceof BigInteger?e[1].signum()>=0?e[1]:e[1]._add(n):null}mod(t){return this.clone()._mod(t)}_setBit(t){const n=BigInteger._toInteger(t);return this._memory_allocation(n+1),this.element[n>>>4]|=1<<(15&n),this}setBit(t){const n=BigInteger._toInteger(t);return this.clone()._setBit(n)}_flipBit(t){const n=BigInteger._toInteger(t);return this._memory_allocation(n+1),this.element[n>>>4]^=1<<(15&n),this._memory_reduction(),this}flipBit(t){const n=BigInteger._toInteger(t);return this.clone()._flipBit(n)}clearBit(t){const n=BigInteger._toInteger(t),e=this.clone();return e.element[n>>>4]&=~(1<<(15&n)),e._memory_reduction(),e}testBit(t){const n=BigInteger._toInteger(t);return 0!=(this.element[n>>>4]>>>(15&n)&1)}pow(t){const n=new BigInteger(t);let e=BigInteger._toBigInteger(this),r=BigInteger._toBigInteger(1);for(;0!==n.element.length;)0!=(1&n.element[0])&&(r=r.multiply(e)),e=e.multiply(e),n._shift(-1);return r}modPow(t,n){const e=BigInteger._toBigInteger(n);let r=new BigInteger(this),i=new BigInteger(1);const o=new BigInteger(t);for(;0!==o.element.length;)0!=(1&o.element[0])&&(i=i.multiply(r).mod(e)),r=r.multiply(r).mod(e),o._shift(-1);return i}modInverse(t){const n=BigInteger._toBigInteger(t),e=this.extgcd(t),r=new BigInteger(1);return 0!==e[2].compareTo(r)?null:e[0]._add(n)._mod(n)}isProbablePrime(t){const n=this.element;if(0===n.length||1===n.length&&n[0]<=2)return!0;if(0==(1&n[0]))return!1;const e=void 0!==t?BigInteger._toInteger(t):100,r=new BigInteger(0),i=new BigInteger(1),o=this,a=o.bitLength(),s=o.subtract(i),c=s.getLowestSetBit(),u=s.shift(-c);if(e<=0)return!1;for(let t=0;t<e;t++){let t;do{t=BigInteger.createRandomBigInteger(a)}while(0===t.compareTo(r)||-1!==t.compareTo(o));let n=u,e=t.modPow(n,o);for(;;){if(n.equals(s)||e.equals(i)||e.equals(s))break;e=e.mul(e)._mod(o),n=n.shiftLeft(1)}if(!e.equals(s)&&0==(1&n.element[0]))return!1}return!0}nextProbablePrime(t,n){const e=void 0!==t?BigInteger._toInteger(t)>>1:50,r=void 0!==n?BigInteger._toInteger(n):1e5,i=this.clone();for(let t=0;t<r;t++)if(i._add(BigInteger.ONE),i.isProbablePrime(e))return i;throw"nextProbablePrime ["+r+"]"}factorial(){const t=BigInteger._toInteger(this);let n=BigInteger.ONE;for(let e=2;e<=t;e++)n=n.multiply(e);return n}scaleByPowerOfTen(t){const n=BigInteger._toInteger(t);return 0===n?this:n>0?this.mul(BigInteger.TEN.pow(n)):this.div(BigInteger.TEN.pow(n))}static setDefaultRandom(t){DEFAULT_RANDOM=t}static getDefaultRandom(){return DEFAULT_RANDOM}static get ONE(){return DEFINE$1.ONE}static get TWO(){return DEFINE$1.TWO}static get TEN(){return DEFINE$1.TEN}static get ZERO(){return DEFINE$1.ZERO}static get MINUS_ONE(){return DEFINE$1.MINUS_ONE}}const DEFINE$1={ONE:new BigInteger(1),TWO:new BigInteger(2),TEN:new BigInteger(10),ZERO:new BigInteger(0),MINUS_ONE:new BigInteger(-1)};let DEFAULT_CONTEXT=MathContext.DECIMAL128;class DecimalTool{static ToBigDecimalFromString(t){let n,e=0,r=t.replace(/\s/g,"").toLowerCase(),i="";return null!==(n=r.match(/^[+-]+/))&&(n=n[0],r=r.substr(n.length),-1!==n.indexOf("-")&&(i+="-")),null!==(n=r.match(/^[0-9]+/))&&(n=n[0],r=r.substr(n.length),i+=n),null!==(n=r.match(/^\.[0-9]+/))&&(n=n[0],r=r.substr(n.length),e+=(n=n.substr(1)).length,i+=n),null!==(n=r.match(/^e[+-]?[0-9]+/))&&(n=n[0].substr(1),e-=parseInt(n,10)),{scale:e,integer:new BigInteger([i,10])}}static ToBigDecimalFromNumber(t){if(t===Math.floor(t))return{scale:0,integer:new BigInteger(Math.round(t))};{let n=Math.trunc(Math.log(Math.abs(t))/Math.log(10)),e=t/Math.pow(10,n);n=-n;for(let t=0;t<14&&(e*=10,n+=1,!(Math.abs(e-Math.round(e))<=Number.EPSILON));t++);return{scale:n,integer:new BigInteger(e)}}}}class BigDecimal{constructor(t){this._scale=0,this.default_context=DEFAULT_CONTEXT;let n=null;if(arguments.length>1)throw"BigDecimal Unsupported argument["+arguments.length+"]";if(t instanceof BigDecimal)this.integer=t.integer.clone(),this._scale=t._scale,this.int_string=t.int_string,this.default_context=t.default_context;else if(t instanceof BigInteger)this.integer=t.clone();else if("number"==typeof t){const n=DecimalTool.ToBigDecimalFromNumber(t);this.integer=n.integer,this._scale=n.scale}else if(t instanceof Array){if(t.length>=1)if("string"==typeof t[0]||t[0]instanceof String){const n=DecimalTool.ToBigDecimalFromString(t[0]);this.integer=n.integer,this._scale=n.scale}else this.integer=new BigInteger(t[0]);t.length>=2&&("number"==typeof t[1]||t[1]instanceof Number?(this._scale=t[1],t.length>=3&&(this.default_context=t[2]),t.length>=4&&(n=t[3])):(t.length>=2&&(this.default_context=t[1]),t.length>=3&&(n=t[2])))}else if("string"==typeof t){const n=DecimalTool.ToBigDecimalFromString(t);this.integer=n.integer,this._scale=n.scale}else if(t instanceof Object&&void 0!==t.scale&&void 0!==t.default_context)this.integer=new BigInteger(t.integer),t.scale&&(this._scale=t.scale),t.default_context&&(this.default_context=t.default_context),t.context&&(n=t.context);else{if(!(t instanceof Object))throw"BigDecimal Unsupported argument "+arguments;{const n=DecimalTool.ToBigDecimalFromString(t.toString());this.integer=n.integer,this._scale=n.scale}}if(n){const t=this.round(n);this.integer=t.integer,this._scale=t._scale,delete this.int_string}if(!(this.integer instanceof BigInteger&&this.default_context instanceof MathContext))throw"BigDecimal Unsupported argument "+arguments}static create(t){return t instanceof BigDecimal?t:new BigDecimal(t)}static valueOf(t,n){return new BigDecimal(1===arguments.length?t:[t,n])}static _toBigDecimal(t){return t instanceof BigDecimal?t:new BigDecimal(t)}static _toBigInteger(t){return t instanceof BigInteger?t:t instanceof BigDecimal?t.toBigInteger():new BigInteger(t)}static _toFloat(t){return"number"==typeof t?t:t instanceof BigDecimal?t.doubleValue:new BigDecimal(t).doubleValue}static _toInteger(t){return"number"==typeof t?Math.trunc(t):t instanceof BigInteger?t.intValue:new BigInteger(t).intValue}_getUnsignedIntegerString(){return void 0===this.int_string&&(this.int_string=this.integer.toString(10).replace(/^-/,"")),this.int_string}clone(){return new BigDecimal(this)}scale(){return this._scale}signum(){return this.integer.signum()}sign(){return this.signum()}precision(){return this._getUnsignedIntegerString().length}unscaledValue(){return new BigInteger(this.integer)}toScientificNotation(t){const n=BigDecimal._toInteger(t),e=this._getUnsignedIntegerString();let r=this.scale();const i=[];let o,a;if(-1===this.signum()&&(i[i.length]="-"),(r=-n-r)>=0)for(i[i.length]=e,o=0;o<r;o++)i[i.length]="0";else if(0<(a=this.precision()+r))i[i.length]=e.substring(0,a),i[i.length]=".",i[i.length]=e.substring(a,e.length);else{for(a=-a,i[i.length]="0.",o=0;o<a;o++)i[i.length]="0";i[i.length]=e}return i[i.length]="E",n>=0&&(i[i.length]="+"),i[i.length]=n,i.join("")}toString(){const t=-this.scale()+(this.precision()-1);return this.scale()>=0&&t>=-6?this.toPlainString():this.toScientificNotation(t)}toEngineeringString(){const t=-this.scale()+(this.precision()-1);return this.scale()>=0&&t>=-6?this.toPlainString():this.toScientificNotation(3*Math.floor(t/3))}toPlainString(){return 0===this.scale()?this.signum()<0?"-"+this._getUnsignedIntegerString():this._getUnsignedIntegerString():this.toScientificNotation(0).match(/^[^E]*/)[0]}ulp(){return new BigDecimal([BigInteger.ONE,this.scale(),this.default_context])}setScale(t,n,e){const r=BigDecimal._toInteger(t);if(this.scale()===r)return this.clone();const i=void 0!==n?RoundingMode.valueOf(n):RoundingMode.UNNECESSARY,o=void 0!==e?e:this.default_context;let a=this._getUnsignedIntegerString();const s=this.signum(),c=s>=0?"":"-",u=r-this.scale();if(0<=u){let t;for(t=0;t<u;t++)a+="0";return new BigDecimal([new BigInteger(c+a),r,o])}const l=a.length+u,h=l+1;if(l<=0){const t=(s+i.getAddNumber(s))/10;return new BigDecimal([new BigInteger(t),r,o])}{const t=a.match(/0+$/),n=null!==t?t[0].length:0;if(n+u>=0||i===RoundingMode.DOWN)return new BigDecimal([new BigInteger(c+a.substring(0,l)),r,o])}{const t=(a=a.substring(0,h)).length>1?2:1,n=parseInt(a.substring(a.length-t,a.length))*s,e=new BigInteger(c+a),u=new BigInteger(i.getAddNumber(n));return a=e.add(u).toString(),new BigDecimal([new BigInteger(a.substring(0,a.length-1)),r,o])}}round(t){if(!(t instanceof MathContext))throw"not MathContext";const n=t.getPrecision(),e=n-this.precision();if(0===e||0===n)return this.clone();const r=this.setScale(this.scale()+e,t.getRoundingMode(),t);if(e>0)return r;if(r.precision()===t.getPrecision())return r;const i=r.integer.signum()>=0?"":"-",o=r._getUnsignedIntegerString(),a=i+o.substring(0,o.length-1);return new BigDecimal([new BigInteger(a),r.scale()-1,t])}abs(t){const n=this.clone();return n.integer=n.integer.abs(),void 0===t?n:n.round(t)}plus(t){const n=this.clone();return void 0===t?n:n.round(t)}negate(t){const n=this.clone();return n.integer=n.integer.negate(),void 0===t?n:n.round(t)}compareTo(t){const n=this,e=BigDecimal._toBigDecimal(t);{const t=n.signum(),r=e.signum();if(0===t&&t===r)return 0;if(0===t)return-r;if(0===r)return t}if(n._scale===e._scale)return n.integer.compareTo(e.integer);if(n._scale>e._scale){const t=e.setScale(n._scale);return n.integer.compareTo(t.integer)}{const t=n.setScale(e._scale);return t.integer.compareTo(e.integer)}}isZero(){return 0===this.compareTo(BigDecimal.ZERO)}isOne(){return 0===this.compareTo(BigDecimal.ONE)}isPositive(){return 1===this.compareTo(BigDecimal.ZERO)}isNegative(){return-1===this.compareTo(BigDecimal.ZERO)}isNotNegative(){return this.compareTo(BigDecimal.ZERO)>=0}equals(t){if(t instanceof BigDecimal)return this._scale===t._scale&&this.integer.equals(t.integer);if("string"==typeof t||t instanceof String){const n=BigDecimal._toBigDecimal(t);return this._scale===n._scale&&this.integer.equals(n.integer)}return 0===this.compareTo(t)}max(t){const n=BigDecimal._toBigDecimal(t);return this.compareTo(n)>=0?this.clone():n.clone()}min(t){const n=BigDecimal._toBigDecimal(t);return this.compareTo(n)<=0?this.clone():n.clone()}clip(t,n){const e=BigDecimal._toBigDecimal(t),r=BigDecimal._toBigDecimal(n),i=e.compareTo(r);if(1===i)throw"clip(min, max) error. (min > max)->("+e+" > "+r+")";return 0===i?e:1===this.compareTo(r)?r:-1===this.compareTo(e)?e:this}scaleByPowerOfTen(t){const n=BigDecimal._toInteger(t),e=this.clone();return e._scale=this.scale()-n,e}movePointLeft(t){const n=BigDecimal._toInteger(t);let e=this.scaleByPowerOfTen(-n);return e=e.setScale(Math.max(this.scale()+n,0))}movePointRight(t){const n=BigDecimal._toInteger(t);let e=this.scaleByPowerOfTen(n);return e=e.setScale(Math.max(this.scale()-n,0))}stripTrailingZeros(){const t=this.signum()>=0?"":"-",n=this.integer.toString(10).replace(/^-/,""),e=n.match(/0+$/);let r=null!==e?e[0].length:0;r===n.length&&(r=n.length-1);const i=this.scale()-r;return new BigDecimal([new BigInteger(t+n.substring(0,n.length-r)),i,this.default_context])}add(t,n){const e=BigDecimal._toBigDecimal(t),r=n||e.default_context,i=this,o=e,a=Math.max(i._scale,o._scale);if(i._scale===o._scale)return new BigDecimal([i.integer.add(o.integer),a,r,r]);if(i._scale>o._scale){const t=o.setScale(i._scale);return new BigDecimal([i.integer.add(t.integer),a,r,r])}{const t=i.setScale(o._scale);return new BigDecimal([t.integer.add(o.integer),a,r,r])}}subtract(t,n){const e=BigDecimal._toBigDecimal(t),r=n||e.default_context,i=this,o=e,a=Math.max(i._scale,o._scale);if(i._scale===o._scale)return new BigDecimal([i.integer.subtract(o.integer),a,r,r]);if(i._scale>o._scale){const t=o.setScale(i._scale);return new BigDecimal([i.integer.subtract(t.integer),a,r,r])}{const t=i.setScale(o._scale);return new BigDecimal([t.integer.subtract(o.integer),a,r,r])}}sub(t,n){return this.subtract(t,n)}multiply(t,n){const e=BigDecimal._toBigDecimal(t),r=n||e.default_context,i=this,o=e,a=i.integer.multiply(o.integer),s=i._scale+o._scale;return new BigDecimal([a,s,r])}mul(t,n){return this.multiply(t,n)}divideToIntegralValue(t,n){const e=BigDecimal._toBigDecimal(t),r=n||e.default_context,i=function(t){let n,e="1";for(n=0;n<t;n++)e+="0";return new BigInteger(e)};if(0===e.compareTo(BigDecimal.ZERO))throw"ArithmeticException";const o=this,a=e;let s=o.integer,c=a.integer;const u=o._scale-a._scale;o._scale>a._scale?c=c.multiply(i(u)):o._scale<a._scale&&(s=s.multiply(i(-u)));const l=s.divide(c),h=l.signum();if(0!==h){const t=l.toString(10).replace(/^-/,"");if(0!==r.getPrecision()&&t.length>r.getPrecision())throw"ArithmeticException";if(t.length<=-u){const n=t.match(/0+$/),e=null!==n?n[0].length:0,i=h>=0?"":"-";return new BigDecimal([new BigInteger(i+t.substring(0,t.length-e)),-e,r])}}let g=new BigDecimal(l);return g=g.setScale(u,RoundingMode.UP),g=g.round(r),g.default_context=r,g}divideAndRemainder(t,n){const e=BigDecimal._toBigDecimal(t),r=n||e.default_context,i=this.divideToIntegralValue(e,r);return[i,this.subtract(i.multiply(e,r),r)]}rem(t,n){return this.divideAndRemainder(t,n)[1]}mod(t,n){const e=this.rem(t,n);if(e.compareTo(BigDecimal.ZERO)<0)return e.add(t,n)}divide(t,n){const e=this,r=BigDecimal._toBigDecimal(t);let i=null,o=null,a=0,s=!1;if(n&&n.scale?(s=!1,a=n.scale):(s=!0,a=n&&(n.roundingMode||n.context)?e.scale():e.scale()-r.scale()),n&&n.context?(i=n.context.getRoundingMode(),a=n.context.getPrecision(),o=n.context):o=this.default_context,i=n&&n.roundingMode?n.roundingMode:o.getRoundingMode(),0===r.compareTo(BigDecimal.ZERO))throw"ArithmeticException";let c;const u=[];let l,h,g,f;f=BigDecimal.ZERO;const m=o.getPrecision(),_=0!==m?m+8:262143;c=e;for(let t=0;t<_&&(l=c.divideAndRemainder(r,MathContext.UNLIMITED),h=l[0],g=l[1],f=f.add(h.scaleByPowerOfTen(-t),MathContext.UNLIMITED),0!==g.compareTo(BigDecimal.ZERO));t++){if(0===m){if(u[g._getUnsignedIntegerString()])throw"ArithmeticException "+f+"["+g._getUnsignedIntegerString()+"]";u[g._getUnsignedIntegerString()]=!0}c=g.scaleByPowerOfTen(1)}if(s)try{f=f.setScale(a,i)}catch(t){}else f=f.setScale(a,i);return f=f.round(o)}div(t,n){return this.divide(t,n)}toBigInteger(){const t=this.toPlainString().replace(/\.\d*$/,"");return new BigInteger(t)}toBigIntegerExact(){const t=this.setScale(0,RoundingMode.UNNECESSARY);return new BigInteger(t.toPlainString())}get intValue(){return 4294967295&this.toBigInteger().intValue}get intValueExact(){const t=this.toBigIntegerExact().intValue;if(t<-2147483648||2147483647<t)throw"ArithmeticException";return t}get floatValue(){const t=this.precision();return MathContext.DECIMAL32.getPrecision()<t?this.signum()>=0?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY:parseFloat(this.toEngineeringString())}get doubleValue(){const t=this.precision();return MathContext.DECIMAL64.getPrecision()<t?this.signum()>=0?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY:parseFloat(this.toEngineeringString())}pow(t,n){let e=BigDecimal._toInteger(t);const r=n||this.default_context;if(Math.abs(e)>999999999)throw"ArithmeticException";if(0===r.getPrecision()&&e<0)throw"ArithmeticException";if(r.getPrecision()>0&&e>r.getPrecision())throw"ArithmeticException";let i,o;for(i=this.clone(),o=BigDecimal.ONE;0!==e;)0!=(1&e)&&(o=o.multiply(i,MathContext.UNLIMITED)),i=i.multiply(i,MathContext.UNLIMITED),e>>>=1;return o.round(r)}static setDefaultContext(t){DEFAULT_CONTEXT=t||MathContext.DECIMAL128}static getDefaultContext(){return DEFAULT_CONTEXT}static get ONE(){const t=new BigDecimal(DEFINE$2.ONE);return t.default_context=DEFAULT_CONTEXT,t}static get TWO(){const t=new BigDecimal(DEFINE$2.TWO);return t.default_context=DEFAULT_CONTEXT,t}static get TEN(){const t=new BigDecimal(DEFINE$2.TEN);return t.default_context=DEFAULT_CONTEXT,t}static get ZERO(){const t=new BigDecimal(DEFINE$2.ZERO);return t.default_context=DEFAULT_CONTEXT,t}static get MINUS_ONE(){const t=new BigDecimal(DEFINE$2.MINUS_ONE);return t.default_context=DEFAULT_CONTEXT,t}}const DEFINE$2={ZERO:new BigDecimal(0),ONE:new BigDecimal(1),TWO:new BigDecimal(2),TEN:new BigDecimal(10),MINUS_ONE:new BigDecimal(-1)};BigDecimal.RoundingMode=RoundingMode,BigDecimal.MathContext=MathContext;class FractionTool{static to_fraction_data_from_number_string(t){let n,e=0,r=t.replace(/\s/g,"").toLowerCase();const i=[];if(null!==(n=r.match(/^[+-]+/))&&(n=n[0],r=r.substr(n.length),-1!==n.indexOf("-")&&i.push("-")),null!==(n=r.match(/^[0-9]+/))&&(n=n[0],r=r.substr(n.length),i.push(n)),0===r.length)return new Fraction([new BigInteger([i.join(""),10]),BigInteger.ONE]);let o=null;if(/[()'"[\]]/.test(r)){const t=r.match(/([^.]*)\.(\d*)[(['"](\d+)[)\]'"](.*)/);if(null===t)throw"Fraction Unsupported argument "+r;const n=t[2].length,e=t[3];r=0===n?t[1]+t[4]:t[1]+"."+t[2]+t[4];const i=new BigInteger([e,10]),a=[];for(let t=0;t<e.length;t++)a.push("9");const s=new BigInteger([a.join(""),10]);o=(o=new Fraction([i,s])).scaleByPowerOfTen(-n)}null!==(n=r.match(/^\.[0-9]+/))&&(n=n[0],r=r.substr(n.length),e+=(n=n.substr(1)).length,i.push(n)),null!==(n=r.match(/^e[+-]?[0-9]+/))&&(n=n[0].substr(1),e-=parseInt(n,10));let a=null;{let t=null,n=null;if(0===e&&(t=new BigInteger([i.join(""),10]),n=BigInteger.ONE),e<0){for(let t=0;t<-e;t++)i.push("0");t=new BigInteger([i.join(""),10]),n=BigInteger.ONE}else if(e>0){t=new BigInteger([i.join(""),10]);const r=["1"];for(let t=0;t<e;t++)r.push("0");n=new BigInteger([r.join(""),10])}a=new Fraction([t,n])}return o&&(a=a.add(o)),a}static to_fraction_data_from_fraction_string(t){if(-1===t.indexOf("/"))return FractionTool.to_fraction_data_from_number_string(t);{const n=t.split("/"),e=FractionTool.to_fraction_data_from_number_string(n[0]),r=FractionTool.to_fraction_data_from_number_string(n[1]);return e.div(r)}}static to_fraction_data_from_number(t){let n=null,e=null;if(t===Math.floor(t))n=new BigInteger(t),e=BigInteger.ONE;else{let r=Math.trunc(Math.log(Math.abs(t))/Math.log(10)),i=t/Math.pow(10,r);r=-r;for(let t=0;t<14&&(i*=10,r+=1,!(Math.abs(i-Math.round(i))<=Number.EPSILON));t++);if(r<=0)n=new BigInteger(t),e=BigInteger.ONE;else{n=new BigInteger(i);const t=["1"];for(let n=0;n<r;n++)t.push("0");e=new BigInteger([t.join(""),10])}}return new Fraction([n,e])}static normalization(t){if(!t.denominator.equals(BigInteger.ONE)){if(t.denominator.equals(BigInteger.MINUS_ONE))return t.numerator=t.numerator.negate(),void(t.denominator=BigInteger.ONE);if(t.numerator.equals(BigInteger.ZERO))return void(t.denominator=BigInteger.ONE);const n=t.numerator.gcd(t.denominator);let e=t.numerator.div(n),r=t.denominator.div(n);r.sign()<0&&(e=e.negate(),r=r.negate()),t.numerator=e,t.denominator=r}}}class Fraction{constructor(t){if(this.numerator=null,this.denominator=null,0===arguments.length)this.numerator=BigInteger.ZERO,this.denominator=BigInteger.ONE;else{if(1!==arguments.length)throw"Fraction Unsupported argument "+t;{let n=!1;if("number"==typeof t){const n=FractionTool.to_fraction_data_from_number(t);this.numerator=n.numerator,this.denominator=n.denominator}else if("string"==typeof t){const n=FractionTool.to_fraction_data_from_fraction_string(t);this.numerator=n.numerator,this.denominator=n.denominator}else if(t instanceof BigInteger)this.numerator=t,this.denominator=BigInteger.ONE;else if(t instanceof Fraction)this.numerator=t.numerator,this.denominator=t.denominator;else if(t instanceof Array&&2===t.length)this.numerator=t[0]instanceof BigInteger?t[0]:new BigInteger(t[0]),this.denominator=t[1]instanceof BigInteger?t[1]:new BigInteger(t[1]),n=!0;else if(t instanceof Object&&t.numerator&&t.denominator)this.numerator=t.numerator instanceof BigInteger?t.numerator:new BigInteger(t.numerator),this.denominator=t.denominator instanceof BigInteger?t.denominator:new BigInteger(t.denominator),n=!0;else if(t instanceof BigDecimal){const n=new Fraction(t.unscaledValue()),e=n.scaleByPowerOfTen(-t.scale());this.numerator=e.numerator,this.denominator=e.denominator}else{if(!(t instanceof Object))throw"Fraction Unsupported argument "+t;{const n=FractionTool.to_fraction_data_from_fraction_string(t.toString());this.numerator=n.numerator,this.denominator=n.denominator}}n&&FractionTool.normalization(this)}}}static create(t){return t instanceof Fraction?t:new Fraction(t)}static valueOf(t){return Fraction.create(t)}static _toFraction(t){return t instanceof Fraction?t:new Fraction(t)}static _toFloat(t){return"number"==typeof t?t:t instanceof Fraction?t.doubleValue:new Fraction(t).doubleValue}static _toInteger(t){return"number"==typeof t?Math.trunc(t):t instanceof Fraction?t.intValue:new Fraction(t).intValue}clone(){return new Fraction(this)}get intValue(){return this.isInteger()?Math.trunc(this.numerator.doubleValue):Math.trunc(this.doubleValue)}get doubleValue(){if(this.isInteger())return this.numerator.doubleValue;const t=new BigDecimal([this.numerator,MathContext.UNLIMITED]),n=new BigDecimal([this.denominator,MathContext.UNLIMITED]);return t.div(n,{context:MathContext.DECIMAL64}).doubleValue}toString(){return this.numerator.toString()+" / "+this.denominator.toString()}isInteger(){return this.denominator.equals(BigInteger.ONE)}isZero(){return this.numerator.equals(BigInteger.ZERO)&&this.denominator.equals(BigInteger.ONE)}isOne(){return this.numerator.equals(BigInteger.ONE)&&this.denominator.equals(BigInteger.ONE)}isPositive(){return this.numerator.isPositive()}isNegative(){return this.numerator.isNegative()}isNotNegative(){return this.numerator.isNotNegative()}add(t){const n=this,e=Fraction._toFraction(t);return new Fraction(n.isInteger()&&e.isInteger()?[n.numerator.add(e.numerator),BigInteger.ONE]:[n.numerator.mul(e.denominator).add(e.numerator.mul(n.denominator)),n.denominator.mul(e.denominator)])}sub(t){const n=this,e=Fraction._toFraction(t);return new Fraction(n.isInteger()&&e.isInteger()?[n.numerator.sub(e.numerator),BigInteger.ONE]:[n.numerator.mul(e.denominator).sub(e.numerator.mul(n.denominator)),n.denominator.mul(e.denominator)])}mul(t){const n=this,e=Fraction._toFraction(t);return new Fraction(n.isInteger()&&e.isInteger()?[n.numerator.mul(e.numerator),BigInteger.ONE]:[n.numerator.mul(e.numerator),n.denominator.mul(e.denominator)])}div(t){const n=this,e=Fraction._toFraction(t);return new Fraction(n.isInteger()&&e.isInteger()?[n.numerator,e.denominator]:[n.numerator.mul(e.denominator),e.denominator.mul(n.numerator)])}scaleByPowerOfTen(t){const n=Fraction._toInteger(t);if(0===n)return this;let e;return n>0?e=new Fraction([this.numerator.scaleByPowerOfTen(n),this.denominator]):n<0&&(e=new Fraction([this.numerator,this.denominator.scaleByPowerOfTen(-n)])),e}static get ONE(){return DEFINE$3.ONE}static get ZERO(){return DEFINE$3.ZERO}static get MINUS_ONE(){return DEFINE$3.MINUS_ONE}}const DEFINE$3={ONE:new Fraction([BigInteger.ONE,BigInteger.ONE]),ZERO:new Fraction([BigInteger.ZERO,BigInteger.ONE]),MINUS_ONE:new Fraction([BigInteger.MINUS_ONE,BigInteger.ONE])};class LinearAlgebraTool{static tridiagonalize(t){const n=Matrix._toMatrix(t).getNumberMatrixArray(),e=function(t,n,e,r){let i=0;const o=e||0,a=r||t.length;for(let e=o;e<a;e++)i+=t[e]*n[e];return i},r=n.length,i=[],o=[];for(let t=0;t<r-2;t++){const a=n[t];i[t]=a[t];{const n=function(t,n,r){const i=n||0,o=r||t.length;let a=Math.sqrt(e(t,t,i,o));const s=[];if(Math.abs(a)>=1e-10){t[i]<0&&(a=-a);let n;for(let e=i,r=0;e<o;e++,r++)e===i?(s[r]=t[e]+a,n=1/Math.sqrt(s[r]*a),s[r]=s[r]*n):s[r]=t[e]*n}return{y1:-a,v:s}}(a,t+1,r);o[t]=n.y1;for(let e=0;e<n.v.length;e++)a[t+1+e]=n.v[e]}if(!(Math.abs(o[t])<1e-10)){for(let e=t+1;e<r;e++){let o=0;for(let r=t+1;r<e;r++)o+=n[r][e]*a[r];for(let t=e;t<r;t++)o+=n[e][t]*a[t];i[e]=o}const o=e(a,i,t+1,r)/2;for(let e=r-1;e>t;e--){const t=a[e],s=i[e]-o*t;i[e]=s;for(let o=e;o<r;o++){const r=t*i[o]+s*a[o];n[e][o]=n[e][o]-r}}}}r>=2&&(i[r-2]=n[r-2][r-2],o[r-2]=n[r-2][r-1]),r>=1&&(i[r-1]=n[r-1][r-1]);for(let t=r-1;t>=0;t--){const i=n[t];if(t<r-2)for(let o=t+1;o<r;o++){const a=n[o],s=e(i,a,t+1,r);for(let n=t+1;n<r;n++)a[n]-=s*i[n]}for(let t=0;t<r;t++)i[t]=0;i[t]=1}const a=Matrix.createMatrixDoEachCalculation(function(t,n){return t===n?new Complex(i[t]):1===Math.abs(t-n)?new Complex(o[Math.trunc(.5*(t+n))]):Complex.ZERO},r,r);return{P:new Matrix(n).T(),H:a}}static eig(t){const n=Matrix._toMatrix(t);let e=!1;const r=LinearAlgebraTool.tridiagonalize(n),i=r.P.getNumberMatrixArray(),o=r.H.getNumberMatrixArray(),a=n.row_length,s=[],c=[];for(let t=0;t<a;t++)s[t]=o[t][t],c[t]=0===t?0:o[t][t-1];for(let t=a-1;t>0;t--){let n=t;for(n=t;n>=1&&!(Math.abs(c[n])<=1e-10*(Math.abs(s[n-1])+Math.abs(s[n])));n--);if(n!=t){let r=0;for(;;){if(++r>100){e=!0;break}let o=(s[t-1]-s[t])/2,u=c[t]*c[t],l=Math.sqrt(o*o+u);o<0&&(l=-l);let h=s[n]-s[t]+u/(o+l),g=c[n+1];for(let e=n;e<t;e++){let r,l;Math.abs(h)>=Math.abs(g)?l=(u=-g/h)*(r=1/Math.sqrt(u*u+1)):r=(u=-h/g)*(l=1/Math.sqrt(u*u+1)),u=((o=s[e]-s[e+1])*l+2*r*c[e+1])*l,s[e]-=u,s[e+1]+=u,e>n&&(c[e]=r*c[e]-l*g),c[e+1]+=l*(r*o-2*l*c[e+1]);for(let t=0;t<a;t++)h=i[t][e],g=i[t][e+1],i[t][e]=r*h-l*g,i[t][e+1]=l*h+r*g;e<t-1&&(h=c[e+1],g=-l*c[e+2],c[e+2]*=r)}if(Math.abs(c[t])<=1e-10*(Math.abs(s[t-1])+Math.abs(s[t])))break}if(e)break}}return function(t,n){const e=n.length,r=[];for(let t=0;t<e;t++)r[t]={sigma:n[t],index:t};const i=function(t,n){return t.sigma===n.sigma?0:t.sigma<n.sigma?1:-1};r.sort(i);const o=Matrix.zeros(e),a=Matrix.zeros(e);for(let t=0;t<e;t++)a.matrix_array[t][t]=new Complex(r[t].sigma),o.matrix_array[t][r[t].index]=Complex.ONE;return{V:t.mul(o),D:a}}(new Matrix(i),s)}static doGramSchmidtOrthonormalization(t){const n=Matrix._toMatrix(t),e=n.column_length,r=n.matrix_array,i=Matrix.zeros(e),o=Matrix.zeros(e),a=i.matrix_array,s=o.matrix_array,c=[],u=new Array(e);for(let t=0;t<e;t++){for(let n=0;n<e;n++)u[n]=r[n][t];if(t>0){for(let n=0;n<t;n++)for(let i=0;i<e;i++)s[n][t]=s[n][t].add(r[i][t].dot(a[i][n]));for(let n=0;n<t;n++)for(let r=0;r<e;r++)u[r]=u[r].sub(s[n][t].mul(a[r][n]))}for(let n=0;n<e;n++)s[t][t]=s[t][t].add(u[n].square());if(s[t][t]=s[t][t].sqrt(),s[t][t].isZero(1e-10)){c.push(t);for(let n=0;n<e;n++)a[n][t]=Complex.ZERO}else for(let n=0;n<e;n++)a[n][t]=u[n].div(s[t][t])}return{Q:i,R:o,non_orthogonalized:c}}static createOrthogonalVector(t,n){const e=new Matrix(t),r=e.column_length,i=e.matrix_array,o=n||1e-10,a=LinearAlgebraTool.getLinearDependenceVector(e,o);for(let t=a.length-1;t>=0;t--)i.splice(a[t],1),e.row_length--;const s=r-i.length;if(s<=0)return null;const c=new Random(0);let u=null;for(let t=0;t<100;t++){const t=e.T(),n=Matrix.createMatrixDoEachCalculation(function(){return new Complex(c.nextGaussian())},t.row_length,s);if(t._concatRight(n),0===(u=LinearAlgebraTool.doGramSchmidtOrthonormalization(t)).non_orthogonalized.length)break}if(0!==u.non_orthogonalized.length)return console.log("miss"),null;const l=new Array(s),h=u.Q.matrix_array;for(let t=0;t<s;t++){l[t]=new Array(r);for(let n=0;n<r;n++)l[t][n]=h[n][r-s+t]}return new Matrix(l)}static getMaxRowNumber(t,n,e,r){const i=Matrix._toMatrix(t);let o=0,a=0,s=e||0;const c=r||i.row_length;for(;s<c;s++){const t=i.matrix_array[s][n].norm;t>a&&(a=t,o=s)}return{index:o,max:a}}static getLinearDependenceVector(t,n){const e=new Matrix(t),r=e.matrix_array,i=n?Matrix._toDouble(n):1e-10,o=new Array(t.row_length);for(let n=0;n<t.row_length;n++)o[n]=n;for(let t=0;t<e.column_length;t++){let n=0;{let a=0,s=0;for(const e in o){const i=o[e],c=r[i][t].norm;c>a&&(a=c,s=parseInt(e,10),n=i)}if(a<=i)continue;if(o.splice(s,1),t===e.column_length-1)break}for(const i in o){const a=o[i],s=r[a][t].div(r[n][t]);for(let i=t;i<e.column_length;i++)r[a][i]=r[a][i].sub(r[n][i].mul(s))}}return o}}class LinearAlgebra{static inner(t,n,e){const r=Matrix._toMatrix(t),i=Matrix._toMatrix(n),o=r.matrix_array,a=i.matrix_array,s=e?Matrix._toInteger(e):1;if(r.isScalar()&&i.isScalar())return new Matrix(r.scalar.dot(i.scalar));if(r.isVector()&&i.isVector()){let t=Complex.ZERO;for(let n=0;n<r.length;n++)t=t.add(r.getComplex(n).dot(i.getComplex(n)));return new Matrix(t)}if(r.row_length!==i.row_length||r.column_length!==i.column_length)throw"Matrix size does not match";if(1===s){const t=new Array(1);t[0]=new Array(r.column_length);for(let n=0;n<r.column_length;n++){let e=Complex.ZERO;for(let t=0;t<r.row_length;t++)e=e.add(o[t][n].dot(a[t][n]));t[0][n]=e}return new Matrix(t)}if(2===s){const t=new Array(r.row_length);for(let n=0;n<r.row_length;n++){let e=Complex.ZERO;for(let t=0;t<r.column_length;t++)e=e.add(o[n][t].dot(a[n][t]));t[n]=[e]}return new Matrix(t)}throw"dim"}static norm(t,n){const e=Matrix._toMatrix(t),r=void 0===n?2:Matrix._toDouble(n);if(1===r){const t=e.matrix_array;if(e.isRow()){let n=0;for(let r=0;r<e.column_length;r++)n+=t[0][r].norm;return n}if(e.isColumn()){let n=0;for(let r=0;r<e.row_length;r++)n+=t[r][0].norm;return n}let n=0;for(let r=0;r<e.column_length;r++){let i=0;for(let n=0;n<e.row_length;n++)i+=t[n][r].norm;n<i&&(n=i)}return n}if(2===r){const t=e.matrix_array;if(e.isRow()){let n=0;for(let r=0;r<e.column_length;r++)n+=t[0][r].square().real;return Math.sqrt(n)}if(e.isColumn()){let n=0;for(let r=0;r<e.row_length;r++)n+=t[r][0].square().real;return Math.sqrt(n)}return e.svd().S.diag().max().scalar.real}if(r===Number.POSITIVE_INFINITY||r===Number.NEGATIVE_INFINITY){const t=e.matrix_array;let n=r===Number.POSITIVE_INFINITY?0:Number.POSITIVE_INFINITY;const i=r===Number.POSITIVE_INFINITY?Math.max:Math.min;if(e.isRow()){for(let r=0;r<e.column_length;r++)n=i(n,t[0][r].norm);return n}if(e.isColumn()){for(let r=0;r<e.row_length;r++)n=i(n,t[r][0].norm);return n}n=0;for(let r=0;r<e.row_length;r++){let i=0;for(let n=0;n<e.column_length;n++)i+=t[r][n].norm;n=Math.max(n,i)}return n}if(e.isVector()){let t=0;for(let n=0;n<e.length;n++)t+=Math.pow(e.getComplex(n).norm,r);return Math.pow(t,1/r)}throw"norm"}static cond(t,n){const e=Matrix._toMatrix(t);if(2===(void 0===n?2:Matrix._toInteger(n))){if(e.isZeros())return Number.POSITIVE_INFINITY;if(e.isVector())return 1;if(e.isUnitary())return 1;const t=e.svd().S.diag();return t.max().scalar.real/t.min().scalar.real}return e.norm(n)*e.pinv().norm(n)}static rcond(t){return 1/LinearAlgebra.cond(Matrix._toMatrix(t),1)}static rank(t,n){const e=Matrix._toMatrix(t);return e.row_length<=e.column_length?Math.min(e.row_length,e.column_length)-LinearAlgebraTool.getLinearDependenceVector(e,n).length:e.row_length-LinearAlgebraTool.getLinearDependenceVector(e,n).length}static trace(t){const n=Matrix._toMatrix(t),e=Math.min(n.row_length,n.column_length);let r=Complex.ZERO;for(let t=0;t<e;t++)r=r.add(n.matrix_array[t][t]);return r}static det(t){const n=Matrix._toMatrix(t);if(!n.isSquare())throw"not square";const e=n.length;if(e<5){const t=function(n){if(2===n.length)return n[0][0].mul(n[1][1]).sub(n[0][1].mul(n[1][0]));let e=Complex.ZERO;for(let r=0;r<n.length;r++){const i=[],o=n[r][0];for(let t=0,e=0;t<n.length;t++)if(r!==t){i[e]=[];for(let r=1,o=0;r<n.length;r++,o++)i[e][o]=n[t][r];e++}e=r%2==0?e.add(o.mul(t(i))):e.sub(o.mul(t(i)))}return e};return new Matrix(t(n.matrix_array))}{const t=LinearAlgebra.lup(n),r=(e-t.P.diag().sum().scalar.real)/2;let i=t.U.diag().prod();return r%2==1&&(i=i.negate()),new Matrix(i)}}static lup(t){const n=new Matrix(t),e=Matrix.zeros(n.row_length),r=n,i=Matrix.eye(n.row_length),o=e.matrix_array,a=r.matrix_array;for(let t=0;t<n.column_length;t++){let s;{const n=LinearAlgebraTool.getMaxRowNumber(r,t,t);if(s=n.index,0===n.max)continue;t!==s&&(e._exchangeRow(t,s),r._exchangeRow(t,s),i._exchangeRow(t,s))}for(let e=t+1;e<n.row_length;e++){const r=a[e][t].div(a[t][t]);o[e][t]=r;for(let i=t;i<n.column_length;i++)a[e][i]=a[e][i].sub(a[t][i].mul(r))}}return e._resize(n.row_length,Math.min(n.row_length,n.column_length)),r._resize(Math.min(n.row_length,n.column_length),n.column_length),e._each(function(t,n,e){return n===e?Complex.ONE:t}),{L:e,U:r,P:i}}static lu(t){const n=LinearAlgebra.lup(t);return{L:n.P.T().mul(n.L),U:n.U}}static linsolve(t,n){const e=Matrix._toMatrix(t),r=Matrix._toMatrix(n);if(!e.isSquare())throw"Matrix size does not match";const i=r;if(r.row_length!==e.row_length||r.column_length>1)throw"Matrix size does not match";const o=new Matrix(e);o._concatRight(i);const a=o.matrix_array,s=o.column_length,c=e.column_length;for(let t=0;t<c-1;t++){{const n=LinearAlgebraTool.getMaxRowNumber(o,t,t).index;o._exchangeRow(t,n)}{const n=a[t][t].inv();for(let e=t,r=t;r<s;r++)a[e][r]=a[e][r].mul(n)}for(let n=t+1;n<c;n++){const e=a[n][t];for(let r=t;r<s;r++)a[n][r]=a[n][r].sub(a[t][r].mul(e))}}const u=new Array(c);u[c-1]=a[c-1][c].div(a[c-1][c-1]);for(let t=c-2;t>=0;t--){u[t]=a[t][s-1];for(let n=t+1;n<c;n++)u[t]=u[t].sub(a[t][n].mul(u[n]));u[t]=u[t].div(a[t][t])}const l=new Array(e.row_length);for(let t=0;t<e.row_length;t++)l[t]=[u[t]];return new Matrix(l)}static qr(t){const n=new Matrix(t),e=n.row_length,r=n.row_length,i=n.row_length,o=n.column_length,a=Math.max(n.row_length,n.column_length);n._resize(a,a);const s=LinearAlgebraTool.doGramSchmidtOrthonormalization(n);let c=s.Q;const u=s.R,l=s.non_orthogonalized;if(l.length===n.row_length)c=Matrix.eye(n.row_length);else if(0!==l.length){const t={};for(let n=0;n<l.length;n++)t[l[n]]=1;const n=[];for(let e=0;e<a;e++)if(!t[e]){const t=[];for(let n=0;n<a;n++)t[n]=c.matrix_array[n][e];n.push(t)}const e=LinearAlgebraTool.createOrthogonalVector(n);for(let t=0;t<l.length;t++){const n=l[t];for(let r=0;r<a;r++)c.matrix_array[r][n]=e.matrix_array[t][r]}}return c._resize(e,r),u._resize(i,o),{Q:c,R:u}}static tridiagonalize(t){const n=new Matrix(t);if(!n.isSquare())throw"not square matrix";if(!n.isSymmetric())throw"not Symmetric";if(n.isComplex())throw"not Real Matrix";return LinearAlgebraTool.tridiagonalize(n)}static eig(t){const n=new Matrix(t);if(!n.isSquare())throw"not square matrix";if(!n.isSymmetric())throw"not Symmetric";if(n.isComplex())throw"not Real Matrix";return LinearAlgebraTool.eig(n)}static svd(t){const n=new Matrix(t);if(n.isComplex())throw"Unimplemented";const e=LinearAlgebra.rank(n),r=LinearAlgebra.eig(n.T().mul(n)),i=Matrix.zeros(n.row_length,n.column_length);i._each(function(t,n,i){if(n===i&&n<e)return r.D.getComplex(n,n).sqrt()});const o=Math.min(n.row_length,n.column_length),a=Matrix.createMatrixDoEachCalculation(function(t,n){if(t===n){const n=i.matrix_array[t][t];return n.isZero()?Complex.ZERO:n.inv()}return Complex.ZERO},o),s=r.V.resize(r.V.row_length,o),c=n.mul(s).mul(a);return{U:LinearAlgebra.qr(c).Q,S:i,V:r.V}}static inv(t){const n=new Matrix(t);if(n.isScalar())return new Matrix(Complex.ONE.div(n.scalar));if(!n.isSquare())throw"not square";if(n.isDiagonal()){const t=n.T(),e=Math.min(t.row_length,t.column_length);for(let n=0;n<e;n++)t.matrix_array[n][n]=t.matrix_array[n][n].inv();return t}const e=n.column_length,r=new Matrix(n);r._concatRight(Matrix.eye(e));const i=r.matrix_array,o=r.column_length;for(let t=0;t<e;t++){{const n=LinearAlgebraTool.getMaxRowNumber(r,t,t).index;r._exchangeRow(t,n)}{const n=i[t][t].inv();for(let e=t,r=t;r<o;r++)i[e][r]=i[e][r].mul(n)}for(let n=0;n<e;n++)if(n!==t){const e=i[n][t];for(let r=t;r<o;r++)i[n][r]=i[n][r].sub(i[t][r].mul(e))}}const a=new Array(e);for(let t=0;t<e;t++){a[t]=new Array(e);for(let n=0;n<e;n++)a[t][n]=i[t][e+n]}return new Matrix(a)}static pinv(t){const n=new Matrix(t),e=LinearAlgebra.svd(n),r=e.U,i=e.S,o=e.V,a=Matrix.createMatrixDoEachCalculation(function(t,n){if(t===n){const n=i.matrix_array[t][t];return n.isZero()?Complex.ZERO:n.inv()}return Complex.ZERO},n.column_length,n.row_length);return o.mul(a).mul(r.T())}}class StatisticsTool{static gammaln(t){const n=Math.log(2*Math.PI),e=[-15238221.539407417,691472.268851313,-36108.77125372499,8553103/6/650,-156.84828462600203,854513/138/462,-174611/330/380,43867/798/306,-3617/510/240,7/6/182,-691/2730/132,5/66/90,-1/30/56,1/42/30,-1/30/12,1/6/2];let r=1,i=t;for(;i<e.length;)r*=i,i++;const o=1/(i*i);let a=e[0];for(let t=1;t<e.length;t++)a*=o,a+=e[t];return a/=i,a+=.5*n,a+=-Math.log(r)-i+(i-.5)*Math.log(i)}static q_gamma(t,n,e){let r,i,o,a,s,c=1,u=1+t-n;if(t<1+n)return 1-StatisticsTool.p_gamma(t,n,e);for(i=(o=Math.exp(n*Math.log(t)-t-e))/u,r=2;r<1e3;r++)if(a=((r-1-n)*(u-c)+(r+t)*u)/r,c=u,u=a,o*=(r-1-n)/r,a=o/(c*u),s=i,(i+=a)==s)return i;return Number.NaN}static p_gamma(t,n,e){let r,i,o,a;if(t>=1+n)return 1-StatisticsTool.q_gamma(t,n,e);if(0===t)return 0;for(i=o=Math.exp(n*Math.log(t)-t-e)/n,r=1;r<1e3;r++)if(o*=t/(n+r),a=i,(i+=o)==a)return i;return Number.NaN}static gamma(t){return t<0?Math.PI/(Math.sin(Math.PI*t)*Math.exp(StatisticsTool.gammaln(1-t))):Math.exp(StatisticsTool.gammaln(t))}static gammainc(t,n,e){if("lower"===e)return StatisticsTool.p_gamma(t,n,StatisticsTool.gammaln(n));if("upper"===e)return StatisticsTool.q_gamma(t,n,StatisticsTool.gammaln(n));if(2===arguments.length)return StatisticsTool.gammainc(t,n,"lower");throw"gammainc unsupported argument ["+e+"]"}static gampdf(t,n,e){let r=1/(StatisticsTool.gamma(n)*Math.pow(e,n));return r*=Math.pow(t,n-1),r*=Math.exp(-t/e)}static gamcdf(t,n,e){return StatisticsTool.gammainc(t/e,n)}static gaminv(t,n,e){if(t<0||t>1)return Number.NaN;if(0==t)return 0;if(1==t)return Number.POSITIVE_INFINITY;let r,i,o=n*e;for(let a=0;a<100&&(i=o-(StatisticsTool.gamcdf(o,n,e)-t)/StatisticsTool.gampdf(o,n,e),r=i-o,!(Math.abs(r)<=1e-12));a++)(o=i)<0&&(o=1e-12);return o}static beta(t,n){return Math.exp(StatisticsTool.gammaln(t)+StatisticsTool.gammaln(n)-StatisticsTool.gammaln(t+n))}static p_beta(t,n,e){let r,i,o,a;if(n<=0)return Number.POSITIVE_INFINITY;if(e<=0)return t<1?0:1===t?1:Number.POSITIVE_INFINITY;if(t>(n+1)/(n+e+2))return 1-StatisticsTool.p_beta(1-t,e,n);if(t<=0)return 0;for(o=n*Math.log(t),o+=e*Math.log(1-t),o+=StatisticsTool.gammaln(n+e),o-=StatisticsTool.gammaln(n)+StatisticsTool.gammaln(e),o=Math.exp(o),i=o/=n,r=1;r<1e3;r++)if(o*=n+e+r-1,o*=t,o/=n+r,a=i,(i+=o)===a)return i;return Number.NaN}static q_beta(t,n,e){return 1-StatisticsTool.p_beta(t,n,e)}static betainc(t,n,e,r){if("lower"===r)return StatisticsTool.p_beta(t,n,e);if("upper"===r)return StatisticsTool.q_beta(t,n,e);if(3===arguments.length)return StatisticsTool.betainc(t,n,e,"lower");throw"betainc unsupported argument ["+r+"]"}static isInteger(t){return t-Math.trunc(t)!=0}static betapdf(t,n,e){return t<0&&StatisticsTool.isInteger(e-1)||1-t<0&&StatisticsTool.isInteger(e-1)?0:Math.pow(t,n-1)*Math.pow(1-t,e-1)/StatisticsTool.beta(n,e)}static betacdf(t,n,e){return StatisticsTool.betainc(t,n,e)}static betainv(t,n,e){if(t<0||t>1)return Number.NaN;if(0==t&&n>0&&e>0)return 0;if(1==t&&n>0&&e>0)return 1;let r;r=0==e?1-1e-14:0==n?1e-14:n/(n+e);let i,o;for(let a=0;a<100&&(o=r-(StatisticsTool.betacdf(r,n,e)-t)/StatisticsTool.betapdf(r,n,e),i=o-r,!(Math.abs(i)<=1e-14));a++)(r=o)>1?r=1-1e-14:r<0&&(r=1e-14);return r}static factorial(t){const n=StatisticsTool.gamma(t+1);return Math.trunc(t)===t?Math.round(n):n}static nchoosek(t,n){return Math.round(StatisticsTool.factorial(t)/(StatisticsTool.factorial(t-n)*StatisticsTool.factorial(n)))}static erf(t){return StatisticsTool.p_gamma(t*t,.5,.5*Math.log(Math.PI))*(t>=0?1:-1)}static erfc(t){return 1-StatisticsTool.erf(t)}static normpdf(t,n,e){const r="number"==typeof n?n:0,i="number"==typeof e?e:1;let o=1/Math.sqrt(2*Math.PI*i*i);return o*=Math.exp(-(t-r)*(t-r)/(2*i*i))}static normcdf(t,n,e){const r="number"==typeof n?n:0,i="number"==typeof e?e:1;return(1+StatisticsTool.erf((t-r)/(i*Math.sqrt(2))))/2}static norminv(t,n,e){if(t<0||t>1)return Number.NaN;if(0==t)return Number.NEGATIVE_INFINITY;if(1==t)return Number.POSITIVE_INFINITY;const r="number"==typeof n?n:0,i="number"==typeof e?e:1;let o,a,s=r;for(let n=0;n<200&&(a=s-(StatisticsTool.normcdf(s,r,i)-t)/StatisticsTool.normpdf(s,r,i),o=a-s,!(Math.abs(o)<=1e-12));n++)s=a;return s}static tpdf(t,n){let e=1/(Math.sqrt(n)*StatisticsTool.beta(.5,.5*n));return e*=Math.pow(1+t*t/n,.5*-(n+1))}static tcdf(t,n){const e=t*t/(n+t*t);return.5*(1+StatisticsTool.betainc(e,.5,.5*n)*(t<0?-1:1))}static tinv(t,n){if(t<0||t>1)return Number.NaN;if(0==t)return Number.NEGATIVE_INFINITY;if(1==t)return Number.POSITIVE_INFINITY;if(t<.5){const e=StatisticsTool.betainv(2*t,.5*n,.5);return-Math.sqrt(n/e-n)}{const e=StatisticsTool.betainv(2*(1-t),.5*n,.5);return Math.sqrt(n/e-n)}}static tdist(t,n,e){return(1-StatisticsTool.tcdf(t,n))*e}static tinv2(t,n){return-StatisticsTool.tinv(.5*t,n)}static chi2pdf(t,n){if(t<0)return 0;if(0===t)return.5;let e=Math.pow(t,n/2-1)*Math.exp(-t/2);return e/=Math.pow(2,n/2)*StatisticsTool.gamma(n/2)}static chi2cdf(t,n){return StatisticsTool.gammainc(t/2,n/2)}static chi2inv(t,n){return StatisticsTool.gaminv(t,n/2,2)}static fpdf(t,n,e){if(n<0||e<0)return Number.NaN;if(t<=0)return 0;let r=1;return r*=Math.pow(n*t/(n*t+e),n/2),r*=Math.pow(1-n*t/(n*t+e),e/2),r/=t*StatisticsTool.beta(n/2,e/2)}static fcdf(t,n,e){return StatisticsTool.betacdf(n*t/(n*t+e),n/2,e/2)}static finv(t,n,e){return(1/StatisticsTool.betainv(1-t,e/2,n/2)-1)*e/n}}const isStr=function(t){return t&&("string"==typeof t||t instanceof String)};class StatisticsComplex{static gammaln(t){return new Complex(StatisticsTool.gammaln(Complex._toDouble(t)))}static gamma(t){return new Complex(StatisticsTool.gamma(Complex._toDouble(t)))}static gammainc(t,n,e){const r=Complex._toDouble(t),i=Complex._toDouble(n),o=isStr(e)?e:"lower";return new Complex(StatisticsTool.gammainc(r,i,o))}static gampdf(t,n,e){const r=Complex._toDouble(t),i=Complex._toDouble(n),o=Complex._toDouble(e);return new Complex(StatisticsTool.gampdf(r,i,o))}static gamcdf(t,n,e){const r=Complex._toDouble(t),i=Complex._toDouble(n),o=Complex._toDouble(e);return new Complex(StatisticsTool.gamcdf(r,i,o))}static gaminv(t,n,e){const r=Complex._toDouble(t),i=Complex._toDouble(n),o=Complex._toDouble(e);return new Complex(StatisticsTool.gaminv(r,i,o))}static beta(t,n){const e=Complex._toDouble(t),r=Complex._toDouble(n);return new Complex(StatisticsTool.beta(e,r))}static betainc(t,n,e,r){const i=Complex._toDouble(t),o=Complex._toDouble(n),a=Complex._toDouble(e),s=isStr(r)?r:"lower";return new Complex(StatisticsTool.betainc(i,o,a,s))}static betapdf(t,n,e){const r=Complex._toDouble(t),i=Complex._toDouble(n),o=Complex._toDouble(e);return new Complex(StatisticsTool.betapdf(r,i,o))}static betacdf(t,n,e){const r=Complex._toDouble(t),i=Complex._toDouble(n),o=Complex._toDouble(e);return new Complex(StatisticsTool.betacdf(r,i,o))}static betainv(t,n,e){const r=Complex._toDouble(t),i=Complex._toDouble(n),o=Complex._toDouble(e);return new Complex(StatisticsTool.betainv(r,i,o))}static factorial(t){return new Complex(StatisticsTool.factorial(Complex._toDouble(t)))}static nchoosek(t,n){const e=Complex._toDouble(t),r=Complex._toDouble(n);return new Complex(StatisticsTool.nchoosek(e,r))}static erf(t){const n=Complex._toDouble(t);return new Complex(StatisticsTool.erf(n))}static erfc(t){const n=Complex._toDouble(t);return new Complex(StatisticsTool.erfc(n))}static normpdf(t,n,e){const r=Complex._toDouble(t),i=void 0!==n?Complex._toDouble(n):0,o=void 0!==e?Complex._toDouble(e):1;return new Complex(StatisticsTool.normpdf(r,i,o))}static normcdf(t,n,e){const r=Complex._toDouble(t),i=void 0!==n?Complex._toDouble(n):0,o=void 0!==e?Complex._toDouble(e):1;return new Complex(StatisticsTool.normcdf(r,i,o))}static norminv(t,n,e){const r=Complex._toDouble(t),i=void 0!==n?Complex._toDouble(n):0,o=void 0!==e?Complex._toDouble(e):1;return new Complex(StatisticsTool.norminv(r,i,o))}static tpdf(t,n){const e=Complex._toDouble(t),r=Complex._toDouble(n);return new Complex(StatisticsTool.tpdf(e,r))}static tcdf(t,n){const e=Complex._toDouble(t),r=Complex._toDouble(n);return new Complex(StatisticsTool.tcdf(e,r))}static tinv(t,n){const e=Complex._toDouble(t),r=Complex._toDouble(n);return new Complex(StatisticsTool.tinv(e,r))}static tdist(t,n,e){const r=Complex._toDouble(t),i=Complex._toDouble(n),o=Complex._toInteger(e);return new Complex(StatisticsTool.tdist(r,i,o))}static tinv2(t,n){const e=Complex._toDouble(t),r=Complex._toDouble(n);return new Complex(StatisticsTool.tinv2(e,r))}static chi2pdf(t,n){const e=Complex._toDouble(t),r=Complex._toDouble(n);return new Complex(StatisticsTool.chi2pdf(e,r))}static chi2cdf(t,n){const e=Complex._toDouble(t),r=Complex._toDouble(n);return new Complex(StatisticsTool.chi2cdf(e,r))}static chi2inv(t,n){const e=Complex._toDouble(t),r=Complex._toDouble(n);return new Complex(StatisticsTool.chi2inv(e,r))}static fpdf(t,n,e){const r=Complex._toDouble(t),i=Complex._toDouble(n),o=Complex._toDouble(e);return new Complex(StatisticsTool.fpdf(r,i,o))}static fcdf(t,n,e){const r=Complex._toDouble(t),i=Complex._toDouble(n),o=Complex._toDouble(e);return new Complex(StatisticsTool.fcdf(r,i,o))}static finv(t,n,e){const r=Complex._toDouble(t),i=Complex._toDouble(n),o=Complex._toDouble(e);return new Complex(StatisticsTool.finv(r,i,o))}}class Statistics{static gammaln(t){return Matrix._toMatrix(t).cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.gammaln(t)})}static gamma(t){return Matrix._toMatrix(t).cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.gamma(t)})}static gammainc(t,n,e){const r=Matrix._toMatrix(t),i=Matrix._toDouble(n),o=isStr(e)?e:"lower";return r.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.gammainc(t,i,o)})}static gampdf(t,n,e){const r=Matrix._toMatrix(t),i=Matrix._toDouble(n),o=Matrix._toDouble(e);return r.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.gampdf(t,i,o)})}static gamcdf(t,n,e){const r=Matrix._toMatrix(t),i=Matrix._toDouble(n),o=Matrix._toDouble(e);return r.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.gamcdf(t,i,o)})}static gaminv(t,n,e){const r=Matrix._toMatrix(t),i=Matrix._toDouble(n),o=Matrix._toDouble(e);return r.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.gaminv(t,i,o)})}static beta(t,n){const e=Matrix._toMatrix(t),r=Matrix._toDouble(n);return e.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.beta(t,r)})}static betainc(t,n,e,r){const i=Matrix._toMatrix(t),o=Matrix._toDouble(n),a=Matrix._toDouble(e),s=isStr(r)?r:"lower";return i.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.betainc(t,o,a,s)})}static betacdf(t,n,e){const r=Matrix._toMatrix(t),i=Matrix._toDouble(n),o=Matrix._toDouble(e);return r.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.betacdf(t,i,o)})}static betapdf(t,n,e){const r=Matrix._toMatrix(t),i=Matrix._toDouble(n),o=Matrix._toDouble(e);return r.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.betapdf(t,i,o)})}static betainv(t,n,e){const r=Matrix._toMatrix(t),i=Matrix._toDouble(n),o=Matrix._toDouble(e);return r.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.betainv(t,i,o)})}static factorial(t){return Matrix._toMatrix(t).cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.factorial(t)})}static nchoosek(t,n){const e=Matrix._toMatrix(t),r=Matrix._toDouble(n);return e.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.nchoosek(t,r)})}static erf(t){return Matrix._toMatrix(t).cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.erf(t)})}static erfc(t){return Matrix._toMatrix(t).cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.erfc(t)})}static normpdf(t,n,e){const r=Matrix._toMatrix(t),i=void 0!==n?Matrix._toDouble(n):0,o=void 0!==e?Matrix._toDouble(e):1;return r.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.normpdf(t,i,o)})}static normcdf(t,n,e){const r=Matrix._toMatrix(t),i=void 0!==n?Matrix._toDouble(n):0,o=void 0!==e?Matrix._toDouble(e):1;return r.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.normcdf(t,i,o)})}static norminv(t,n,e){const r=Matrix._toMatrix(t),i=void 0!==n?Matrix._toDouble(n):0,o=void 0!==e?Matrix._toDouble(e):1;return r.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.norminv(t,i,o)})}static tpdf(t,n){const e=Matrix._toMatrix(t),r=Matrix._toDouble(n);return e.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.tpdf(t,r)})}static tcdf(t,n){const e=Matrix._toMatrix(t),r=Matrix._toDouble(n);return e.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.tcdf(t,r)})}static tinv(t,n){const e=Matrix._toMatrix(t),r=Matrix._toDouble(n);return e.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.tinv(t,r)})}static tdist(t,n,e){const r=Matrix._toMatrix(t),i=Matrix._toDouble(n),o=Matrix._toDouble(e);return r.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.tdist(t,i,o)})}static tinv2(t,n){const e=Matrix._toMatrix(t),r=Matrix._toDouble(n);return e.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.tinv2(t,r)})}static chi2pdf(t,n){const e=Matrix._toMatrix(t),r=Matrix._toDouble(n);return e.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.chi2pdf(t,r)})}static chi2cdf(t,n){const e=Matrix._toMatrix(t),r=Matrix._toDouble(n);return e.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.chi2cdf(t,r)})}static chi2inv(t,n){const e=Matrix._toMatrix(t),r=Matrix._toDouble(n);return e.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.chi2inv(t,r)})}static fpdf(t,n,e){const r=Matrix._toMatrix(t),i=Matrix._toDouble(n),o=Matrix._toDouble(e);return r.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.fpdf(t,i,o)})}static fcdf(t,n,e){const r=Matrix._toMatrix(t),i=Matrix._toDouble(n),o=Matrix._toDouble(e);return r.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.fcdf(t,i,o)})}static finv(t,n,e){const r=Matrix._toMatrix(t),i=Matrix._toDouble(n),o=Matrix._toDouble(e);return r.cloneMatrixDoEachCalculation(function(t){return StatisticsComplex.finv(t,i,o)})}static max(t,n){const e=Matrix._toMatrix(t),r=n&&n.dimension?n.dimension:"auto",i=function(t){let n=t[0];for(let e=1;e<t.length;e++)n.compareTo(t[e])<0&&(n=t[e]);return[n]};return e.eachVector(i,r)}static min(t,n){const e=Matrix._toMatrix(t),r=n&&n.dimension?n.dimension:"auto",i=function(t){let n=t[0];for(let e=1;e<t.length;e++)n.compareTo(t[e])>0&&(n=t[e]);return[n]};return e.eachVector(i,r)}static sum(t,n){const e=Matrix._toMatrix(t),r=n&&n.dimension?n.dimension:"auto",i=function(t){let n=Complex.ZERO,e=Complex.ZERO;for(let r=0;r<t.length;r++){const i=t[r].add(e),o=n.add(i);e=o.sub(n).sub(i),n=o}return[n]};return e.eachVector(i,r)}static mean(t,n){const e=Matrix._toMatrix(t),r=n&&n.dimension?n.dimension:"auto",i=function(t){let n=Complex.ZERO,e=Complex.ZERO;for(let r=0;r<t.length;r++){const i=t[r].add(e),o=n.add(i);e=o.sub(n).sub(i),n=o}return[n.div(t.length)]};return e.eachVector(i,r)}static prod(t,n){const e=Matrix._toMatrix(t),r=n&&n.dimension?n.dimension:"auto",i=function(t){let n=Complex.ONE;for(let e=0;e<t.length;e++)n=n.mul(t[e]);return[n]};return e.eachVector(i,r)}static geomean(t,n){const e=Matrix._toMatrix(t),r=n&&n.dimension?n.dimension:"auto",i=function(t){let n=Complex.ONE;for(let e=0;e<t.length;e++)n=n.mul(t[e]);return[n.pow(Complex.create(t.length).inv())]};return e.eachVector(i,r)}static median(t,n){const e=Matrix._toMatrix(t),r=n&&n.dimension?n.dimension:"auto",i=function(t,n){return t.compareTo(n)},o=function(t){t.sort(i);let n;if(t.length%2==1)n=t[Math.floor(t.length/2)];else{const e=t[Math.floor(t.length/2)-1],r=t[Math.floor(t.length/2)];n=e.add(r).div(Complex.TWO)}return[n]};return e.eachVector(o,r)}static mode(t,n){const e=Matrix._toMatrix(t),r=n&&n.dimension?n.dimension:"auto",i=function(t,n){return t.compareTo(n)},o=function(t){t.sort(i);const n={};for(let e=0;e<t.length;e++){const r=t[e].real+" "+t[e].imag;n[r]?n[r].value++:n[r]={complex:t[e],value:1}}let e=Complex.ZERO,r=Number.NEGATIVE_INFINITY;for(const t in n){const i=n[t];i.value>r&&(r=i.value,e=i.complex)}return[e]};return e.eachVector(o,r)}static moment(t,n,e){const r=Matrix._toMatrix(t),i=Statistics.mean(r),o=e&&"number"==typeof e.correction?Matrix._toDouble(e.correction):1,a=e&&e.dimension?e.dimension:"auto",s=Matrix._toComplex(n);let c=0;const u=function(t){let n;n=i.isScalar()?i.scalar:i.getComplex(c++);let e=Complex.ZERO;for(let r=0;r<t.length;r++){const i=t[r].sub(n);e=e.add(i.pow(s))}return 1===t.length?[e.div(t.length)]:[e.div(t.length-1+o)]};return r.eachVector(u,a)}static var(t,n){const e=Matrix._toMatrix(t),r=Statistics.mean(e),i=n&&"number"==typeof n.correction?Matrix._toDouble(n.correction):0,o=n&&n.dimension?n.dimension:"auto";let a=0;const s=function(t){if(1===t.length)return[Complex.ZERO];const n=r.getComplex(a++);let e=0;for(let r=0;r<t.length;r++){const i=t[r].sub(n).norm;e+=i*i}return[Complex.create(e/(t.length-1+i))]};return e.eachVector(s,o)}static std(t,n){const e=Matrix._toMatrix(t),r=n&&"number"==typeof n.correction?Matrix._toDouble(n.correction):0,i=n&&n.dimension?n.dimension:"auto",o=Statistics.var(e,{correction:r,dimension:i});return o._each(function(t){return t.sqrt()}),o}static mad(t,n,e){const r=Matrix._toMatrix(t),i=n?"string"==typeof n?n:Matrix._toInteger(n):"mean",o=e&&e.dimension?e.dimension:"auto";if("mean"===i||0===i)return Statistics.mean(r.sub(Statistics.mean(r,{dimension:o})).abs(),{dimension:o});if("median"===i||1===i)return Statistics.median(r.sub(Statistics.median(r,{dimension:o})).abs(),{dimension:o});throw"mad unsupported argument "+i}static skewness(t,n){const e=Matrix._toMatrix(t),r=n&&"number"==typeof n.correction?Matrix._toDouble(n.correction):1,i=n&&n.dimension?n.dimension:"auto",o=Statistics.moment(e,3,{correction:r,dimension:i}),a=Statistics.std(e,{correction:r,dimension:i});return 1===r?o.dotdiv(a.dotpow(3)):o.dotdiv(a.dotpow(3)).dotmul(2)}static cov(t,n){const e=Matrix._toMatrix(t),r=n&&"number"==typeof n.correction?Matrix._toDouble(n.correction):0;if(e.isVector())return Statistics.var(e,n);const i=1===e.row_length?1:r,o=e.matrix_array,a=Statistics.mean(e).matrix_array[0],s=new Array(e.column_length);for(let t=0;t<e.column_length;t++){const n=a[t];s[t]=new Array(e.column_length);for(let r=t;r<e.column_length;r++){const c=a[r];let u=Complex.ZERO;for(let i=0;i<e.row_length;i++)u=u.add(o[i][t].sub(n).dot(o[i][r].sub(c)));s[t][r]=u.div(e.row_length-1+i)}}for(let t=1;t<s[0].length;t++)for(let n=0;n<t;n++)s[t][n]=s[n][t];return new Matrix(s)}static normalize(t,n){const e=Matrix._toMatrix(t),r=e.sub(Statistics.mean(e,n));return r.dotdiv(Statistics.std(r,n))}static corrcoef(t,n){const e=Matrix._toMatrix(t);return Statistics.cov(Statistics.normalize(e,n),n)}static sort(t,n,e){const r=Matrix._toMatrix(t),i=e&&e.dimension?e.dimension:"auto";let o;o="ascend"===(n||"ascend")?function(t,n){return t.compareTo(n)}:function(t,n){return n.compareTo(t)};const a=function(t){return t.sort(o),t};return r.eachVector(a,i)}}class FFT{static bit_reverse_32(t){let n=4294967295&t;return n=(1431655765&n)<<1|n>>1&1431655765,n=(858993459&n)<<2|n>>2&858993459,n=(252645135&n)<<4|n>>4&252645135,n=(16711935&n)<<8|n>>8&16711935,n=(65535&n)<<16|n>>16&65535}static create_bit_reverse_table(t){const n=1<<t,e=[];for(let r=0;r<n;r++)e[r]=FFT.bit_reverse_32(r)>>>32-t;return e}constructor(t){this.size=t,this.inv_size=1/this.size,this.bit_size=Math.round(Math.log(this.size)/Math.log(2)),this.is_fast=1<<this.bit_size===this.size,this.bitrv=null,this.fft_re=new Array(this.size),this.fft_im=new Array(this.size);{const t=-2*Math.PI/this.size;let n=0;for(let e=0,r=0;e<this.size;e++){this.fft_re[e]=Math.cos(r),this.fft_im[e]=Math.sin(r);const i=t+n,o=r+i;n=o-r-i,r=o}}this.is_fast&&(this.bitrv=FFT.create_bit_reverse_table(this.bit_size))}delete(){delete this.size,delete this.inv_size,delete this.bit_size,delete this.is_fast,delete this.bitrv,delete this.fft_re,delete this.fft_im}fft(t,n){const e=new Array(this.size),r=new Array(this.size);if(this.is_fast){for(let i=0;i<this.size;i++)e[i]=t[this.bitrv[i]],r[i]=n[this.bitrv[i]];{let t=1,n=this.size/2,i=2;for(let o=1<<this.bit_size-1;o>0;o>>=1){for(let a=0;a<n;a++){let n=a*i;for(let i=0,a=0;i<t;i++,n++,a+=o){const i=e[n+t]*this.fft_re[a]-r[n+t]*this.fft_im[a],o=r[n+t]*this.fft_re[a]+e[n+t]*this.fft_im[a];e[n+t]=e[n]-i,r[n+t]=r[n]-o,e[n]+=i,r[n]+=o}}n/=2,i*=2,t*=2}}}else if(SignalTool.isContainsZero(n))for(let i=0;i<this.size;i++){e[i]=0,r[i]=0;for(let o=0,a=0;o<this.size;o++,a=o*i%this.size)e[i]+=t[o]*this.fft_re[a]-n[o]*this.fft_im[a],r[i]+=t[o]*this.fft_im[a]+n[o]*this.fft_re[a]}else for(let n=0;n<this.size;n++){e[n]=0,r[n]=0;for(let i=0,o=0;i<this.size;i++,o=i*n%this.size)e[n]+=t[i]*this.fft_re[o],r[n]+=t[i]*this.fft_im[o]}return{real:e,imag:r}}ifft(t,n){const e=new Array(this.size),r=new Array(this.size);if(this.is_fast){for(let i=0;i<this.size;i++)e[i]=t[this.bitrv[i]],r[i]=n[this.bitrv[i]];{let t,n,i=1,o=this.size/2,a=2;for(let s=1<<this.bit_size-1;s>0;s>>=1){for(let c=0;c<o;c++){let o=c*a;for(let a=0,c=0;a<i;a++,o++,c+=s)t=e[o+i]*this.fft_re[c]+r[o+i]*this.fft_im[c],n=r[o+i]*this.fft_re[c]-e[o+i]*this.fft_im[c],e[o+i]=e[o]-t,r[o+i]=r[o]-n,e[o]+=t,r[o]+=n}o/=2,a*=2,i*=2}}}else if(SignalTool.isContainsZero(n))for(let i=0;i<this.size;i++){e[i]=0,r[i]=0;for(let o=0,a=0;o<this.size;o++,a=i*o%this.size)e[i]+=t[o]*this.fft_re[a]+n[o]*this.fft_im[a],r[i]+=-t[o]*this.fft_im[a]+n[o]*this.fft_re[a]}else for(let n=0;n<this.size;n++){e[n]=0,r[n]=0;for(let i=0,o=0;i<this.size;i++,o=n*i%this.size)e[n]+=t[i]*this.fft_re[o],r[n]+=-t[i]*this.fft_im[o]}for(let t=0;t<this.size;t++)e[t]*=this.inv_size,r[t]*=this.inv_size;return{real:e,imag:r}}}class Cache{constructor(t,n){this.object=n,this.table_max=t,this.table_size=0,this.table=[]}get(t){for(let n=0;n<this.table_size;n++)if(this.table[n].size===t){const t=this.table.splice(n,1);return this.table.unshift(t),t}const n=new this.object(t);if(this.table_size===this.table_max){const t=this.table.pop();t.delete()}return this.table.unshift(n),n}}const fft_cache=new Cache(4,FFT);class DCT{constructor(t){this.size=t,this.dct_size=2*t,this.dct_re=new Array(this.size),this.dct_im=new Array(this.size);{const t=1/Math.sqrt(this.size),n=t*Math.sqrt(2);for(let e=0;e<this.size;e++){const r=-Math.PI*e/this.dct_size;this.dct_re[e]=Math.cos(r)*(0===e?t:n),this.dct_im[e]=Math.sin(r)*(0===e?t:n)}}}delete(){delete this.size,delete this.dct_size,delete this.dct_re,delete this.dct_im}dct(t){const n=new Array(this.dct_size),e=new Array(this.dct_size);for(let r=0;r<this.dct_size;r++)n[r]=r<this.size?t[r]:0,e[r]=0;const r=fft_cache.get(this.dct_size).fft(n,e);for(let t=0;t<this.size;t++)n[t]=r.real[t]*this.dct_re[t]-r.imag[t]*this.dct_im[t];return n.splice(this.size),n}idct(t){const n=new Array(this.dct_size),e=new Array(this.dct_size),r=2*this.size;for(let i=0;i<this.dct_size;i++)n[i]=i<this.size?r*t[i]*this.dct_re[i]:0,e[i]=i<this.size?r*t[i]*-this.dct_im[i]:0;const i=fft_cache.get(this.dct_size).ifft(n,e);return i.real.splice(this.size),i.real}}const dct_cache=new Cache(4,DCT);class SignalTool{static isContainsZero(t){for(let n=0;n<t.length;n++)if(0!==t[n])return!0;return!1}static fft(t,n){return fft_cache.get(t.length).fft(t,n)}static ifft(t,n){return fft_cache.get(t.length).ifft(t,n)}static dct(t){return dct_cache.get(t.length).dct(t)}static idct(t){return dct_cache.get(t.length).idct(t)}static powerfft(t,n){const e=t.length,r=SignalTool.fft(t,n),i=new Array(e);for(let t=0;t<e;t++)i[t]=r.real[t]*r.real[t]+r.imag[t]*r.imag[t];return i}static conv(t,n,e,r){let i=!1;if(t.length===e.length){i=!0;for(let o=0;o<t.length;o++)if(t[o]!==e[o]||n[o]!==r[o]){i=!1;break}}const o=t.length,a=2*o;if(1<<Math.round(Math.log(o)/Math.log(2))===o){if(i){const e=t.length,r=new Array(a),i=new Array(a);for(let o=0;o<a;o++)r[o]=o<e?t[o]:0,i[o]=o<e?n[o]:0;const o=SignalTool.fft(r,i);for(let t=0;t<a;t++)r[t]=o.real[t]*o.real[t]-o.imag[t]*o.imag[t],i[t]=o.real[t]*o.imag[t]+o.imag[t]*o.real[t];const s=SignalTool.ifft(r,i);return s.real.splice(a-1),s.imag.splice(a-1),s}if(t.length===e.length){const i=t.length,o=new Array(a),s=new Array(a),c=new Array(a),u=new Array(a);for(let l=0;l<a;l++)o[l]=l<i?t[l]:0,s[l]=l<i?n[l]:0,c[l]=l<i?e[l]:0,u[l]=l<i?r[l]:0;const l=SignalTool.fft(o,s),h=SignalTool.fft(c,u),g=new Array(a),f=new Array(a);for(let t=0;t<a;t++)g[t]=l.real[t]*h.real[t]-l.imag[t]*h.imag[t],f[t]=l.real[t]*h.imag[t]+l.imag[t]*h.real[t];const m=SignalTool.ifft(g,f);return m.real.splice(a-1),m.imag.splice(a-1),m}}let s=!SignalTool.isContainsZero(n);s&&(s=!SignalTool.isContainsZero(r));{const i=new Array(t.length+e.length-1),o=new Array(t.length+e.length-1);for(let t=0;t<i.length;t++)i[t]=0,o[t]=0;if(s)for(let n=0;n<e.length;n++)for(let r=0;r<t.length;r++)i[n+r]+=t[r]*e[n];else for(let a=0;a<e.length;a++)for(let s=0;s<t.length;s++)i[a+s]+=t[s]*e[a]-n[s]*r[a],o[a+s]+=t[s]*r[a]+n[s]*e[a];return{real:i,imag:o}}}static xcorr(t,n,e,r){let i=!1;if(t.length===e.length){i=!0;for(let o=0;o<t.length;o++)if(t[o]!==e[o]||n[o]!==r[o]){i=!1;break}}if(t.length===e.length){const o=t.length,a=2*o,s=Math.round(Math.log(o)/Math.log(2)),c=1<<s===o;if(c){let s=null;if(i){const e=new Array(a),r=new Array(a);for(let i=0;i<a;i++)e[i]=i<o?t[i]:0,r[i]=i<o?n[i]:0;const i=SignalTool.powerfft(e,r);s=SignalTool.ifft(i,r),e.pop(),r.pop();for(let t=0,n=o+1;t<e.length;t++,n++)a<=n&&(n=0),e[t]=s.real[n],r[t]=s.imag[n];return{real:e,imag:r}}{const i=new Array(a),c=new Array(a),u=new Array(a),l=new Array(a);for(let s=0;s<a;s++)i[s]=s<o?t[s]:0,c[s]=s<o?n[s]:0,u[s]=s<o?e[o-s-1]:0,l[s]=s<o?-r[o-s-1]:0;const h=SignalTool.fft(i,c),g=SignalTool.fft(u,l),f=new Array(a),m=new Array(a);for(let t=0;t<a;t++)f[t]=h.real[t]*g.real[t]-h.imag[t]*g.imag[t],m[t]=h.real[t]*g.imag[t]+h.imag[t]*g.real[t];return(s=SignalTool.ifft(f,m)).real.splice(a-1),s.imag.splice(a-1),s}}}let o=!SignalTool.isContainsZero(n);if(o&&(o=!SignalTool.isContainsZero(r)),i){const n=t.length,r=2*n;if(o){const i=new Array(n);for(let r=0;r<n;r++){i[r]=0;const o=n-r;for(let n=0;n<o;n++)i[r]+=t[n]*e[n+r]}const o=new Array(r-1),a=new Array(r-1);for(let t=0,e=n-1;t<n;t++,e--)o[t]=i[e],o[n+t-1]=i[t];for(let t=0;t<a.length;t++)a[t]=0;return{real:o,imag:a}}}{const i=new Array(e.length),o=new Array(e.length);for(let t=0;t<e.length;t++)i[t]=e[e.length-t-1],o[t]=-r[e.length-t-1];const a=SignalTool.conv(t,n,i,o);if(t.length===e.length)return a;const s=Math.abs(t.length-e.length),c=new Array(s);for(let t=0;t<s;t++)c[t]=0;return t.length>e.length?{real:c.concat(a.real),imag:c.concat(a.imag)}:{real:a.real.concat(c),imag:a.imag.concat(c)}}}static window(t,n,e){const r=void 0!==e?e:"symmetric",i=t.toLocaleLowerCase(),o=n,a=new Array(o);let s;"symmetric"===r||0===r?s=function(t){return t/(o-1)*(2*Math.PI)}:"periodic"!==r&&0===r||(s=function(t){return t/o*(2*Math.PI)});const c=function(t,n,e,r,i){for(let c=0;c<o;c++)a[c]=t,a[c]-=n*Math.cos(1*s(c)),a[c]+=e*Math.cos(2*s(c)),a[c]-=r*Math.cos(3*s(c)),a[c]+=i*Math.cos(4*s(c))};switch(i){case"rectangle":c(1,0,0,0,0);break;case"hann":c(.5,.5,0,0,0);break;case"hamming":c(.54,.46,0,0,0);break;case"blackman":c(.42,.5,.08,0,0);break;case"blackmanharris":c(.35875,.48829,.14128,.01168,0);break;case"blackmannuttall":c(.3635819,.4891775,.1365995,.0106411,0);break;case"flattop":c(1,1.93,1.29,.388,.032);break;case"sin":for(let t=0;t<o;t++)a[t]=Math.sin(.5*s(t));break;case"vorbis":for(let t=0;t<o;t++){const n=Math.sin(.5*s(t));a[t]=Math.sin(.5*Math.PI*n*n)}}return a}static hann(t,n){return SignalTool.window("hann",t,n)}static hamming(t,n){return SignalTool.window("hamming",t,n)}}class Signal{static fft(t,n){const e=n&&n.dimension?n.dimension:"auto",r=function(t){const n=new Array(t.length),e=new Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r].real,e[r]=t[r].imag;const r=SignalTool.fft(n,e),i=new Array(t.length);for(let n=0;n<t.length;n++)i[n]=new Complex([r.real[n],r.imag[n]]);return i};return Matrix._toMatrix(t).eachVector(r,e)}static ifft(t,n){const e=n&&n.dimension?n.dimension:"auto",r=function(t){const n=new Array(t.length),e=new Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r].real,e[r]=t[r].imag;const r=SignalTool.ifft(n,e),i=new Array(t.length);for(let n=0;n<t.length;n++)i[n]=new Complex([r.real[n],r.imag[n]]);return i};return Matrix._toMatrix(t).eachVector(r,e)}static powerfft(t,n){const e=n&&n.dimension?n.dimension:"auto",r=function(t){const n=new Array(t.length),e=new Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r].real,e[r]=t[r].imag;const r=SignalTool.powerfft(n,e),i=new Array(t.length);for(let n=0;n<t.length;n++)i[n]=new Complex(r[n]);return i};return Matrix._toMatrix(t).eachVector(r,e)}static dct(t,n){const e=n&&n.dimension?n.dimension:"auto",r=Matrix._toMatrix(t);if(r.isComplex())throw"dct don't support complex numbers.";const i=function(t){const n=new Array(t.length);for(let e=0;e<t.length;e++)n[e]=t[e].real;const e=SignalTool.dct(n),r=new Array(t.length);for(let n=0;n<t.length;n++)r[n]=new Complex(e[n]);return r};return r.eachVector(i,e)}static idct(t,n){const e=n&&n.dimension?n.dimension:"auto",r=Matrix._toMatrix(t);if(r.isComplex())throw"idct don't support complex numbers.";const i=function(t){const n=new Array(t.length);for(let e=0;e<t.length;e++)n[e]=t[e].real;const e=SignalTool.idct(n),r=new Array(t.length);for(let n=0;n<t.length;n++)r[n]=new Complex(e[n]);return r};return r.eachVector(i,e)}static fft2(t){return Signal.fft(t,{dimension:"both"})}static ifft2(t){return Signal.ifft(t,{dimension:"both"})}static dct2(t){return Signal.dct(t,{dimension:"both"})}static idct2(t){return Signal.idct(t,{dimension:"both"})}static conv(t,n){const e=Matrix._toMatrix(t),r=Matrix._toMatrix(n);if(e.isMatrix()||r.isMatrix())throw"conv don't support matrix numbers.";const i=new Array(e.length),o=new Array(e.length),a=new Array(r.length),s=new Array(r.length);if(e.isRow())for(let t=0;t<e.column_length;t++)i[t]=e.matrix_array[0][t].real,o[t]=e.matrix_array[0][t].imag;else for(let t=0;t<e.row_length;t++)i[t]=e.matrix_array[t][0].real,o[t]=e.matrix_array[t][0].imag;if(r.isRow())for(let t=0;t<r.column_length;t++)a[t]=r.matrix_array[0][t].real,s[t]=r.matrix_array[0][t].imag;else for(let t=0;t<r.row_length;t++)a[t]=r.matrix_array[t][0].real,s[t]=r.matrix_array[t][0].imag;const c=SignalTool.conv(i,o,a,s),u=new Array(c.real.length);for(let t=0;t<c.real.length;t++)u[t]=new Complex([c.real[t],c.imag[t]]);const l=new Matrix([u]);return r.isRow()?l:l.transpose()}static xcorr(t,n){const e=Matrix._toMatrix(t);if(!n)return e.xcorr(e);const r=Matrix._toMatrix(n);if(e.isMatrix()||r.isMatrix())throw"conv don't support matrix numbers.";const i=new Array(e.length),o=new Array(e.length),a=new Array(r.length),s=new Array(r.length);if(e.isRow())for(let t=0;t<e.column_length;t++)i[t]=e.matrix_array[0][t].real,o[t]=e.matrix_array[0][t].imag;else for(let t=0;t<e.row_length;t++)i[t]=e.matrix_array[t][0].real,o[t]=e.matrix_array[t][0].imag;if(r.isRow())for(let t=0;t<r.column_length;t++)a[t]=r.matrix_array[0][t].real,s[t]=r.matrix_array[0][t].imag;else for(let t=0;t<r.row_length;t++)a[t]=r.matrix_array[t][0].real,s[t]=r.matrix_array[t][0].imag;const c=SignalTool.xcorr(i,o,a,s),u=new Array(c.real.length);for(let t=0;t<c.real.length;t++)u[t]=new Complex([c.real[t],c.imag[t]]);const l=new Matrix([u]);return e.isRow()?l:l.transpose()}static window(t,n,e){const r=Matrix._toInteger(n),i=SignalTool.window(t,r,e);return new Matrix(i).transpose()}static hann(t,n){return Signal.window("hann",t,n)}static hamming(t,n){return Signal.window("hamming",t,n)}static fftshift(t,n){const e=Matrix._toMatrix(t);if(e.isVector()){const t=Math.floor(e.length/2);return e.circshift(t,n)}const r=Math.floor(e.column_length/2),i=Math.floor(e.row_length/2);if(void 0!==n){const t=n.dimension;if("row"===t||1===t)return e.circshift(r,n);if("column"===t||2===t)return e.circshift(i,n)}return e.circshift(r,{dimension:"row"}).circshift(i,{dimension:"column"})}}class MatrixTool{static toPositionArrayFromObject(t,n,e){if("string"==typeof t){const r=MatrixTool.toArrayFromString(t);if(":"===r){const t=new Array(n);for(let r=0;r<n;r++)t[r]=r+e;return t}if(r instanceof Array){const t=r,n=new Array(t.length);for(let e=0;e<t.length;e++)n[e]=Math.trunc(t[e].real);return n}throw"toArrayFromString["+t+"]["+r+"]"}let r=t;if(r instanceof Matrix||r instanceof Complex||"number"==typeof r||(r=Matrix._toMatrix(r)),r instanceof Matrix){if(!r.isVector())throw"getMatrix argument "+r;const t=r.length,n=new Array(r.length);if(r.isRow())for(let e=0;e<t;e++)n[e]=Math.trunc(r.matrix_array[0][e].real);else if(r.isColumn())for(let e=0;e<t;e++)n[e]=Math.trunc(r.matrix_array[e][0].real);return n}return[Matrix._toInteger(r)]}static match2(t,n){const e=[];let r=t;for(let t=0;t<1e3;t++){const t=r.match(n);if(null===t){r.length&&e.push([!1,r]);break}t.index>0&&e.push([!1,r.substr(0,t.index)]),e.push([!0,t[0]]),r=r.substr(t.index+t[0].length)}return e}static trimBracket(t){return/^\[/.test(t)&&/\]$/.test(t)?t.substring(1,t.length-1):null}static toMatrixArrayFromStringForArrayJSON(t){const n=[];let e=t.match(/\[[^\]]+\]/g);null===e&&(e=[t]);for(let t=0;t<e.length;t++){const r=e[t],i=r.substring(1,r.length-1).split(","),o=[];for(let t=0;t<i.length;t++){const n=i[t];o[t]=new Complex(n)}n[t]=o}return n}static InterpolationCalculation(t,n,e,r){const i=t.compareTo(e),o=void 0===r||r;if(0===i)return[t];if(n.isZero())throw"IllegalArgumentException";if(n.isNegative()&&-1===i)throw"IllegalArgumentException";const a=[];let s=t;a[0]=s;for(let t=1;t<65536;t++){if(s=s.add(n),o){if(e.compareTo(s)===i)break}else if(e.compareTo(s)*i>=0)break;a[t]=s}return a}static toArrayFromMatch2String(t){const n=t,e=[];for(let t=0;t<n.length;t++){const r=n[t];if(r[0])if(t<n.length-2&&!n[t+1][0]&&/:/.test(n[t+1][1])){let i,o,a;t<n.length-4&&!n[t+3][0]&&/:/.test(n[t+3][1])?(i=new Complex(r[1]),o=new Complex(n[t+2][1]),a=new Complex(n[t+4][1]),t+=4):(i=new Complex(r[1]),o=Complex.ONE,a=new Complex(n[t+2][1]),t+=2);const s=MatrixTool.InterpolationCalculation(i,o,a,!0);for(let t=0;t<s.length;t++)e.push(s[t])}else e.push(new Complex(r[1]))}return e}static toArrayFromString(t){if(":"===t.trim())return":";const n=t.toLowerCase().replace(/infinity|inf/g,"1e100000"),e=new RegExp("("+/[+-]? *(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan))?[ij]( *[+] *[- ]?(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan)))?/.source+")|("+/[+-]? *(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan))( *[+-] *[- ]?(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan))?[ij])?/.source+")","i");return MatrixTool.toArrayFromMatch2String(MatrixTool.match2(n,e))}static toMatrixArrayFromStringForArraySPACE(t){const n=t.split(";"),e=new Array(n.length);for(let t=0;t<n.length;t++)e[t]=MatrixTool.toArrayFromString(n[t]);return e}static toMatrixArrayFromStringInBracket(t){return/[[\]]/.test(t)?MatrixTool.toMatrixArrayFromStringForArrayJSON(t):MatrixTool.toMatrixArrayFromStringForArraySPACE(t)}static toMatrixArrayFromString(t){const n=t.replace(/^\s*|\s*$/g,""),e=MatrixTool.trimBracket(n);return e?MatrixTool.toMatrixArrayFromStringInBracket(e):[[new Complex(t)]]}static isCorrectMatrixArray(t){if(0===t.length)return!1;const n=t[0].length;if(0===n)return!1;for(let e=1;e<t.length;e++)if(t[e].length!==n)return!1;return!0}}class Matrix{constructor(t){let n=null,e=!1;if(1!==arguments.length)throw"Matrix : Many arguments ["+arguments.length+"]";{const r=t;if(r instanceof Matrix){n=new Array(r.row_length);for(let t=0;t<r.row_length;t++){n[t]=new Array(r.column_length);for(let e=0;e<r.column_length;e++)n[t][e]=r.matrix_array[t][e]}}else if(r instanceof Complex)n=[[r]];else if(r instanceof Array){n=[];for(let t=0;t<r.length;t++){const e=r[t];if(e instanceof Array){const r=new Array(e.length);for(let t=0;t<e.length;t++){const n=e[t];if(n instanceof Complex)r[t]=n;else if(n instanceof Matrix){if(!n.isScalar())throw"Matrix in matrix";r[t]=n.scalar}else r[t]=new Complex(n)}n[t]=r}else if(0===t&&(n[0]=new Array(r.length)),e instanceof Complex)n[0][t]=e;else if(e instanceof Matrix){if(!e.isScalar())throw"Matrix in matrix";n[0][t]=e.scalar}else n[0][t]=new Complex(e)}}else"string"==typeof r?(e=!0,n=MatrixTool.toMatrixArrayFromString(r)):r instanceof Object?(e=!0,n=MatrixTool.toMatrixArrayFromString(r.toString())):n=[[new Complex(r)]]}if(e)for(let t=0;t<n.length;t++)":"===n[t]&&n.splice(t--,1);if(!MatrixTool.isCorrectMatrixArray(n))throw console.log(n),"new Matrix IllegalArgumentException";this.matrix_array=n,this.row_length=this.matrix_array.length,this.column_length=this.matrix_array[0].length,this.string_cash=null}static create(t){return 1===arguments.length&&t instanceof Matrix?t:new Matrix(t)}static valueOf(t){return Matrix.create(t)}static _toMatrix(t){return t instanceof Matrix?t:new Matrix(t)}static _toComplex(t){if(t instanceof Complex)return t;const n=Matrix._toMatrix(t);if(n.isScalar())return n.scalar;throw"not scalar. ["+t+"]"}static _toDouble(t){if("number"==typeof t)return t;const n=Matrix._toComplex(t);if(n.isReal())return n.real;throw"not support complex numbers."}static _toInteger(t){return Math.trunc(Matrix._toDouble(t))}_clearCash(){this.string_cash&&delete this.string_cash}clone(){return new Matrix(this.matrix_array)}toString(){if(this.string_cash)return this.string_cash;const t=Math.pow(10,9);let n=!1,e=!1,r=0;this._each(function(i){i.isReal()||(n=!0),Number.isFinite(i.real)&&Math.abs(i.real)>=t&&(e=!0),Number.isFinite(i.imag)&&Math.abs(i.imag)>=t&&(e=!0),r=Math.max(r,i.getDecimalPosition())}),r>0&&(r=4);let i=0;const o=[],a=function(t){const n=e?t.toExponential(4):t.toFixed(r);if(/inf/i.test(n))return t===Number.POSITIVE_INFINITY?"Inf":"-Inf";if(/nan/i.test(n))return"NaN";if(!e)return n;const i=n.split("e");let o=i[1];return 2===o.length?o=o.substr(0,1)+"00"+o.substr(1):3===o.length&&(o=o.substr(0,1)+"0"+o.substr(1)),i[0]+"e"+o};this._each(function(t){const e={};let r=t.real;if(e.re_sign=r<0?"-":" ",r=Math.abs(r),e.re_str=a(r),i=Math.max(i,e.re_str.length+1),n){let n=t.imag;e.im_sign=n<0?"-":"+",n=Math.abs(n),e.im_str=a(n),i=Math.max(i,e.im_str.length+1)}o.push(e)});const s=function(t,n){return"                                        ".substr(0,n-t.length)+t},c=[],u=this;return this._each(function(t,e,r){const a=o.shift();let l=s(a.re_sign+a.re_str,i);n&&(l+=" "+a.im_sign+s(a.im_str,i)+"i"),c.push(l),c.push(r<u.column_length-1?" ":"\n")}),this.string_cash=c.join(""),this.string_cash}toOneLineString(){if(this.isScalar())return this.scalar.toString();let t="[ ";for(let n=0;n<this.row_length;n++)for(let e=0;e<this.column_length;e++)t+=this.matrix_array[n][e].toString(),e<this.column_length-1?t+=", ":n<this.row_length-1&&(t+="; ");return t+=" ]"}equals(t,n){const e=this,r=Matrix._toMatrix(t);if(e.row_length!==r.row_length||e.column_length!==r.column_length)return!1;if(1===e.row_length&&1===e.column_length)return e.scalar.equals(r.scalar,n);const i=e.matrix_array,o=r.matrix_array;for(let t=0;t<this.row_length;t++)for(let e=0;e<this.column_length;e++)if(!i[t][e].equals(o[t][e],n))return!1;return!0}getNumberMatrixArray(){const t=new Array(this.row_length);for(let n=0;n<this.row_length;n++){t[n]=new Array(this.column_length);for(let e=0;e<this.column_length;e++)t[n][e]=this.matrix_array[n][e].real}return t}getComplexMatrixArray(){const t=new Array(this.row_length);for(let n=0;n<this.row_length;n++){t[n]=new Array(this.column_length);for(let e=0;e<this.column_length;e++)t[n][e]=this.matrix_array[n][e]}return t}_each(t){let n=!1;for(let e=0;e<this.row_length;e++)for(let r=0;r<this.column_length;r++){const i=t(this.matrix_array[e][r],e,r);void 0!==i&&(this.matrix_array[e][r]=i instanceof Complex?i:i instanceof Matrix?i.scalar:new Complex(i),n=!0)}return n&&this._clearCash(),this}cloneMatrixDoEachCalculation(t){return this.clone()._each(t)}static createMatrixDoEachCalculation(t,n,e){if(0===arguments.length||arguments.length>3)throw"IllegalArgumentException";const r=Matrix._toInteger(n),i=e?Matrix._toInteger(e):r,o=new Array(r);for(let n=0;n<r;n++){o[n]=new Array(i);for(let e=0;e<i;e++){const r=t(n,e);o[n][e]=void 0===r?Complex.ZERO:Matrix._toComplex(r)}}return new Matrix(o)}eachVectorAuto(t){if(this.isRow()){const n=new Array(this.row_length);for(let t=0;t<this.column_length;t++)n[t]=this.matrix_array[0][t];return new Matrix(t(n))}{const n=new Matrix(0);n._resize(1,this.column_length);for(let e=0;e<this.column_length;e++){const r=new Array(this.row_length);for(let t=0;t<this.row_length;t++)r[t]=this.matrix_array[t][e];const i=t(r);n._resize(Math.max(n.row_length,i.length),n.column_length);for(let t=0;t<i.length;t++)n.matrix_array[t][e]=i[t]}return n}}eachVectorBoth(t){const n=new Matrix(0);n._resize(this.row_length,1);for(let e=0;e<this.row_length;e++){const r=new Array(this.column_length);for(let t=0;t<this.column_length;t++)r[t]=this.matrix_array[e][t];const i=t(r);n._resize(n.row_length,Math.max(n.column_length,i.length));for(let t=0;t<i.length;t++)n.matrix_array[e][t]=i[t]}const e=new Matrix(0);e._resize(1,n.column_length);for(let r=0;r<n.column_length;r++){const i=new Array(n.row_length);for(let t=0;t<n.row_length;t++)i[t]=n.matrix_array[t][r];const o=t(i);e._resize(Math.max(e.row_length,o.length),e.column_length);for(let t=0;t<o.length;t++)e.matrix_array[t][r]=o[t]}return e}eachVectorRow(t){const n=new Matrix(0);n._resize(this.row_length,1);for(let e=0;e<this.row_length;e++){const r=new Array(this.column_length);for(let t=0;t<this.column_length;t++)r[t]=this.matrix_array[e][t];const i=t(r);n._resize(n.row_length,Math.max(n.column_length,i.length));for(let t=0;t<i.length;t++)n.matrix_array[e][t]=i[t]}return n}eachVectorColumn(t){const n=new Matrix(0);n._resize(1,this.column_length);for(let e=0;e<this.column_length;e++){const r=new Array(this.row_length);for(let t=0;t<this.row_length;t++)r[t]=this.matrix_array[t][e];const i=t(r);n._resize(Math.max(n.row_length,i.length),n.column_length);for(let t=0;t<i.length;t++)n.matrix_array[t][e]=i[t]}return n}eachVector(t,n){let e=void 0!==n?n:"auto";if("string"==typeof e?e=e.toLocaleLowerCase():"number"!=typeof e&&(e=Matrix._toInteger(e)),"auto"===e||0===e)return this.eachVectorAuto(t);if("row"===e||1===e)return this.eachVectorRow(t);if("column"===e||2===e)return this.eachVectorColumn(t);if("both"===e||3===e)return this.eachVectorBoth(t);throw"eachVector argument "+n}getMatrix(t,n,e=!1){const r=e?1:0,i=MatrixTool.toPositionArrayFromObject(t,this.row_length,r),o=MatrixTool.toPositionArrayFromObject(n,this.column_length,r),a=this.matrix_array,s=new Array(i.length);for(let t=0;t<i.length;t++){const n=new Array(o.length);for(let e=0;e<o.length;e++)n[e]=a[i[t]-r][o[e]-r];s[t]=n}return new Matrix(s)}setMatrix(t,n,e,r=!1){const i=r?1:0,o=MatrixTool.toPositionArrayFromObject(t,this.row_length,i),a=MatrixTool.toPositionArrayFromObject(n,this.column_length,i),s=new Matrix(this).matrix_array,c=Matrix._toMatrix(e),u=c.matrix_array;for(let t=0;t<o.length;t++)for(let n=0;n<a.length;n++)s[o[t]-i][a[n]-i]=u[t%c.row_length][n%c.column_length];return new Matrix(s)}getComplex(t,n){let e=null,r=null;return 1===arguments.length?e=Matrix._toInteger(t):2===arguments.length&&(e=Matrix._toInteger(t),r=Matrix._toInteger(n)),this.isRow()?this.matrix_array[0][e]:this.isColumn()?this.matrix_array[e][0]:this.matrix_array[e][r]}get intValue(){return Math.trunc(this.matrix_array[0][0].real)}get doubleValue(){return this.matrix_array[0][0].real}get scalar(){return this.matrix_array[0][0]}get length(){return this.row_length>this.column_length?this.row_length:this.column_length}get norm1(){return LinearAlgebra.norm(this,1)}get norm2(){return LinearAlgebra.norm(this,2)}norm(t){return LinearAlgebra.norm(this,t)}cond(t){return LinearAlgebra.cond(this,t)}rcond(){return LinearAlgebra.rcond(this)}rank(t){return LinearAlgebra.rank(this,t)}trace(){return LinearAlgebra.trace(this)}det(){return LinearAlgebra.det(this)}static memset(t,n,e){if(0===arguments.length||arguments.length>3)throw"IllegalArgumentException";const r=Matrix._toMatrix(t);if(r.isScalar()){const t=r.scalar;return Matrix.createMatrixDoEachCalculation(function(){return t},n,e)}{const t=r.matrix_array,i=r.row_length,o=r.column_length;return Matrix.createMatrixDoEachCalculation(function(n,e){return t[n%i][e%o]},n,e)}}static eye(t,n){return Matrix.createMatrixDoEachCalculation(function(t,n){return t===n?Complex.ONE:Complex.ZERO},t,n)}static zeros(t,n){if(0===arguments.length||arguments.length>2)throw"IllegalArgumentException";return Matrix.memset(Complex.ZERO,t,n)}static ones(t,n){if(0===arguments.length||arguments.length>2)throw"IllegalArgumentException";return Matrix.memset(Complex.ONE,t,n)}static rand(t,n){return Matrix.createMatrixDoEachCalculation(function(){return Complex.rand()},t,n)}static randn(t,n){return Matrix.createMatrixDoEachCalculation(function(){return Complex.randn()},t,n)}diag(){if(this.isVector()){const t=this;return Matrix.createMatrixDoEachCalculation(function(n,e){return n===e?t.getComplex(n):Complex.ZERO},this.length)}{const t=Math.min(this.row_length,this.column_length),n=new Array(t);for(let e=0;e<t;e++)n[e]=new Array(1),n[e][0]=this.matrix_array[e][e];return new Matrix(n)}}isScalar(){return 1===this.row_length&&1==this.column_length}isRow(){return 1===this.row_length}isColumn(){return 1===this.column_length}isVector(){return 1===this.row_length||1===this.column_length}isMatrix(){return 1!==this.row_length&&1!==this.column_length}isSquare(){return this.row_length===this.column_length}isReal(t){let n=!0;return this._each(function(e){n&&e.isComplex(t)&&(n=!1)}),n}isComplex(t){return!this.isReal(t)}isZeros(t){let n=!0;const e=t||1e-10;return this._each(function(t){n&&!t.isZero(e)&&(n=!1)}),n}isIdentity(t){let n=!0;const e=t||1e-10;return this._each(function(t,r,i){n&&(r===i?t.isOne(e)||(n=!1):t.isZero(e)||(n=!1))}),n}isDiagonal(t){let n=!0;const e=t||1e-10;return this._each(function(t,r,i){n&&r!==i&&!t.isZero(e)&&(n=!1)}),n}isTridiagonal(t){let n=!0;const e=t||1e-10;return this._each(function(t,r,i){n&&Math.abs(r-i)>1&&!t.isZero(e)&&(n=!1)}),n}isRegular(t){if(!this.isSquare())return!1;const n=t||1e-10;return this.rank(n)===this.row_length}isOrthogonal(t){if(!this.isSquare())return!1;const n=t||1e-10;return this.mul(this.transpose()).isIdentity(n)}isUnitary(t){if(!this.isSquare())return!1;const n=t||1e-10;return this.mul(this.ctranspose()).isIdentity(n)}isSymmetric(t){if(!this.isSquare())return!1;const n=t||1e-10;for(let t=0;t<this.row_length;t++)for(let e=t+1;e<this.column_length;e++)if(!this.matrix_array[t][e].equals(this.matrix_array[e][t],n))return!1;return!0}isHermitian(t){if(!this.isSquare())return!1;const n=t||1e-10;for(let t=0;t<this.row_length;t++)for(let e=t;e<this.column_length;e++)if(t===e){if(!this.matrix_array[t][e].isReal(n))return!1}else if(!this.matrix_array[t][e].equals(this.matrix_array[e][t].conj(),n))return!1;return!0}isTriangleUpper(t){let n=!0;const e=t||1e-10;return this._each(function(t,r,i){n&&r>i&&!t.isZero(e)&&(n=!1)}),n}isTriangleLower(t){let n=!0;const e=t||1e-10;return this._each(function(t,r,i){n&&r<i&&!t.isZero(e)&&(n=!1)}),n}isPermutation(t){if(!this.isSquare())return!1;const n=t||1e-10,e=new Array(this.row_length),r=new Array(this.column_length);for(let t=0;t<this.row_length;t++)for(let i=0;i<this.column_length;i++){const o=this.matrix_array[t][i];if(o.isOne(n)){if(e[t]||r[i])return!1;e[t]=1,r[i]=1}else if(!o.isZero(n))return!1}for(let t=0;t<this.row_length;t++)if(void 0===e[t]||void 0===r[t])return!1;return!0}size(){return new Matrix([[this.row_length,this.column_length]])}compareTo(t,n){const e=this,r=Matrix._toMatrix(t);if(e.isScalar()&&r.isScalar())return e.scalar.compareTo(r.scalar,n);const i=e.matrix_array,o=r.matrix_array,a=Math.max(e.row_length,r.row_length),s=Math.max(e.column_length,r.column_length);return Matrix.createMatrixDoEachCalculation(function(t,n){return i[t%e.row_length][n%e.column_length].compareTo(o[t%r.row_length][n%r.column_length])},a,s)}add(t){const n=this,e=Matrix._toMatrix(t);if(n.row_length!==e.row_length&&n.column_length!==e.column_length)throw"Matrix size does not match";const r=n.matrix_array,i=e.matrix_array,o=Math.max(n.row_length,e.row_length),a=Math.max(n.column_length,e.column_length);return Matrix.createMatrixDoEachCalculation(function(t,o){return r[t%n.row_length][o%n.column_length].add(i[t%e.row_length][o%e.column_length])},o,a)}sub(t){const n=this,e=Matrix._toMatrix(t);if(n.row_length!==e.row_length&&n.column_length!==e.column_length)throw"Matrix size does not match";const r=n.matrix_array,i=e.matrix_array,o=Math.max(n.row_length,e.row_length),a=Math.max(n.column_length,e.column_length);return Matrix.createMatrixDoEachCalculation(function(t,o){return r[t%n.row_length][o%n.column_length].sub(i[t%e.row_length][o%e.column_length])},o,a)}mul(t){const n=this,e=Matrix._toMatrix(t),r=n.matrix_array,i=e.matrix_array;if(n.isScalar()&&e.isScalar())return new Matrix(n.scalar.mul(e.scalar));if(n.isScalar()){const t=new Array(e.row_length);for(let r=0;r<e.row_length;r++){t[r]=new Array(e.column_length);for(let o=0;o<e.column_length;o++)t[r][o]=n.scalar.mul(i[r][o])}return new Matrix(t)}if(e.isScalar()){const t=new Array(n.row_length);for(let i=0;i<n.row_length;i++){t[i]=new Array(n.column_length);for(let o=0;o<n.column_length;o++)t[i][o]=r[i][o].mul(e.scalar)}return new Matrix(t)}if(n.column_length!==e.row_length)throw"Matrix size does not match";{const t=new Array(n.row_length);for(let o=0;o<n.row_length;o++){t[o]=new Array(e.column_length);for(let a=0;a<e.column_length;a++){let e=Complex.ZERO;for(let t=0;t<n.column_length;t++)e=e.add(r[o][t].mul(i[t][a]));t[o][a]=e}}return new Matrix(t)}}div(t){const n=this,e=Matrix._toMatrix(t),r=n.matrix_array;if(n.isScalar()&&e.isScalar())return new Matrix(n.scalar.div(e.scalar));if(e.isScalar()){const t=new Array(n.row_length);for(let i=0;i<n.row_length;i++){t[i]=new Array(n.column_length);for(let o=0;o<n.column_length;o++)t[i][o]=r[i][o].div(e.scalar)}return new Matrix(t)}if(e.row_length===e.column_length){const t=e.det().scalar.norm;return t>1e-10?this.mul(e.inv()):this.mul(e.pinv())}if(n.column_length!==e.column_length)throw"Matrix size does not match";throw"warning"}pow(t){if(!this.isSquare())throw"not square "+this;let n=Matrix._toInteger(t);if(n<0)throw"error negative number "+n;let e,r;for(e=this.clone(),r=Matrix.eye(this.length);0!==n;)0!=(1&n)&&(r=r.mul(e)),e=e.mul(e),n>>>=1;return r}dotmul(t){const n=this,e=Matrix._toMatrix(t);if(!n.isScalar()&&!e.isScalar()&&n.row_length!==e.row_length&&n.column_length!==e.column_length)throw"Matrix size does not match";const r=n.matrix_array,i=e.matrix_array,o=Math.max(n.row_length,e.row_length),a=Math.max(n.column_length,e.column_length);return Matrix.createMatrixDoEachCalculation(function(t,o){return r[t%n.row_length][o%n.column_length].mul(i[t%e.row_length][o%e.column_length])},o,a)}dotdiv(t){const n=this,e=Matrix._toMatrix(t);if(!n.isScalar()&&!e.isScalar()&&n.row_length!==e.row_length&&n.column_length!==e.column_length)throw"Matrix size does not match";const r=n.matrix_array,i=e.matrix_array,o=Math.max(n.row_length,e.row_length),a=Math.max(n.column_length,e.column_length);return Matrix.createMatrixDoEachCalculation(function(t,o){return r[t%n.row_length][o%n.column_length].div(i[t%e.row_length][o%e.column_length])},o,a)}dotinv(){const t=this,n=t.matrix_array;return Matrix.createMatrixDoEachCalculation(function(t,e){return n[t][e].inv()},t.row_length,t.column_length)}dotpow(t){const n=this,e=Matrix._toMatrix(t);if(!n.isScalar()&&!e.isScalar()&&n.row_length!==e.row_length&&n.column_length!==e.column_length)throw"Matrix size does not match";const r=n.matrix_array,i=e.matrix_array,o=Math.max(n.row_length,e.row_length),a=Math.max(n.column_length,e.column_length);return Matrix.createMatrixDoEachCalculation(function(t,o){return r[t%n.row_length][o%n.column_length].pow(i[t%e.row_length][o%e.column_length])},o,a)}nmul(t){return this.dotmul(t)}ndiv(t){return this.dotdiv(t)}ninv(){return this.dotinv()}npow(t){return this.dotpow(t)}real(){return this.cloneMatrixDoEachCalculation(function(t){return new Complex(t.real)})}imag(){return this.cloneMatrixDoEachCalculation(function(t){return new Complex(t.imag)})}arg(){return this.cloneMatrixDoEachCalculation(function(t){return new Complex(t.arg)})}sign(){return this.cloneMatrixDoEachCalculation(function(t){return new Complex(t.sign())})}testInteger(t){return this.cloneMatrixDoEachCalculation(function(n){return n.isInteger(t)?Complex.ONE:Complex.ZERO})}testComplexInteger(t){return this.cloneMatrixDoEachCalculation(function(n){return n.isComplexInteger(t)?Complex.ONE:Complex.ZERO})}testZero(t){return this.cloneMatrixDoEachCalculation(function(n){return n.isZero(t)?Complex.ONE:Complex.ZERO})}testOne(t){return this.cloneMatrixDoEachCalculation(function(n){return n.isOne(t)?Complex.ONE:Complex.ZERO})}testComplex(t){return this.cloneMatrixDoEachCalculation(function(n){return n.isComplex(t)?Complex.ONE:Complex.ZERO})}testReal(t){return this.cloneMatrixDoEachCalculation(function(n){return n.isReal(t)?Complex.ONE:Complex.ZERO})}testNaN(){return this.cloneMatrixDoEachCalculation(function(t){return t.isNaN()?Complex.ONE:Complex.ZERO})}testPositive(){return this.cloneMatrixDoEachCalculation(function(t){return t.isPositive()?Complex.ONE:Complex.ZERO})}testNegative(){return this.cloneMatrixDoEachCalculation(function(t){return t.isNegative()?Complex.ONE:Complex.ZERO})}testNotNegative(){return this.cloneMatrixDoEachCalculation(function(t){return t.isNotNegative()?Complex.ONE:Complex.ZERO})}testInfinite(){return this.cloneMatrixDoEachCalculation(function(t){return t.isInfinite()?Complex.ONE:Complex.ZERO})}testFinite(){return this.cloneMatrixDoEachCalculation(function(t){return t.isFinite()?Complex.ONE:Complex.ZERO})}abs(){return this.cloneMatrixDoEachCalculation(function(t){return t.abs()})}conj(){return this.cloneMatrixDoEachCalculation(function(t){return t.conj()})}negate(){return this.cloneMatrixDoEachCalculation(function(t){return t.negate()})}sqrt(){return this.cloneMatrixDoEachCalculation(function(t){return t.sqrt()})}log(){return this.cloneMatrixDoEachCalculation(function(t){return t.log()})}exp(){return this.cloneMatrixDoEachCalculation(function(t){return t.exp()})}sin(){return this.cloneMatrixDoEachCalculation(function(t){return t.sin()})}cos(){return this.cloneMatrixDoEachCalculation(function(t){return t.cos()})}tan(){return this.cloneMatrixDoEachCalculation(function(t){return t.tan()})}atan(){return this.cloneMatrixDoEachCalculation(function(t){return t.atan()})}atan2(t){const n=Matrix._toComplex(t);return this.cloneMatrixDoEachCalculation(function(t){return t.atan2(n)})}floor(){return this.cloneMatrixDoEachCalculation(function(t){return t.floor()})}ceil(){return this.cloneMatrixDoEachCalculation(function(t){return t.ceil()})}round(){return this.cloneMatrixDoEachCalculation(function(t){return t.round()})}fix(){return this.cloneMatrixDoEachCalculation(function(t){return t.fix()})}fract(){return this.cloneMatrixDoEachCalculation(function(t){return t.fract()})}sinc(){return this.cloneMatrixDoEachCalculation(function(t){return t.sinc()})}_rot90(t){const n=Matrix._toInteger(t);let e=1;if(1===arguments.length&&(e=(n%4+4)%4),0===e)return this;const r=new Array(this.row_length);for(let t=0;t<this.row_length;t++){r[t]=new Array(this.column_length);for(let n=0;n<this.column_length;n++)r[t][n]=this.matrix_array[t][n]}const i=this.matrix_array;if(1===e){i.splice(this.column_length);for(let t=0;t<this.column_length;t++){t<this.row_length?i[t].splice(this.row_length):i[t]=new Array(this.row_length);for(let n=0;n<this.row_length;n++)i[t][n]=r[this.row_length-n-1][t]}}else if(2===e)for(let t=0;t<this.row_length;t++)for(let n=0;n<this.column_length;n++)i[t][n]=r[this.row_length-t-1][this.column_length-n-1];else if(3===e){i.splice(this.column_length);for(let t=0;t<this.column_length;t++){t<this.row_length?i[t].splice(this.row_length):i[t]=new Array(this.row_length);for(let n=0;n<this.row_length;n++)i[t][n]=r[n][this.column_length-t-1]}}return this.row_length=i.length,this.column_length=i[0].length,this._clearCash(),this}rot90(t){return this.clone()._rot90(t)}_resize(t,n){const e=Matrix._toInteger(t),r=Matrix._toInteger(n);if(e===this.row_length&&r===this.column_length)return this;if(e<=0||r<=0)throw"_resize";const i=Math.max(this.row_length,e),o=Math.max(this.column_length,r),a=this.matrix_array;for(let t=0;t<i;t++){t>=this.row_length&&(a[t]=new Array(o));for(let n=0;n<o;n++)(t>=this.row_length||n>=this.column_length)&&(a[t][n]=Complex.ZERO)}if(this.row_length>e&&a.splice(e),this.column_length>r)for(let t=0;t<a.length;t++)a[t].splice(r);return this.row_length=e,this.column_length=r,this._clearCash(),this}resize(t,n){return this.clone()._resize(t,n)}_deleteRow(t){const n=Matrix._toInteger(t);if(1===this.row_length||this.row_length<=n)throw"_deleteRow";return this.matrix_array.splice(n,1),this.row_length--,this._clearCash(),this}_deleteColumn(t){const n=Matrix._toInteger(t);if(1===this.column_length||this.column_length<=n)throw"_deleteColumn";for(let t=0;t<this.row_length;t++)this.matrix_array[t].splice(n,1);return this.column_length--,this._clearCash(),this}deleteRow(t){return this.clone()._deleteRow(t)}deleteColumn(t){return this.clone()._deleteColumn(t)}_exchangeRow(t,n){const e=Matrix._toInteger(t),r=Matrix._toInteger(n);if(1===this.row_length||this.row_length<=e||this.row_length<=r)throw"_exchangeRow";if(e===r)return this;const i=this.matrix_array[e];return this.matrix_array[e]=this.matrix_array[r],this.matrix_array[r]=i,this._clearCash(),this}_exchangeColumn(t,n){const e=Matrix._toInteger(t),r=Matrix._toInteger(n);if(1===this.column_length||this.column_length<=e||this.column_length<=r)throw"_exchangeColumn";if(e===r)return this;for(let t=0;t<this.row_length;t++){const n=this.matrix_array[t][e];this.matrix_array[t][e]=this.matrix_array[t][r],this.matrix_array[t][r]=n}return this._clearCash(),this}exchangeRow(t,n){return this.clone()._exchangeRow(t,n)}exchangeColumn(t,n){return this.clone()._exchangeColumn(t,n)}_concatRight(t){const n=Matrix._toMatrix(t);if(this.row_length!=n.row_length)throw"_concatRight";for(let t=0;t<this.row_length;t++)for(let e=0;e<n.column_length;e++)this.matrix_array[t].push(n.matrix_array[t][e]);return this.column_length+=n.column_length,this._clearCash(),this}_concatBottom(t){const n=Matrix._toMatrix(t);if(this.column_length!=n.column_length)throw"_concatBottom";for(let t=0;t<n.row_length;t++)this.matrix_array.push(n.matrix_array[t]);return this.row_length+=n.row_length,this._clearCash(),this}concatRight(t){return this.clone()._concatRight(t)}concatBottom(t){return this.clone()._concatBottom(t)}clip(t,n){const e=Matrix._toMatrix(t),r=Matrix._toMatrix(n),i=e.matrix_array,o=r.matrix_array;return this.cloneMatrixDoEachCalculation(function(t,n,a){const s=i[n%e.row_length][a%e.column_length],c=o[n%r.row_length][a%r.column_length];return t.clip(s,c)})}static arange(t,n,e){const r=void 0!==n?Matrix._toComplex(t):Complex.ZERO,i=void 0!==n?Matrix._toComplex(n):Matrix._toComplex(t),o=void 0!==e?Matrix._toComplex(e):Complex.ONE;return new Matrix(MatrixTool.InterpolationCalculation(r,o,i,!1))}circshift(t,n){const e=Matrix._toInteger(t),r=n&&n.dimension?n.dimension:"auto",i=function(t){const n=new Array(t.length);let r=(-e%t.length+t.length)%t.length;for(let e=0;e<t.length;e++)n[e]=t[r++],r===t.length&&(r=0);return n};return this.eachVector(i,r)}roll(t,n){return this.circshift(t,n)}reshape(t,n){const e=Matrix._toInteger(t),r=Matrix._toInteger(n),i=this.row_length*this.column_length,o=e*r;if(i!==o)throw"reshape error. (this_size !== new_size)->("+i+" !== "+o+")";const a=this.matrix_array;let s=0,c=0;const u=new Array(e);for(let t=0;t<e;t++){u[t]=new Array(r);for(let n=0;n<r;n++)u[t][n]=a[c][s],++s===this.column_length&&(s=0,c++)}return new Matrix(u)}fliplr(){return this.flip({dimension:"row"})}flipud(){return this.flip({dimension:"column"})}flip(t){const n=t&&t.dimension?t.dimension:"auto",e=function(t){const n=new Array(t.length);for(let e=0,r=t.length-1;e<t.length;e++,r--)n[e]=t[r];return n};return this.eachVector(e,n)}indexsort(t){const n=Matrix._toMatrix(t);if(n.isMatrix())throw"argsort error. argsort is not vector. ("+n.toOneLineString+")";let e=!1,r=null,i=null;if(n.isRow()){if(this.column_length!==n.column_length)throw"argsort error. (this_size !== new_size)->("+this.column_length+" !== "+n.column_length+")";e=!0,r=this.transpose().matrix_array,i=n.matrix_array[0]}if(n.isColumn()){if(this.row_length!==n.row_length)throw"argsort error. (this_size !== new_size)->("+this.row_length+" !== "+n.row_length+")";r=this.matrix_array,i=n.transpose().matrix_array[0]}const o=new Array(i.length);for(let t=0;t<i.length;t++)o[t]={index:i[t],data:r[t]};const a=function(t,n){return t.index.compareTo(n.index)};{const t=[],n=function(e,r,i,o){if(r<i){const a=Math.floor((r+i)/2);n(e,r,a,o),n(e,a+1,i,o);let s,c,u,l=0;for(s=r;s<=a;s++)t[l++]=e[s];for(s=a+1,c=0,u=r;s<=i&&c<l;)o(e[s],t[c])>=0?e[u++]=t[c++]:e[u++]=e[s++];for(;c<l;)e[u++]=t[c++]}return!0};n(o,0,o.length-1,a)}const s=new Array(i.length);for(let t=0;t<i.length;t++)s[t]=o[t].data;const c=new Matrix(s);return e?c.transpose():c}transpose(){const t=new Array(this.column_length);for(let n=0;n<this.column_length;n++){t[n]=new Array(this.row_length);for(let e=0;e<this.row_length;e++)t[n][e]=this.matrix_array[e][n]}return new Matrix(t)}ctranspose(){return this.transpose().conj()}T(){return this.ctranspose()}inner(t,n=1){return LinearAlgebra.inner(this,t,n)}lup(){return LinearAlgebra.lup(this)}lu(){return LinearAlgebra.lu(this)}linsolve(t){return LinearAlgebra.linsolve(this,t)}qr(){return LinearAlgebra.qr(this)}tridiagonalize(){return LinearAlgebra.tridiagonalize(this)}eig(){return LinearAlgebra.eig(this)}svd(){return LinearAlgebra.svd(this)}inv(){return LinearAlgebra.inv(this)}pinv(){return LinearAlgebra.pinv(this)}gammaln(){return Statistics.gammaln(this)}gamma(){return Statistics.gamma(this)}gammainc(t,n){return Statistics.gammainc(this,t,n)}gampdf(t,n){return Statistics.gampdf(this,t,n)}gamcdf(t,n){return Statistics.gampdf(this,t,n)}gaminv(t,n){return Statistics.gaminv(this,t,n)}beta(t){return Statistics.beta(this,t)}betainc(t,n,e){return Statistics.betainc(this,t,n,e)}betacdf(t,n){return Statistics.betacdf(this,t,n)}betapdf(t,n){return Statistics.betapdf(this,t,n)}betainv(t,n){return Statistics.betainv(this,t,n)}factorial(){return Statistics.factorial(this)}nchoosek(t){return Statistics.nchoosek(this,t)}erf(){return Statistics.erf(this)}erfc(){return Statistics.erfc(this)}normpdf(t=0,n=1){return Statistics.normpdf(this,t,n)}normcdf(t=0,n=1){return Statistics.normcdf(this,t,n)}norminv(t=0,n=1){return Statistics.norminv(this,t,n)}tpdf(t){return Statistics.tpdf(this,t)}tcdf(t){return Statistics.tcdf(this,t)}tinv(t){return Statistics.tinv(this,t)}tdist(t,n){return Statistics.tdist(this,t,n)}tinv2(t){return Statistics.tinv2(this,t)}chi2pdf(t){return Statistics.chi2pdf(this,t)}chi2cdf(t){return Statistics.chi2cdf(this,t)}chi2inv(t){return Statistics.chi2inv(this,t)}fpdf(t,n){return Statistics.fpdf(this,t,n)}fcdf(t,n){return Statistics.fcdf(this,t,n)}finv(t,n){return Statistics.finv(this,t,n)}max(t){return Statistics.max(this,t)}min(t){return Statistics.min(this,t)}sum(t){return Statistics.sum(this,t)}mean(t){return Statistics.mean(this,t)}prod(t){return Statistics.prod(this,t)}geomean(t){return Statistics.geomean(this,t)}median(t){return Statistics.median(this,t)}mode(t){return Statistics.mode(this,t)}moment(t,n){return Statistics.moment(this,t,n)}var(t){return Statistics.var(this,t)}std(t){return Statistics.std(this,t)}mad(t,n){return Statistics.mad(this,t,n)}skewness(t){return Statistics.skewness(this,t)}cov(t){return Statistics.cov(this,t)}normalize(t){return Statistics.normalize(this,t)}corrcoef(t){return Statistics.corrcoef(this,t)}sort(t,n){return Statistics.sort(this,t,n)}fft(t){return Signal.fft(this,t)}ifft(t){return Signal.ifft(this,t)}powerfft(t){return Signal.powerfft(this,t)}dct(t){return Signal.dct(this,t)}idct(t){return Signal.idct(this,t)}fft2(){return Signal.fft2(this)}ifft2(){return Signal.ifft2(this)}dct2(){return Signal.dct2(this)}idct2(){return Signal.idct2(this)}conv(t){return Signal.conv(this,t)}xcorr(t){return Signal.xcorr(this,t)}static window(t,n,e){return Signal.window(t,n,e)}static hann(t,n){return Signal.hann(t,n)}static hamming(t,n){return Signal.hamming(t,n)}fftshift(t){return Signal.fftshift(this,t)}}const random_class=new Random;class ComplexTool{static ToComplexFromString(t){let n=t.replace(/\s/g,"").toLowerCase();if(n=n.replace(/infinity|inf/g,"1e100000"),!/[ij]/.test(n))return{real:parseFloat(n),imag:0};let e,r=0,i=0;return(e=n.match(/[+-]?(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan))($|[+-])/))&&(r=parseFloat(e[0])),(e=n.match(/[+-]?(([0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?)|(nan))?[ij]/))&&(e=e[0].substring(0,e[0].length-1),i=/^[-+]$/.test(e)||0===e.length?"-"===e?-1:1:parseFloat(e)),{real:r,imag:i}}}class Complex{constructor(t){if(1!==arguments.length)throw"Complex Many arguments : "+arguments.length;{const n=t;if(n instanceof Complex)this._re=n._re,this._im=n._im;else if("number"==typeof n)this._re=n,this._im=0;else if(n instanceof Array){if(2!==n.length)throw"Complex Unsupported argument "+arguments;this._re=n[0],this._im=n[1]}else if("string"==typeof n){const t=ComplexTool.ToComplexFromString(n);this._re=t.real,this._im=t.imag}else if(n instanceof Object&&"number"==typeof n._re&&"number"==typeof n._im)this._re=n._re,this._im=n._im;else{if(!(n instanceof Object))throw"Complex Unsupported argument "+arguments;{const t=ComplexTool.ToComplexFromString(n.toString());this._re=t.real,this._im=t.imag}}}}static create(t){return t instanceof Complex?t:new Complex(t)}static valueOf(t){return Complex.create(t)}static _toComplex(t){return t instanceof Complex?t:t instanceof Matrix?Matrix._toComplex(t):new Complex(t)}static _toDouble(t){if("number"==typeof t)return t;const n=Complex._toComplex(t);if(n.isReal())return n.real;throw"not support complex numbers.["+t+"]"}static _toInteger(t){return Math.trunc(Complex._toDouble(t))}get intValue(){return Math.trunc(this.real)}get doubleValue(){return this.real}clone(){return this}toString(){const t=function(t){let n=t.toPrecision(6);if(-1!==n.indexOf("."))n=(n=n.replace(/\.?0+$/,"")).replace(/\.?0+e/,"e");else{if(/inf/i.test(n))return t===Number.POSITIVE_INFINITY?"Inf":"-Inf";if(/nan/i.test(n))return"NaN"}return n};return this.isReal()?t(this._re):0===this._re?t(this._im)+"i":this._im>=0||Number.isNaN(this._im)?t(this._re)+" + "+t(this._im)+"i":t(this._re)+" - "+t(-this._im)+"i"}static rand(){return new Complex(random_class.nextDouble())}static randn(){return new Complex(random_class.nextGaussian())}equals(t,n){const e=Complex._toComplex(t),r=n?Complex._toDouble(n):Number.EPSILON;return this._re===e._re&&this._im===e._im||Math.abs(this._re-e._re)<r&&Math.abs(this._im-e._im)<r}get real(){return this._re}get imag(){return this._im}get norm(){return 0===this._im?Math.abs(this._re):0===this._re?Math.abs(this._im):Math.sqrt(this._re*this._re+this._im*this._im)}get arg(){return 0===this._im?this._re>=0?0:Math.PI:0===this._re?Math.PI*(this._im>=0?.5:-.5):Math.atan2(this._im,this._re)}getDecimalPosition(){const t=function(t){if(!Number.isFinite(t))return 0;let n=t,e=0;for(let t=0;t<20&&!(Math.abs(n-Math.round(n))<=Number.EPSILON);t++)n*=10,e++;return e};return Math.max(t(this.real),t(this.imag))}add(t){const n=new Complex(t);return n._re=this._re+n._re,n._im=this._im+n._im,n}sub(t){const n=new Complex(t);return n._re=this._re-n._re,n._im=this._im-n._im,n}mul(t){const n=new Complex(t);if(0===this._im&&0===n._im)return n._re=this._re*n._re,n;if(0===this._re&&0===n._re)return n._re=-this._im*n._im,n._im=0,n;{const t=this._re*n._re-this._im*n._im,e=this._im*n._re+this._re*n._im;return n._re=t,n._im=e,n}}dot(t){const n=new Complex(t);if(0===this._im&&0===n._im)return n._re=this._re*n._re,n;if(0===this._re&&0===n._re)return n._re=this._im*n._im,n._im=0,n;{const t=this._re*n._re+this._im*n._im,e=-this._im*n._re+this._re*n._im;return n._re=t,n._im=e,n}}div(t){const n=new Complex(t);if(0===this._im&&0===n._im)return n._re=this._re/n._re,n;if(0===this._re&&0===n._re)return n._re=this._im/n._im,n._im=0,n;{const t=this._re*n._re+this._im*n._im,e=this._im*n._re-this._re*n._im,r=1/(n._re*n._re+n._im*n._im);return n._re=t*r,n._im=e*r,n}}mod(t){const n=new Complex(t);if(0!==this._im||0!==n._im)throw"calculation method is undefined.";let e=this._re-n._re*(0|this._re/n._re);return e<0&&(e+=n._re),n._re=e,n}inv(){return 0===this._im?new Complex(1/this._re):0===this._re?new Complex([0,-1/this._im]):Complex.ONE.div(this)}sign(){return 0===this._im?new Complex(0===this._re?0:this._re>0?1:-1):this.div(this.norm)}compareTo(t,n){const e=this,r=Complex._toComplex(t),i=n?Complex._toDouble(n):Number.EPSILON,o=e.real+e.imag,a=r.real+r.imag;return Math.abs(o-a)<i?0:o>a?1:-1}max(t){const n=Complex._toComplex(t);return this.compareTo(n)>=0?this:n}min(t){const n=Complex._toComplex(t);return this.compareTo(n)<=0?this:n}clip(t,n){const e=Complex._toComplex(t),r=Complex._toComplex(n),i=e.compareTo(r);if(1===i)throw"clip(min, max) error. (min > max)->("+e+" > "+r+")";return 0===i?e:1===this.compareTo(r)?r:-1===this.compareTo(e)?e:this}isInteger(t){const n=t?Complex._toDouble(t):Number.EPSILON;return this.isReal()&&Math.abs(this._re-Math.trunc(this._re))<n}isComplexInteger(t){const n=t?Complex._toDouble(t):Number.EPSILON;return Math.abs(this._re-Math.trunc(this._re))<n&&Math.abs(this._im-Math.trunc(this._im))<n}isZero(t){const n=t?Complex._toDouble(t):Number.EPSILON;return Math.abs(this._re)<n&&Math.abs(this._im)<n}isOne(t){const n=t?Complex._toDouble(t):Number.EPSILON;return Math.abs(this._re-1)<n&&Math.abs(this._im)<n}isComplex(t){const n=t?Complex._toDouble(t):Number.EPSILON;return Math.abs(this._im)>=n}isReal(t){const n=t?Complex._toDouble(t):Number.EPSILON;return Math.abs(this._im)<n}isNaN(){return isNaN(this._re)||isNaN(this._im)}isPositive(){return 0<this._re}isNegative(){return 0>this._re}isNotNegative(){return 0<=this._re}isInfinite(){return this._re===Number.POSITIVE_INFINITY||this._im===Number.POSITIVE_INFINITY||this._re===Number.NEGATIVE_INFINITY||this._im===Number.NEGATIVE_INFINITY}isFinite(){return!this.isNaN()&&!this.isInfinite()}abs(){return new Complex(this.norm)}conj(){return 0===this._im?this:new Complex([this._re,-this._im])}negate(){return new Complex([-this._re,-this._im])}pow(t){const n=this,e=new Complex(t);if(e.isReal()){if(n.isReal()&&(n.isNotNegative()||e.isInteger()))return e._re=Math.pow(n._re,e._re),e;{const t=Math.pow(n.norm,e._re),r=n.arg*e._re;return e._re=t*Math.cos(r),e._im=t*Math.sin(r),e}}return e.mul(n.log()).exp()}square(){return 0===this._im?new Complex(this._re*this._re):this.mul(this)}sqrt(){if(this.isReal())return new Complex(this.isNotNegative()?Math.sqrt(this._re):[0,Math.sqrt(-this._re)]);const t=Math.sqrt(this.norm),n=.5*this.arg;return new Complex([t*Math.cos(n),t*Math.sin(n)])}log(){return new Complex(this.isReal()&&this.isNotNegative()?Math.log(this._re):[Math.log(this.norm),this.arg])}exp(){if(this.isReal())return new Complex(Math.exp(this._re));const t=Math.exp(this._re);return new Complex([t*Math.cos(this._im),t*Math.sin(this._im)])}sin(){if(this.isReal())return new Complex(Math.sin(this._re));const t=this.mul(Complex.I).exp(),n=this.mul(Complex.I.negate()).exp();return t.sub(n).div([0,2])}cos(){if(this.isReal())return new Complex(Math.cos(this._re));const t=this.mul(Complex.I).exp(),n=this.mul(Complex.I.negate()).exp();return t.add(n).div(2)}tan(){return this.isReal()?new Complex(Math.tan(this._re)):this.sin().div(this.cos())}atan(){return this.isReal()?new Complex(Math.atan(this._re)):Complex.I.div(Complex.TWO).mul(Complex.I.add(this).div(Complex.I.sub(this)).log())}atan2(t){if(0===arguments.length)return new Complex(this.arg);const n=this,e=Complex._toComplex(t);if(n.isReal()&&e.isReal())return new Complex(Math.atan2(n._re,e._re));throw"calculation method is undefined."}sinc(){if(this.isReal()){if(0===this._re)return Complex.ONE;const t=Math.PI*this._re;return new Complex(Math.sin(t)/t)}const t=this.mul(Complex.PI);return new Complex(t.sin().div(t))}floor(){return new Complex([Math.floor(this._re),Math.floor(this._im)])}ceil(){return new Complex([Math.ceil(this._re),Math.ceil(this._im)])}round(){return new Complex([Math.round(this._re),Math.round(this._im)])}fix(){return new Complex([Math.trunc(this._re),Math.trunc(this._im)])}fract(){return new Complex([this._re-Math.trunc(this._re),this._im-Math.trunc(this._im)])}static get ONE(){return DEFINE$4.ONE}static get TWO(){return DEFINE$4.TWO}static get TEN(){return DEFINE$4.TEN}static get ZERO(){return DEFINE$4.ZERO}static get MINUS_ONE(){return DEFINE$4.MINUS_ONE}static get I(){return DEFINE$4.I}static get PI(){return DEFINE$4.PI}static get E(){return DEFINE$4.E}static get LN2(){return DEFINE$4.LN2}static get LN10(){return DEFINE$4.LN10}static get LOG2E(){return DEFINE$4.LOG2E}static get LOG10E(){return DEFINE$4.LOG10E}static get SQRT2(){return DEFINE$4.SQRT2}static get SQRT1_2(){return DEFINE$4.SQRT1_2}static get HALF(){return DEFINE$4.HALF}static get POSITIVE_INFINITY(){return DEFINE$4.POSITIVE_INFINITY}static get NEGATIVE_INFINITY(){return DEFINE$4.NEGATIVE_INFINITY}static get NaN(){return DEFINE$4.NaN}}const DEFINE$4={ZERO:new Complex(0),ONE:new Complex(1),TWO:new Complex(2),TEN:new Complex(10),MINUS_ONE:new Complex(-1),I:new Complex([0,1]),PI:new Complex(Math.PI),E:new Complex(Math.E),LN2:new Complex(Math.LN2),LN10:new Complex(Math.LN10),LOG2E:new Complex(Math.LOG2E),LOG10E:new Complex(Math.LOG10E),SQRT2:new Complex(Math.SQRT2),SQRT1_2:new Complex(Math.SQRT1_2),HALF:new Complex(.5),POSITIVE_INFINITY:new Complex(Number.POSITIVE_INFINITY),NEGATIVE_INFINITY:new Complex(Number.NEGATIVE_INFINITY),NaN:new Complex(Number.NaN)};class konpeito{static get BigInteger(){return BigInteger}static get BigDecimal(){return BigDecimal}static get RoundingMode(){return RoundingMode}static get MathContext(){return MathContext}static get Fraction(){return Fraction}static get Complex(){return Complex}static get Matrix(){return Matrix}static get Random(){return Random}}export default konpeito;
